<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snakes and Ladders</title>
    <style>
* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
}

body { 
    font-family: 'Segoe UI', sans-serif; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    min-height: 100vh; 
    padding: 20px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    color: #fff; 
}

h1 { 
    font-size: 3em; 
    margin-bottom: 30px; 
    text-shadow: 3px 3px 6px rgba(0,0,0,0.3); 
    animation: float 3s ease-in-out infinite; 
}

@keyframes float { 
    0%, 100% { transform: translateY(0); } 
    50% { transform: translateY(-10px); } 
}

#gameContainer { 
    background: rgba(255,255,255,0.95); 
    padding: 30px; 
    border-radius: 20px; 
    box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
    max-width: 1200px; 
    width: 100%; 
}

#board { 
    display: grid; 
    grid-template-columns: repeat(10, 1fr); 
    grid-template-rows: repeat(10, 1fr); 
    border: 4px solid #333; 
    border-radius: 15px; 
    margin: 0 auto 20px; 
    width: 100%; 
    max-width: 700px; 
    aspect-ratio: 1; 
    background: #fff; 
    box-shadow: inset 0 0 20px rgba(0,0,0,0.1); 
    overflow: hidden; 
}

.square { 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    border: 1px solid rgba(0,0,0,0.1); 
    background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%); 
    font-weight: bold; 
    font-size: 0.9em; 
    color: #333; 
    position: relative; 
    transition: all 0.3s ease; 
}

.square:hover { 
    transform: scale(1.05); 
    z-index: 5; 
}

.snake { 
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); 
    color: white; 
}

.snake::before { 
    content: 'üêç'; 
    position: absolute; 
    font-size: 3em; 
    opacity: 0.3; 
}

.snake::after { 
    content: attr(data-destination); 
    position: absolute; 
    bottom: 2px; 
    right: 2px; 
    background: rgba(0,0,0,0.7); 
    color: white; 
    font-size: 0.7em; 
    padding: 2px 5px; 
    border-radius: 5px; 
    font-weight: bold; 
}

.ladder { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    color: white; 
}

.ladder::before { 
    content: 'ü™ú'; 
    position: absolute; 
    font-size: 3em; 
    opacity: 0.3; 
}

.ladder::after { 
    content: attr(data-destination); 
    position: absolute; 
    top: 2px; 
    right: 2px; 
    background: rgba(0,0,0,0.7); 
    color: white; 
    font-size: 0.7em; 
    padding: 2px 5px; 
    border-radius: 5px; 
    font-weight: bold; 
}

.player { 
    width: 30px; 
    height: 30px; 
    background: radial-gradient(circle, #4dabf7 0%, #1864ab 100%); 
    border-radius: 50%; 
    position: absolute; 
    z-index: 10; 
    box-shadow: 0 4px 8px rgba(0,0,0,0.3); 
    animation: pulse 1s ease-in-out infinite; 
    border: 3px solid white; 
}

@keyframes pulse { 
    0%, 100% { transform: scale(1); } 
    50% { transform: scale(1.1); } 
}

#controls { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 15px; 
    margin-bottom: 20px; 
}

button { 
    padding: 15px 40px; 
    font-size: 20px; 
    font-weight: bold; 
    cursor: pointer; 
    color: white; 
    border: none; 
    border-radius: 50px; 
    transition: all 0.3s ease; 
    text-transform: uppercase; 
    letter-spacing: 1px; 
}

#startButton { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    box-shadow: 0 8px 20px rgba(81,207,102,0.4); 
}

#startButton:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 12px 25px rgba(81,207,102,0.5); 
}

#rollDice { 
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
    box-shadow: 0 8px 20px rgba(79,172,254,0.4); 
}

#rollDice:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 12px 25px rgba(79,172,254,0.5); 
}

button:disabled { 
    background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); 
    cursor: not-allowed; 
    box-shadow: none; 
}

#diceResult { 
    font-size: 28px; 
    font-weight: bold; 
    padding: 15px 30px; 
    background: linear-gradient(135deg, #ffd93d 0%, #ffbc00 100%); 
    border-radius: 15px; 
    color: #333; 
    box-shadow: 0 4px 15px rgba(255,188,0,0.3); 
    min-width: 150px; 
    text-align: center; 
}

#instructions { 
    margin-top: 20px; 
    font-size: 18px; 
    text-align: left; 
    min-height: 80px; 
    padding: 50px 80px; 
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); 
    border-radius: 15px; 
    color: #333; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.1); 
    display: none; 
    line-height: 1.8; 
    max-width: 900px; 
    margin-left: auto; 
    margin-right: auto; 
}

#instructions.active { 
    display: block; 
}

#instructions img { 
    margin: 40px 0; 
    max-width: 100%; 
    height: auto; 
    border-radius: 10px; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.2); 
}

#instructions p { 
    margin: 25px 0; 
    font-size: 17px; 
    line-height: 2; 
}

#instructions strong { 
    font-size: 26px; 
    display: block; 
    margin-bottom: 20px; 
    text-align: center; 
    color: #667eea; 
}

#continueButton { 
    margin-top: 15px; 
    padding: 12px 30px; 
    font-size: 18px; 
    background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); 
    box-shadow: 0 6px 20px rgba(250,82,82,0.4); 
    display: block; 
    margin-left: auto; 
    margin-right: auto; 
}

#continueButton:hover { 
    transform: translateY(-2px); 
    box-shadow: 0 8px 25px rgba(250,82,82,0.5); 
}

#buttoncontainer { 
    margin-top: 20px; 
    display: flex; 
    gap: 15px; 
    justify-content: center; 
    flex-wrap: wrap; 
    width: 100%; 
}

.settings-column-left, .settings-column-right { 
    width: 100%; 
    max-width: 900px; 
}

.settings-column-left {
    margin-bottom: 400px;
}

@media (min-width: 900px) {
    #buttoncontainer { 
        max-width: 1200px; 
        margin-left: auto; 
        margin-right: auto; 
        flex-wrap: nowrap; 
    }
    .settings-column-left { 
        width: 50%; 
        max-width: none; 
    }
    .settings-column-right { 
        width: 50%; 
        max-width: none; 
    }
}

.prize-settings { 
    margin-top: 0px; 
    padding: 20px; 
    background: white; 
    border-radius: 15px; 
    border: 2px solid #667eea; 
}

.prize-settings h3 { 
    color: #667eea; 
    margin-bottom: 15px; 
    text-align: center; 
    display: none;
}

.slider-container { 
    margin: 15px 0; 
}

.slider-label { 
    display: flex; 
    justify-content: space-between; 
    margin-bottom: 5px; 
    color: #333; 
    font-weight: bold; 
}

.slider-label .percentage { 
    color: #667eea; 
}

input[type="range"] { 
    width: 100%; 
    height: 8px; 
    border-radius: 5px; 
    outline: none; 
    -webkit-appearance: none; 
}

input[type="range"]::-webkit-slider-thumb { 
    -webkit-appearance: none; 
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #667eea; 
    cursor: pointer; 
}

input[type="range"]::-moz-range-thumb { 
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #667eea; 
    cursor: pointer; 
}

#ruinSlider { 
    background: linear-gradient(to right, #ffd93d, #ffbc00); 
}

#fullSlider { 
    background: linear-gradient(to right, #51cf66, #37b24d); 
}

#deniedSlider { 
    background: linear-gradient(to right, #adb5bd, #868e96); 
}

#strokingSlider {
    background: linear-gradient(to right, #748ffc, #5c7cfa);
}

#vibeSlider {
    background: linear-gradient(to right, #a78bfa, #8b5cf6);
}

#analSlider {
    background: linear-gradient(to right, #f59f0b, #d97706);
}

.toy-library-item { 
    border: 2px solid #e9ecef; 
    border-radius: 10px; 
    padding: 8px; 
    margin-bottom: 8px; 
    transition: all 0.3s ease; 
}

.toy-library-item:hover { 
    border-color: #667eea; 
    box-shadow: 0 4px 12px rgba(102,126,234,0.2); 
}

.toy-header { 
    display: flex; 
    align-items: center; 
    gap: 10px; 
    font-size: 1em; 
    font-weight: bold; 
    color: #333; 
    margin-bottom: 6px; 
}

.toy-checkbox-wrapper { 
    display: flex; 
    align-items: center; 
}

.toy-checkbox-wrapper input[type="checkbox"] { 
    width: 18px; 
    height: 18px; 
    margin: 0; 
    cursor: pointer; 
    accent-color: #51cf66; 
}

.toy-name { 
    flex: 1; 
}

.toy-controls { 
    display: flex; 
    gap: 8px; 
    align-items: center; 
    flex-wrap: wrap; 
    margin-left: 28px; 
    margin-bottom: 6px; 
}

.toy-controls label { 
    font-size: 0.85em; 
    color: #333; 
    font-weight: 600; 
}

.toy-controls input[type="number"] { 
    width: 55px; 
    padding: 4px; 
    border: 2px solid #667eea; 
    border-radius: 6px; 
    text-align: center; 
}

.set-difficulty { 
    margin-left: 28px; 
    padding: 6px; 
    background: #f8f9fa; 
    border-radius: 6px; 
    margin-top: 6px; 
}

.toy-controls input[type="number"]:disabled { 
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.difficulty-row select:disabled {
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.advanced-settings input:disabled {
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.set-difficulty input[type="checkbox"]:disabled {
    opacity: 0.5;
    cursor: default;
}

.set-difficulty input[type="checkbox"]:disabled + span,
.set-difficulty-item:has(input[type="checkbox"]:disabled) {
    opacity: 0.5;
}

.set-difficulty-item { 
    padding: 4px 0; 
    border-bottom: 1px solid #e9ecef; 
}

.set-difficulty-item:last-child { 
    border-bottom: none; 
}

.difficulty-row { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
}

.difficulty-row > span { 
    font-weight: 600; 
    color: #495057; 
    font-size: 0.9em; 
}

.difficulty-controls { 
    display: flex; 
    gap: 8px; 
    align-items: center; 
}

.difficulty-row select { 
    padding: 3px 6px; 
    border: 2px solid #667eea; 
    border-radius: 4px; 
    background: white; 
    color: #333; 
    cursor: pointer; 
    font-size: 0.9em; 
}

.gear-btn { 
    background: #667eea; 
    color: white; 
    border: none; 
    width: 24px; 
    height: 24px; 
    border-radius: 6px; 
    cursor: pointer; 
    font-size: 12px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    transition: background 0.2s ease; 
}

.gear-btn:hover { 
    background: #5568d3; 
}

.gear-btn.active { 
    background: #51cf66; 
}

.gear-btn:disabled { 
    background: #adb5bd; 
    cursor: default; 
    opacity: 0.5; 
}

.gear-btn:disabled:hover { 
    background: #adb5bd; 
}

.advanced-settings { 
    margin-left: 20px; 
    padding: 6px 10px; 
    background: white; 
    border-radius: 4px; 
    border-left: 3px solid #667eea; 
    font-size: 0.8em; 
    color: #666; 
    display: none; 
    gap: 12px; 
    margin-top: 6px; 
}

.advanced-settings.visible { 
    display: flex; 
}

.advanced-settings label { 
    display: flex; 
    align-items: center; 
    gap: 4px; 
}

.advanced-settings input { 
    width: 50px; 
    padding: 2px 4px; 
    border: 1px solid #dee2e6; 
    border-radius: 3px; 
    text-align: center; 
}

#toyLibraryContainer { 
    background: white; 
    border-radius: 10px; 
    padding: 15px; 
    color: #333;
}

.metronome-container { 
    margin: 20px 0; 
    padding: 20px; 
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
    border-radius: 15px; 
    box-shadow: 0 4px 15px rgba(79,172,254,0.3); 
}

.metronome-display { 
    font-size: 48px; 
    font-weight: bold; 
    color: white; 
    text-align: center; 
    margin: 15px 0; 
    min-height: 60px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
}

.metronome-beat { 
    width: 80px; 
    height: 80px; 
    border-radius: 50%; 
    background: rgba(255,255,255,0.3); 
    margin: 0 auto; 
    transition: all 0.1s ease; 
}

.metronome-beat.active { 
    background: white; 
    transform: scale(1.2); 
    box-shadow: 0 0 20px rgba(255,255,255,0.8); 
}

.metronome-btn { 
    padding: 12px 30px; 
    font-size: 18px; 
    background: white; 
    color: #4facfe; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
    margin: 10px auto; 
    display: block; 
}

.metronome-btn:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 6px 20px rgba(0,0,0,0.3); 
}

.metronome-btn:disabled { 
    opacity: 0.5; 
}

.modal { 
    display: none; 
    position: fixed; 
    z-index: 2000; 
    left: 0; 
    top: 0; 
    width: 100%; 
    height: 100%; 
    background-color: rgba(0,0,0,0.7); 
    backdrop-filter: blur(5px); 
    padding-top: 60px; 
}

.modal-content { 
    background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); 
    margin: 5% auto; 
    padding: 30px; 
    width: 80%; 
    max-width: 600px; 
    border-radius: 20px; 
    box-shadow: 0 20px 60px rgba(0,0,0,0.4); 
    color: #333; 
}

.modal-content h2 { 
    color: #667eea; 
    margin-bottom: 20px; 
}

.modal-content p { 
    line-height: 1.8; 
    margin-bottom: 15px; 
}

.close-btn { 
    color: #aaa; 
    float: right; 
    font-size: 32px; 
    font-weight: bold; 
    cursor: pointer; 
    transition: all 0.3s ease; 
}

.close-btn:hover { 
    color: #667eea; 
    transform: rotate(90deg); 
}

#patchNotesBtn, #resetBtn { 
    position: fixed; 
    top: 20px; 
    padding: 10px 20px; 
    font-size: 14px; 
    font-weight: 600; 
    z-index: 10; 
}

#patchNotesBtn { 
    right: 20px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    box-shadow: 0 4px 15px rgba(102,126,234,0.4); 
}

#resetBtn { 
    left: 20px; 
    background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); 
    box-shadow: 0 4px 15px rgba(250,82,82,0.4); 
}

.prize-result { 
    font-size: 2em; 
    text-align: center; 
    margin: 20px 0; 
    padding: 30px; 
    border-radius: 15px; 
    animation: prizeReveal 0.5s ease-out; 
}

@keyframes prizeReveal { 
    0% { transform: scale(0); opacity: 0; } 
    50% { transform: scale(1.2); } 
    100% { transform: scale(1); opacity: 1; } 
}

.prize-ruin { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    color: white; 
}

.prize-full { 
    background: linear-gradient(135deg, #ffd93d 0%, #ffbc00 100%); 
    color: #333; 
}

.prize-denied { 
    background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); 
    color: white; 
}

.instruction-set-selector { 
    background: white; 
    border-radius: 10px; 
    padding: 15px; 
    border: 2px solid #667eea; 
    margin-bottom: 15px; 
}

.instruction-set-selector label { 
    display: block; 
    padding: 8px; 
    cursor: pointer; 
    color: #333; 
}

.instruction-set-selector input[type="checkbox"] { 
    margin-right: 10px; 
    width: 18px; 
    height: 18px; 
    accent-color: #667eea; 
}

@media (max-width: 600px) { 
    h1 { 
        font-size: 2em; 
    } 
    #gameContainer { 
        padding: 20px; 
    } 
    .square { 
        font-size: 0.7em; 
    } 
    .player { 
        width: 20px; 
        height: 20px; 
    } 
}
    </style>
</head>
<body>
    <h1>üé≤ Snakes and Ladders üé≤</h1>
    <div id="gameContainer">
        <div id="board"></div>
        <div id="controls">
            <button id="startButton">üéÆ Start Game</button>
            <div style="display: flex; gap: 10px; align-items: center;">
                <button id="rollDice" style="display: none;">üé≤ Roll Dice</button>
                <input type="number" id="testJumpInput" min="1" max="100" placeholder="or jump to #" 
                       style="display: none; width: 100px; padding: 8px; border: 2px solid #667eea; border-radius: 8px; font-size: 14px;">
            </div>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div id="diceResult" style="display: none;">Dice: -</div>
                <div id="turnCounter" style="display: none; font-size: 20px; font-weight: bold; padding: 12px 25px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; color: white; box-shadow: 0 4px 15px rgba(102,126,234,0.3);">Turn: 0</div>
            </div>
        </div>
        <div id="instructions"></div>
        <div id="buttoncontainer">
            <div class="settings-column-left">
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üë§ Player Name:</label>
                <input type="text" id="playerNameInput" placeholder="Enter your name" style="width: 100%; padding: 12px; border: 2px solid #667eea; border-radius: 10px; font-size: 16px; margin-bottom: 15px; box-sizing: border-box;">
                
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üì¶ Select Instruction Sets:</label>
                <div id="instructionSetCheckboxes" class="instruction-set-selector">
                    <label><input type="checkbox" value="apple"> Anal Set üçé</label>
                    <label><input type="checkbox" value="digging"> Deepthroat ‚õèÔ∏è</label>
                    <label><input type="checkbox" value="dressup"> Painplay üé®</label>
                    <label><input type="checkbox" value="teaseanddenial"> Tease And Denial üéØ</label>
                </div>

                <label style="display: block; font-weight: bold; color: #333; margin-top: 15px; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üéÆ Select Toys:</label>
                <div style="background: white; padding: 12px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #dee2e6;">
                    <div style="font-weight: 600; color: #333; margin-bottom: 8px;">üìä Continuous Task Probability:</div>
                    <div style="display: flex; gap: 15px; font-size: 14px;">
                        <span style="color: #51cf66; font-weight: 500;">‚ûï Add: <span id="totalAddProbability" style="font-weight: 700;">0%</span></span>
                        <span style="color: #ff6b6b; font-weight: 500;">‚ûñ Remove: <span id="totalRemoveProbability" style="font-weight: 700;">0%</span></span>
                    </div>
                </div>
                <div id="toyLibraryContainer"></div>
            </div>
            
            <div class="settings-column-right">
                <!-- Final Challenges Section -->
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üèÜ Final Challenges:</label>
                <div class="prize-settings">
                    <h3>üèÜ Final Challenges</h3>
                    <p style="color: #666; font-size: 14px; margin-bottom: 15px;">Set probabilities for each final challenge type. These are separate from the main game toys.</p>
                    
                    <div class="slider-container">
                        <div class="slider-label"><span>ü§≤ Stroking:</span><span class="percentage" id="strokingPercent">33%</span></div>
                        <input type="range" id="strokingSlider" min="0" max="100" value="33">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>üíé Vibe:</span><span class="percentage" id="vibePercent">33%</span></div>
                        <input type="range" id="vibeSlider" min="0" max="100" value="33">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>üîç Anal:</span><span class="percentage" id="analPercent">34%</span></div>
                        <input type="range" id="analSlider" min="0" max="100" value="34">
                    </div>
                    
                    <!-- Challenge Types -->
                    <div style="margin-top: 25px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                        <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">Challenge Types & Difficulty:</h4>
                        
                        <!-- Stroking -->
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div style="font-weight: 600; color: #5c7cfa;">ü§≤ Stroking:</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 12px; color: #666;">Difficulty:</span>
                                    <select id="strokingDifficulty" style="padding: 4px 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px; cursor: pointer; background: white;">
                                        <option value="easy">Easy</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="stroking_icyhot" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">Icy Hot</span>
                                    <input type="number" id="stroking_icyhot_chance" min="0" max="100" value="10" style="width: 50px; padding: 2px 4px; border: 1px solid #dee2e6; border-radius: 4px; text-align: center; font-size: 12px;" placeholder="%">
                                    <span style="font-size: 12px; color: #666;">%</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="stroking_icewater" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">Ice Water</span>
                                    <input type="number" id="stroking_icewater_chance" min="0" max="100" value="10" style="width: 50px; padding: 2px 4px; border: 1px solid #dee2e6; border-radius: 4px; text-align: center; font-size: 12px;" placeholder="%">
                                    <span style="font-size: 12px; color: #666;">%</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="stroking_ktb" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">KTB</span>
                                    <input type="number" id="stroking_ktb_chance" min="0" max="100" value="10" style="width: 50px; padding: 2px 4px; border: 1px solid #dee2e6; border-radius: 4px; text-align: center; font-size: 12px;" placeholder="%">
                                    <span style="font-size: 12px; color: #666;">%</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="stroking_ballsqueeze" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">Ball Squeeze</span>
                                    <input type="number" id="stroking_ballsqueeze_chance" min="0" max="100" value="10" style="width: 50px; padding: 2px 4px; border: 1px solid #dee2e6; border-radius: 4px; text-align: center; font-size: 12px;" placeholder="%">
                                    <span style="font-size: 12px; color: #666;">%</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="stroking_2finger" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">2 Finger</span>
                                    <input type="number" id="stroking_2finger_chance" min="0" max="100" value="10" style="width: 50px; padding: 2px 4px; border: 1px solid #dee2e6; border-radius: 4px; text-align: center; font-size: 12px;" placeholder="%">
                                    <span style="font-size: 12px; color: #666;">%</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Vibe -->
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div style="font-weight: 600; color: #8b5cf6;">üíé Vibe:</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 12px; color: #666;">Difficulty:</span>
                                    <select id="vibeDifficulty" style="padding: 4px 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px; cursor: pointer; background: white;">
                                        <option value="easy">Easy</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="vibe_icyhot" style="width: 16px; height: 16px; cursor: pointer; accent-color: #8b5cf6;">
                                    <span style="color: #495057; font-size: 14px;">Icy Hot</span>
                                    <input type="number" id="vibe_icyhot_chance" min="0" max="100" value="10" style="width: 50px; padding: 2px 4px; border: 1px solid #dee2e6; border-radius: 4px; text-align: center; font-size: 12px;" placeholder="%">
                                    <span style="font-size: 12px; color: #666;">%</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="vibe_icewater" style="width: 16px; height: 16px; cursor: pointer; accent-color: #8b5cf6;">
                                    <span style="color: #495057; font-size: 14px;">Ice Water</span>
                                    <input type="number" id="vibe_icewater_chance" min="0" max="100" value="10" style="width: 50px; padding: 2px 4px; border: 1px solid #dee2e6; border-radius: 4px; text-align: center; font-size: 12px;" placeholder="%">
                                    <span style="font-size: 12px; color: #666;">%</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Anal -->
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div style="font-weight: 600; color: #d97706;">üîç Anal:</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 12px; color: #666;">Difficulty:</span>
                                    <select id="analDifficulty" style="padding: 4px 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px; cursor: pointer; background: white;">
                                        <option value="easy">Easy</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="anal_vibe" style="width: 16px; height: 16px; cursor: pointer; accent-color: #d97706;">
                                    <span style="color: #495057; font-size: 14px;">Vibe</span>
                                    <input type="number" id="anal_vibe_chance" min="0" max="100" value="10" style="width: 50px; padding: 2px 4px; border: 1px solid #dee2e6; border-radius: 4px; text-align: center; font-size: 12px;" placeholder="%">
                                    <span style="font-size: 12px; color: #666;">%</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Modifiers -->
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #e9ecef;">
                            <div style="font-weight: 600; color: #333; margin-bottom: 8px;">üé≤ Modifiers (chance-based):</div>
                            <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="modifier_ce" style="width: 16px; height: 16px; cursor: pointer; accent-color: #667eea;">
                                    <span style="color: #495057; font-size: 14px;">CE (Cum Eating)</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="modifier_pf" style="width: 16px; height: 16px; cursor: pointer; accent-color: #667eea;">
                                    <span style="color: #495057; font-size: 14px;">PF (Post Finish)</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px; margin-top: 20px;">üéÅ Prize Probabilities:</label>
                <div class="prize-settings">
                    <h3>üéÅ Prize Probabilities</h3>
                    <div class="slider-container">
                        <div class="slider-label"><span>üèÜ Full:</span><span class="percentage" id="fullPercent">33%</span></div>
                        <input type="range" id="fullSlider" min="0" max="100" value="33">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>üéâ Ruin:</span><span class="percentage" id="ruinPercent">33%</span></div>
                        <input type="range" id="ruinSlider" min="0" max="100" value="33">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>‚ùå Denial:</span><span class="percentage" id="deniedPercent">34%</span></div>
                        <input type="range" id="deniedSlider" min="0" max="100" value="34">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <button id="resetBtn">üîÑ Reset</button>
    <button id="patchNotesBtn">üìã Notes</button>
    
    <div id="patchNotesModal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>üìã Patch Notes</h2>
            <p><strong>Ver 0.5:</strong> Modifier system with add/remove chances & toy quantities</p>
        </div>
    </div>
    
    <div id="resetModal" class="modal">
        <div class="modal-content">
            <h2>‚ö†Ô∏è Reset Game?</h2>
            <p style="font-size: 18px; margin: 20px 0;">You will lose all progress!</p>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                <button id="confirmReset" style="padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold;">Yes</button>
                <button id="cancelReset" style="padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold;">Cancel</button>
            </div>
        </div>
    </div>
    
    <script>
// DOM Elements
const board = document.getElementById('board');
const diceResult = document.getElementById('diceResult');
const turnCounter = document.getElementById('turnCounter');
const instructions = document.getElementById('instructions');
const startButton = document.getElementById('startButton');
const rollDiceButton = document.getElementById('rollDice');
const continueButton = document.createElement('button');
continueButton.id = "continueButton";
continueButton.textContent = "‚úì Complete";

// Game Constants
const boardSize = 10;
const totalSquares = 100;
const player = document.createElement('div');
player.classList.add('player');

const snakes = {16:6, 47:26, 49:11, 56:53, 62:19, 64:60, 87:24, 93:73, 95:75, 98:78};
const ladders = {1:38, 4:14, 9:31, 21:42, 28:84, 36:44, 51:67, 71:91, 80:99};

// Game State
let audioContext = null;
let currentMetronomeTask = null;
let toyDifficulties = {};
let gameStarted = false;
let playerPosition = 0;
let turnCount = 0;
let turnCountBySet = {}; // Track turns per set (e.g., {dressup: 5, teaseanddenial: 3})
let turnCountByToy = {}; // Track turns per set-toy combo (e.g., {dressup_pegs: 3, teaseanddenial_cage: 2})
let lastSelectedSet = {}; // Track which set each toy was last selected from (e.g., {pegs: 'dressup', cage: 'teaseanddenial'})
let completedOnlyOnceTasks = {}; // Track which onlyOnce tasks have been completed (e.g., {teaseanddenial_cage_always: true})
let selectedSets = [];
let prizeSettings = {full: 33, ruin: 33, denied: 34};
let toyQuantities = {};
let toyModifiers = {};
let expandedAdvancedSettings = {}; // Track which toys have advanced settings expanded
let playerName = '';
let toySetEnabled = {};
let toyChecked = {};

// Cage-specific state (always available, not tied to Tease And Denial selection)
let cageLocked = false;
let cageWorn = false;

// Final challenge state
let finalChallengeSettings = {
    stroking: 33,
    vibe: 33,
    anal: 34
};

// Final challenge types enabled
let finalChallengeTypes = {
    stroking_icyhot: false,
    stroking_icewater: false,
    stroking_ktb: false,
    stroking_ballsqueeze: false,
    stroking_2finger: false,
    vibe_icyhot: false,
    vibe_icewater: false,
    anal_vibe: false
};

// Final challenge modifier percentages (chance to be applied)
let finalChallengeModifierChances = {
    stroking_icyhot: 10,
    stroking_icewater: 10,
    stroking_ktb: 10,
    stroking_ballsqueeze: 10,
    stroking_2finger: 10,
    vibe_icyhot: 10,
    vibe_icewater: 10,
    anal_vibe: 10
};

// Final challenge difficulties
let finalChallengeDifficulties = {
    stroking: 'medium',
    vibe: 'medium',
    anal: 'medium'
};

// Final challenge modifiers
let finalChallengeModifiers = {
    ce: false,
    pf: false
};

// Body part capacity system
const bodyParts = {
    Mo: { name: "Mo", items: [] },
    Ba: { name: "Ba", items: [] },
    Bu: { name: "Bu", items: [] },
    As: { name: "As", items: [] },
    Ni: { name: "Ni", items: [] },
    Ha: { name: "Ha", items: [] },
    Bo: { name: "Bo", items: [] },
    Pe: { name: "Pe", items: [] }
};

// Clothes Pegs max count per body part
const clothespegsMaxCount = {
    'Ba': 20,
    'Ni': 2,
    'Mo': 3,
    'Bu': 1,
    'As': 1,
    'Ha': 1,
    'Bo': 1,
    'Pe': 1
};

// List of toys that can be worn/held on body parts
const wearableToys = new Set(['pegs', 'silly_shirt', 'stick_a', 'stick_m', 'metal_stick', 'tail', 'cage', 'hand', 'vibe']);

function isToyWearable(toyId) {
    return wearableToys.has(toyId);
}

function isBodyPartEmpty(bodyPart) {
    return bodyPartState[bodyPart].items.length === 0;
}

function hasClothesPegs(bodyPart) {
    return bodyPartState[bodyPart].items.some(item => item === 'pegs');
}

function hasRegularToys(bodyPart) {
    return bodyPartState[bodyPart].items.some(item => item !== 'pegs');
}

function hasClothesPegCount(bodyPart) {
    return bodyPartState[bodyPart].items.filter(item => item === 'pegs').length;
}

function getClothesPegMax(bodyPart) {
    return clothespegsMaxCount[bodyPart] || 1;
}

let bodyPartState = JSON.parse(JSON.stringify(bodyParts));

function getTaskConditions() {
    return {
        // Player info
        name: playerName || 'Player',
        playerPosition: playerPosition,
        turnCount: turnCount,
        
        // Turn count tracking
        getTurnCountForSet: (setId) => turnCountBySet[setId] || 0,
        getTurnCountForToy: (toyKey) => turnCountByToy[toyKey] || 0,
        getLastSelectedSet: (toyId) => lastSelectedSet[toyId] || null,
        
        // Cage state
        cageLocked: cageLocked,
        
        // Selected sets
        selectedSets: selectedSets,
        hasSet: (setId) => selectedSets.includes(setId),
        
        // Toy availability checks
        toyChecked: (toyId) => toyChecked[toyId] === true,
        toySetEnabled: (toyKey) => toySetEnabled[toyKey] === true,
        toyQuantity: (toyKey) => toyQuantities[toyKey] || 0,
        
        // Toy holding checks
        isHolding: (toyId) => {
            for (const part of Object.values(bodyPartState)) {
                if (part.items.includes(toyId)) return true;
            }
            return false;
        },
        
        // Get all body parts holding a specific toy
        getBodyPartsHolding: (toyId) => {
            const parts = [];
            for (const [partKey, part] of Object.entries(bodyPartState)) {
                if (part.items.includes(toyId)) {
                    parts.push({ key: partKey, name: part.name });
                }
            }
            return parts;
        },
        
        // Count toys
        countToy: (toyId) => {
            let count = 0;
            for (const part of Object.values(bodyPartState)) {
                count += part.items.filter(item => item === toyId).length;
            }
            return count;
        },
        
        countToyInBodyPart: (toyId, bodyPart) => {
            return bodyPartState[bodyPart].items.filter(item => item === toyId).length;
        },
        
        // Body part checks
        getBodyPart: (bodyPartKey) => {
            return bodyPartState[bodyPartKey];
        },
        
        bodyPartEmpty: (bodyPartKey) => {
            return isBodyPartEmpty(bodyPartKey);
        },
        
        bodyPartHas: (bodyPartKey, toyId) => {
            return bodyPartState[bodyPartKey].items.includes(toyId);
        },
        
        bodyPartHasRegularToys: (bodyPartKey) => {
            return hasRegularToys(bodyPartKey);
        },
        
        bodyPartHasClothesPegs: (bodyPartKey) => {
            return hasClothesPegs(bodyPartKey);
        },
        
        isBodyPartOccupied: (bodyPartKey) => {
            return bodyPartState[bodyPartKey] && !isBodyPartEmpty(bodyPartKey);
        },
        
        canBodyPartHold: (bodyPartKey, toyId) => {
            return canAddToyToBodyPart(bodyPartKey, toyId);
        },
        
        // Multiple toy checks
        hasMultiple: (toyIds) => {
            return toyIds.every(toyId => {
                for (const part of Object.values(bodyPartState)) {
                    if (part.items.includes(toyId)) return true;
                }
                return false;
            });
        },
        
        hasAny: (toyIds) => {
            return toyIds.some(toyId => {
                for (const part of Object.values(bodyPartState)) {
                    if (part.items.includes(toyId)) return true;
                }
                return false;
            });
        },
        
        // Get all held items
        getAllHeldItems: () => {
            const items = [];
            for (const part of Object.values(bodyPartState)) {
                items.push(...part.items);
            }
            return items;
        },
        
        // Get full body part state
        getBodyPartState: () => bodyPartState,
        
        // Utility
        randomChance: (percent) => {
            return Math.random() * 100 < percent;
        }
    };
}

// Helper function to get difficulty value based on difficulty setting
function getDifficultyValue(difficulty, easyVal, mediumVal, hardVal) {
    if (difficulty === 'easy') return easyVal;
    if (difficulty === 'medium') return mediumVal;
    if (difficulty === 'hard') return hardVal;
    return mediumVal; // default
}

// Instruction Sets
const instructionSets = {
    dressup: {
        name: "Painplay",
        toys: [
            {id: "pegs", name: "Clothes Pegs üé®"},
            {id: "silly_shirt", name: "Clamps üëï"},
            {id: "wristband", name: "KTB ‚åö"},
            {id: "hand", name: "Hand ‚úã"},
            {id: "vibe", name: "Vibe üíé"}
        ],
        tasks: {
            pegs: [
                {
                    // STANDARD TASK: Apply clothespegs
                    // Difficulty: Easy=3, Medium=5, Hard=8 clothespegs
                    // No conditions - always available
                    getDifficulty: d => `<strong>Clothes Peg Challenge</strong><p>Apply ${d=='easy'?3:d=='medium'?5:8} clothespegs to yourself.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard clothespeg task. Difficulty: Easy=3, Medium=5, Hard=8 pegs.</em></p><img src="https://picsum.photos/seed/peg1/800/600"/>`
                },
                {
                    // ADD TASK: Add clothespegs to Ba
                    // Difficulty: Easy=3, Medium=5, Hard=8 clothespegs
                    type: 'add', 
                    bodyPart: 'Ba', 
                    quantity: d => d=='easy'?3:d=='medium'?5:8
                },
                {
                    // REMOVE TASK: Remove clothespegs from Ba
                    // Difficulty: Easy=3, Medium=5, Hard=8 clothespegs
                    type: 'remove', 
                    bodyPart: 'Ba', 
                    quantity: d => d=='easy'?3:d=='medium'?5:8
                }
            ],
            silly_shirt: [
                {
                    // DYNAMIC TASK: Multi-toy task with conditions
                    // CONDITIONS:
                    //   - Only available if: Anal set is selected OR Ba has clothespegs
                    // DYNAMIC BEHAVIOR:
                    //   - If wearing clamps: asks to spin (uses clamps difficulty: Easy=5s, Medium=10s, Hard=15s)
                    //   - If not wearing: asks to put it on
                    //   - Adds special comment if Anal set is active
                    //   - If Ba can hold more pegs: adds requirement to add clothespegs (uses peg difficulty: Easy=3, Medium=5, Hard=8)
                    //   - Comments on existing clothespeg count in Ba (0, <5, <15, 15+)
                    canSelect: (c) => {
                        return c.hasSet('apple') || c.countToyInBodyPart('pegs', 'Ba') > 0;
                    },
                    getDifficulty: (primaryDifficulty, c, diffMap) => {
                        let html = '<strong>Clamps Task</strong><p>';
                        
                        const shirtDiff = diffMap['silly_shirt'] || 'medium';
                        const pegDiff = diffMap['pegs'] || 'medium';
                        
                        if (c.bodyPartHas('Ni', 'silly_shirt')) {
                            const spinTime = getDifficultyValue(shirtDiff, 5, 10, 15);
                            html += `Spin around with the clamps on for ${spinTime} seconds!`;
                        } else {
                            html += 'Put on the clamps';
                            if (c.hasSet('apple')) {
                                html += ' (the Anal set appreciates fashion)';
                            }
                            html += '.';
                        }
                        
                        const baPegs = c.countToyInBodyPart('pegs', 'Ba');
                        const pegCount = getDifficultyValue(pegDiff, 3, 5, 8);
                        
                        if (c.canBodyPartHold('Ba', 'pegs')) {
                            html += `<br><br>Also add ${pegCount} clothespegs to Ba.`;
                        }
                        
                        if (baPegs > 0) {
                            html += '<br><br><em>';
                            if (baPegs < 5) {
                                html += "Just a few clothespegs... not bad.";
                            } else if (baPegs < 15) {
                                html += "That's quite a few clothespegs!";
                            } else {
                                html += "Wow! So many clothespegs!";
                            }
                            html += '</em>';
                        }
                        
                        html += '</p>';
                        html += '<p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Dynamic multi-toy task. ';
                        html += 'Condition: Only appears if Anal set selected OR Ba has clothespegs. ';
                        html += 'Clamps difficulty (Easy=5s, Med=10s, Hard=15s). ';
                        html += 'Clothes Peg difficulty (Easy=3, Med=5, Hard=8). ';
                        html += 'Changes based on: wearing shirt, Anal set active, Ba peg count, if Ba can hold more.</em></p>';
                        html += '<img src="https://picsum.photos/seed/shirt1/800/600"/>';
                        return html;
                    }
                },
                {
                    // ADD TASK: Put on clamps to Ni
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Ni'
                },
                {
                    // REMOVE TASK: Take off clamps from Ni
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Ni'
                }
            ],
            wristband: [
                {
                    // STANDARD TASK: Spin ktb
                    // Difficulty: Easy=5, Medium=10, Hard=15 spins
                    // No conditions - always available
                    getDifficulty: d => `<strong>KTB Spin</strong><p>Spin the ktb around your wrist ${d=='easy'?5:d=='medium'?10:15} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard ktb task. Difficulty: Easy=5, Medium=10, Hard=15 spins.</em></p><img src="https://picsum.photos/seed/wrist1/800/600"/>`
                }
            ],
            hand: [
                {
                    // STANDARD TASK: Wave hand
                    // Difficulty: Easy=10, Medium=15, Hard=20 waves
                    // No conditions - always available
                    getDifficulty: d => `<strong>Hand Wave</strong><p>Wave your hand ${d=='easy'?10:d=='medium'?15:20} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard hand wave task. Difficulty: Easy=10, Medium=15, Hard=20 waves.</em></p><img src="https://picsum.photos/seed/hand1/800/600"/>`
                },
                {
                    // RED LIGHT GREEN LIGHT TASK: Jump on green, stop on red
                    // Difficulty: Easy=15s, Medium=20s, Hard=25s duration
                    // No conditions - always available
                    type: 'redlight', 
                    getDifficulty: d => d=='easy'?15000:d=='medium'?20000:25000
                }
            ],
            vibe: [
                {
                    // STANDARD TASK: Hold vibe steady
                    // Difficulty: Easy=5, Medium=10, Hard=15 seconds
                    // No conditions - always available
                    getDifficulty: (d, c, diffMap) => {
                        const seconds = d === 'easy' ? 5 : d === 'hard' ? 15 : 10;
                        const isCageWorn = c.isHolding('cage');
                        
                        if (isCageWorn) {
                            return `<strong>Vibe Hold</strong><p>Hold the vibe steady for ${seconds} seconds while wearing the cage.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Vibe task with cage worn. Difficulty: Easy=5s, Medium=10s, Hard=15s.</em></p><img src="https://picsum.photos/seed/vibeprision/800/600"/>`;
                        } else {
                            return `<strong>Vibe Hold</strong><p>Hold the vibe steady for ${seconds} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard vibe task. Difficulty: Easy=5s, Medium=10s, Hard=15s.</em></p><img src="https://picsum.photos/seed/vibe1/800/600"/>`;
                        }
                    }
                }
            ]
        }
    },
    apple: {
        name: "Anal Set",
        toys: [
            {id: "stick_a", name: "Dildo A ü™µ"},
            {id: "metal_stick", name: "Metal Wand üî©"},
            {id: "tail", name: "Plug ü¶ä"},
            {id: "vibe", name: "Vibe üíé"},
            {id: "cage", name: "Cage üîí"}
        ],
        tasks: {
            stick_a: [
                {
                    // STANDARD TASK: Balance dildo A
                    // Difficulty: Easy=3, Medium=5, Hard=8 seconds
                    // No conditions - always available
                    getDifficulty: d => `<strong>Dildo A Balance</strong><p>Balance the dildo A on your hand for ${d=='easy'?3:d=='medium'?5:8} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard dildo A task. Difficulty: Easy=3s, Medium=5s, Hard=8s.</em></p><img src="https://picsum.photos/seed/stick1/800/600"/>`
                },
                {
                    // ADD TASK: Add dildo A to Bu
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Bu'
                },
                {
                    // REMOVE TASK: Remove dildo A from Bu
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Bu'
                }
            ],
            metal_stick: [
                {
                    // STANDARD TASK: Tap metal wand
                    // Difficulty: Easy=10, Medium=15, Hard=20 taps
                    // No conditions - always available
                    getDifficulty: d => `<strong>Metal Wand Tap</strong><p>Tap the metal wand on the ground ${d=='easy'?10:d=='medium'?15:20} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard metal wand task. Difficulty: Easy=10, Medium=15, Hard=20 taps.</em></p><img src="https://picsum.photos/seed/metal1/800/600"/>`
                },
                {
                    // ADD TASK: Add metal wand to Bu
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Bu'
                },
                {
                    // REMOVE TASK: Remove metal wand from Bu
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Bu'
                }
            ],
            tail: [
                {
                    // STANDARD TASK: Wag plug
                    // Difficulty: Easy=5, Medium=10, Hard=15 wags
                    // No conditions - always available
                    getDifficulty: d => `<strong>Plug Wag</strong><p>Wag your plug ${d=='easy'?5:d=='medium'?10:15} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard plug task. Difficulty: Easy=5, Medium=10, Hard=15 wags.</em></p><img src="https://picsum.photos/seed/tail1/800/600"/>`
                },
                {
                    // ADD TASK: Add plug to Bu
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Bu'
                },
                {
                    // REMOVE TASK: Remove plug from Bu
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Bu'
                }
            ],
            vibe: [
                {
                    // STANDARD TASK: Shake vibe
                    // Difficulty: Easy=5, Medium=10, Hard=15 shakes
                    // No conditions - always available
                    getDifficulty: (d, c, diffMap) => {
                        const count = d === 'easy' ? 5 : d === 'hard' ? 15 : 10;
                        const isCageWorn = c.isHolding('cage');
                        
                        if (isCageWorn) {
                            return `<strong>Vibe Shake</strong><p>Shake the vibe ${count} times while wearing the cage.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Vibe shake task with cage worn. Difficulty: Easy=5, Medium=10, Hard=15 shakes.</em></p><img src="https://picsum.photos/seed/vibeshakecage/800/600"/>`;
                        } else {
                            return `<strong>Vibe Shake</strong><p>Shake the vibe ${count} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard vibe shake task. Difficulty: Easy=5, Medium=10, Hard=15 shakes.</em></p><img src="https://picsum.photos/seed/vibe2/800/600"/>`;
                        }
                    }
                }
            ],
            cage: [
                {
                    // TASK: Inspect the cage
                    // DIFFICULTY: Easy=5sec, Medium=10sec, Hard=15sec
                    // CONDITIONS: None (always available)
                    getDifficulty: d => `<strong>Cage Inspection</strong><p>Carefully inspect the cage for ${d=='easy'?5:d=='medium'?10:15} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Anal cage task. Difficulty: Easy=5s, Medium=10s, Hard=15s.</em></p><img src="https://picsum.photos/seed/cage2/800/600"/>`
                },
                {
                    // ADD TASK: Add cage to Pe
                    // Locked status affects whether this can be rolled
                    type: 'add', 
                    bodyPart: 'Pe'
                },
                {
                    // REMOVE TASK: Remove cage from Pe
                    // Locked status affects whether this can be rolled
                    type: 'remove', 
                    bodyPart: 'Pe'
                }
            ]
        }
    },
    digging: {
        name: "Deepthroat",
        toys: [
            {id: "stick_m", name: "Dildo M ü™µ"},
            {id: "hand", name: "Hand ‚úã"}
        ],
        tasks: {
            stick_m: [
                {
                    // STANDARD TASK: Dig with dildo M
                    // Difficulty: Easy=3, Medium=5, Hard=8 digging motions
                    // No conditions - always available
                    getDifficulty: d => `<strong>Dig with Dildo M</strong><p>Use the dildo M to make ${d=='easy'?3:d=='medium'?5:8} digging motions.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard dildo M task. Difficulty: Easy=3, Medium=5, Hard=8 motions.</em></p><img src="https://picsum.photos/seed/dig1/800/600"/>`
                },
                {
                    // ADD TASK: Add dildo M to Mo
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Mo'
                },
                {
                    // REMOVE TASK: Remove dildo M from Mo
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Mo'
                }
            ],
            hand: [
                {
                    // STANDARD TASK: Hand digging motions
                    // Difficulty: Easy=10, Medium=15, Hard=20 motions
                    // No conditions - always available
                    getDifficulty: d => `<strong>Hand Digging</strong><p>Make digging motions with your hands ${d=='easy'?10:d=='medium'?15:20} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard hand digging task. Difficulty: Easy=10, Medium=15, Hard=20 motions.</em></p><img src="https://picsum.photos/seed/dighand1/800/600"/>`
                }
            ]
        }
    },
    teaseanddenial: {
        name: "Tease And Denial",
        toys: [
            {id: "vibe", name: "Vibe üíé"},
            {id: "hand", name: "Hand ‚úã"},
            {id: "cage", name: "Cage üîí"}
        ],
        tasks: {
            vibe: [
                {
                    // STANDARD TASK: Control vibe settings
                    // Difficulty: Easy=10, Medium=20, Hard=30 seconds
                    // No conditions - always available
                    getDifficulty: (d, c, diffMap) => {
                        const seconds = d === 'easy' ? 10 : d === 'hard' ? 30 : 20;
                        const isCageWorn = c.isHolding('cage');
                        
                        if (isCageWorn) {
                            return `<strong>Vibe Control</strong><p>Control the vibe settings for ${seconds} seconds while wearing the cage.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Vibe control task with cage worn. Difficulty: Easy=10s, Medium=20s, Hard=30s.</em></p><img src="https://picsum.photos/seed/vibecontrolcage/800/600"/>`;
                        } else {
                            return `<strong>Vibe Control</strong><p>Control the vibe settings for ${seconds} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard vibe control task. Difficulty: Easy=10s, Medium=20s, Hard=30s.</em></p><img src="https://picsum.photos/seed/vibe3/800/600"/>`;
                        }
                    }
                }
            ],
            hand: [
                {
                    // STANDARD TASK: Hand stroking
                    // Difficulty: Easy=8, Medium=12, Hard=16 stroking
                    // No conditions - always available
                    getDifficulty: d => `<strong>Hand Gesture</strong><p>Make hand stroking ${d=='easy'?8:d=='medium'?12:16} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard hand stroke task. Difficulty: Easy=8, Medium=12, Hard=16 stroking.</em></p><img src="https://picsum.photos/seed/handteaseanddenial1/800/600"/>`
                }
            ],
            cage: [
                {
                    // SPECIAL ALWAYS TASK: Put on cage after 2 Tease And Denial hand tasks
                    // CONDITIONS: Tease And Denial selected, Cage can be worn on Pe, Rolled 2+ Tease And Denial hand tasks
                    // This task is "always" selected when conditions are met (overrides normal task selection)
                    alwaysSelect: (c) => {
                        // Check if we've rolled at least 2 Tease And Denial hand tasks
                        const handCount = c.getTurnCountForToy('teaseanddenial_hand');
                        if (handCount < 2) {
                            return false;
                        }
                        // Check Tease And Denial is selected
                        if (!c.hasSet('teaseanddenial')) {
                            return false;
                        }
                        // Check if cage toy is checked
                        if (!c.toyChecked('cage')) {
                            return false;
                        }
                        // Check if Pe can hold cage
                        const canHold = c.canBodyPartHold('Pe', 'cage');
                        if (!canHold) {
                            return false;
                        }
                        return true;
                    },
                    excludeFromNormalPool: true,  // Only appears via alwaysSelect, not random selection
                    onlyOnce: true,  // Only triggers once per game (tracked separately)
                    getDifficulty: (d, c, diffMap) => {
                        const handCount = c.getTurnCountForToy('teaseanddenial_hand');
                        return `<strong>üîí Special Cage Task!</strong><p>You've completed ${handCount} hand tasks from Tease And Denial. Time to put on the cage!</p><p>Place the cage on your Pe.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: ALWAYS task - only triggers after rolling 2+ Tease And Denial hand tasks if Tease And Denial selected, cage checked, and Pe can hold cage. This overrides normal task selection.</em></p><img src="https://picsum.photos/seed/cagehand/800/600"/>`;
                    },
                    execute: function() {
                        // Add cage to Pe
                        return addToyToBodyPart('Pe', 'cage');
                    }
                },
                {
                    // TASK: Hand stroking (when cage is NOT on Pe AND hand is available)
                    // DIFFICULTY: Easy=8, Medium=12, Hard=16 stroking
                    // CONDITIONS: Cage is NOT on Pe AND hand toy is checked for Tease And Denial
                    canSelect: (c) => {
                        const isCageOnPe = c.isHolding('cage') && c.getBodyPartsHolding('cage').some(part => part.key === 'Pe');
                        const isHandAvailable = c.toyChecked('hand') && c.toySetEnabled('teaseanddenial_hand');
                        return !isCageOnPe && isHandAvailable; // Cage OFF and hand available
                    },
                    getDifficulty: (d, c, diffMap) => {
                        const count = d === 'easy' ? 8 : d === 'hard' ? 16 : 12;
                        // Check if cage is worn anywhere (not necessarily on Pe)
                        const isCageWorn = c.isHolding('cage');
                        
                        if (isCageWorn) {
                            return `<strong>Hand Stroking</strong><p>Complete ${count} hand stroking while wearing the cage.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Tease And Denial hand task with cage worn. Difficulty: Easy=8, Medium=12, Hard=16 stroking.</em></p><img src="https://picsum.photos/seed/cagehandworn/800/600"/>`;
                        } else {
                            return `<strong>Hand Stroking</strong><p>Complete ${count} hand stroking.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Tease And Denial hand task without cage. Difficulty: Easy=8, Medium=12, Hard=16 stroking.</em></p><img src="https://picsum.photos/seed/cagehand/800/600"/>`;
                        }
                    }
                },
                {
                    // TASK: Put on cage then do settings (when cage is NOT on Pe AND hand is NOT available)
                    // DIFFICULTY: Easy=10sec, Medium=15sec, Hard=20sec
                    // CONDITIONS: Cage is NOT on Pe AND hand toy is NOT available for Tease And Denial
                    canSelect: (c) => {
                        const isCageOnPe = c.isHolding('cage') && c.getBodyPartsHolding('cage').some(part => part.key === 'Pe');
                        const isHandAvailable = c.toyChecked('hand') && c.toySetEnabled('teaseanddenial_hand');
                        return !isCageOnPe && !isHandAvailable; // Cage OFF and hand NOT available
                    },
                    getDifficulty: (d, c, diffMap) => {
                        const seconds = d === 'easy' ? 10 : d === 'hard' ? 20 : 15;
                        return `<strong>Cage Task</strong><p>Put the cage on your Pe.</p><p>Then adjust the cage settings for ${seconds} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Tease And Denial cage off + hand NOT available - put on cage task. Difficulty: Easy=10s, Medium=15s, Hard=20s.</em></p><img src="https://picsum.photos/seed/cageputon/800/600"/>`;
                    }
                },
                {
                    // TASK: Control cage settings (when cage IS on Pe)
                    // DIFFICULTY: Easy=10sec, Medium=15sec, Hard=20sec
                    // CONDITIONS: Cage is currently on Pe
                    canSelect: (c) => {
                        const isCageOnPe = c.isHolding('cage') && c.getBodyPartsHolding('cage').some(part => part.key === 'Pe');
                        return isCageOnPe; // Only if cage is ON
                    },
                    getDifficulty: (d, c, diffMap) => {
                        const seconds = d === 'easy' ? 10 : d === 'hard' ? 20 : 15;
                        return `<strong>Cage Control</strong><p>Adjust the cage settings for ${seconds} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Tease And Denial cage on - settings task. Difficulty: Easy=10s, Medium=15s, Hard=20s.</em></p><img src="https://picsum.photos/seed/cagesettings/800/600"/>`;
                    }
                },
                {
                    // ADD TASK: Add cage to Pe
                    // Locked status affects whether this can be rolled
                    type: 'add', 
                    bodyPart: 'Pe'
                },
                {
                    // REMOVE TASK: Remove cage from Pe
                    // Locked status affects whether this can be rolled
                    type: 'remove', 
                    bodyPart: 'Pe'
                }
            ]
        }
    }
};

// Snake and Ladder special tasks (at root level, not tied to a specific set)
const snakeLadderTasks = {
    snakeTasks: [
        {
            // SNAKE TASK: Conditional vibe task
            // CONDITIONS: Tease And Denial selected AND vibe available AND vibe not currently held
            // DIFFICULTY: Easy=5sec, Medium=10sec, Hard=15sec
            canSelect: (c) => {
                // Check Tease And Denial is selected
                if (!c.hasSet('teaseanddenial')) return false;
                // Check if vibe toy is checked/enabled
                if (!c.toyChecked('vibe')) return false;
                // Check if any vibe toy key is enabled (could be from Tease And Denial or other sets)
                const teaseanddenialVibKey = 'teaseanddenial_vibe';
                const hasVibe = c.toySetEnabled(teaseanddenialVibKey) && (c.toyQuantity(teaseanddenialVibKey) > 0);
                if (!hasVibe) return false;
                // Check if vibe is free (not currently held on any body part)
                return !c.isHolding('vibe');
            },
            getDifficulty: (d, c, diffMap, snakeLadderInfo) => {
                const vibDiff = diffMap['vibe'] || 'medium';
                const seconds = getDifficultyValue(vibDiff, 5, 10, 15);
                return `<strong>Snake Slide! üêç</strong><p>You fell ${Math.abs(snakeLadderInfo.distance)} spaces from ${snakeLadderInfo.from} to ${snakeLadderInfo.to}!</p><p>Hold the vibe steady for ${seconds} seconds to steady yourself.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Conditional snake task with vibe. Only appears if Tease And Denial selected, vibe checked, teaseanddenial_vibe enabled with quantity > 0, and vibe is NOT currently being held. Difficulty: Easy=5s, Medium=10s, Hard=15s. Fall distance: ${Math.abs(snakeLadderInfo.distance)} spaces.</em></p><img src="https://picsum.photos/seed/snakevib/800/600"/>`;
            }
        },
        {
            // SNAKE TASK: Fallback task (always available)
            // CONDITIONS: None
            getDifficulty: (d, c, diffMap, snakeLadderInfo) => {
                return `<strong>Snake Slide! üêç</strong><p>You slid down ${Math.abs(snakeLadderInfo.distance)} spaces from ${snakeLadderInfo.from} to ${snakeLadderInfo.to}.</p><p>Take a moment to recover from the fall.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: FALLBACK snake task (no toys, no conditions). Always available when conditional tasks don't pass. Fall distance: ${Math.abs(snakeLadderInfo.distance)} spaces.</em></p><img src="https://picsum.photos/seed/snakefallback/800/600"/>`;
            }
        }
    ],
    ladderTasks: [
        {
            // LADDER TASK: Conditional hand task
            // CONDITIONS: Tease And Denial selected AND hand available AND Ha available
            // DIFFICULTY: Easy=8, Medium=12, Hard=16 stroking
            canSelect: (c) => {
                // Check Tease And Denial is selected
                if (!c.hasSet('teaseanddenial')) return false;
                // Check if hand toy is checked/enabled
                if (!c.toyChecked('hand')) return false;
                // Check if Tease And Denial hand is enabled with quantity > 0
                const teaseanddenialHandKey = 'teaseanddenial_hand';
                const hasHand = c.toySetEnabled(teaseanddenialHandKey) && (c.toyQuantity(teaseanddenialHandKey) > 0);
                if (!hasHand) return false;
                // Check if Ha can hold hand
                return c.canBodyPartHold('Ha', 'hand');
            },
            getDifficulty: (d, c, diffMap, snakeLadderInfo) => {
                const handDiff = diffMap['hand'] || 'medium';
                const stroking = getDifficultyValue(handDiff, 8, 12, 16);
                return `<strong>Ladder Climb! ü™ú</strong><p>You climbed ${snakeLadderInfo.distance} spaces from ${snakeLadderInfo.from} to ${snakeLadderInfo.to}!</p><p>Make ${stroking} celebratory hand stroking for your climb.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: CONDITIONAL ladder task with hand. Only appears if Tease And Denial selected, hand checked, teaseanddenial_hand enabled with quantity > 0, and Ha can hold it. Difficulty: Easy=8, Medium=12, Hard=16 stroking. Climb distance: ${snakeLadderInfo.distance} spaces.</em></p><img src="https://picsum.photos/seed/ladderhand/800/600"/>`;
            }
        },
        {
            // LADDER TASK: Fallback task (always available)
            // CONDITIONS: None
            getDifficulty: (d, c, diffMap, snakeLadderInfo) => {
                return `<strong>Ladder Climb! ü™ú</strong><p>You climbed ${snakeLadderInfo.distance} spaces from ${snakeLadderInfo.from} to ${snakeLadderInfo.to}!</p><p>Celebrate your good fortune!</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: FALLBACK ladder task (no toys, no conditions). Always available when conditional tasks don't pass. Climb distance: ${snakeLadderInfo.distance} spaces.</em></p><img src="https://picsum.photos/seed/ladderfallback/800/600"/>`;
            }
        }
    ]
};

// Final Challenge Tasks
const finalChallengeTasks = [
    {
        id: 'stroking',
        // GESTURES TASK: Only if stroking probability > 0%
        canSelect: (c) => {
            return finalChallengeSettings.stroking > 0;
        },
        getDifficulty: (d, c, diffMap, prizeType) => {
            // Roll for each modifier based on percentage chance
            const appliedModifiers = [];
            if (finalChallengeTypes.stroking_icyhot && Math.random() * 100 < finalChallengeModifierChances.stroking_icyhot) {
                appliedModifiers.push('Icy Hot');
            }
            if (finalChallengeTypes.stroking_icewater && Math.random() * 100 < finalChallengeModifierChances.stroking_icewater) {
                appliedModifiers.push('Ice Water');
            }
            if (finalChallengeTypes.stroking_ktb && Math.random() * 100 < finalChallengeModifierChances.stroking_ktb) {
                appliedModifiers.push('KTB');
            }
            if (finalChallengeTypes.stroking_ballsqueeze && Math.random() * 100 < finalChallengeModifierChances.stroking_ballsqueeze) {
                appliedModifiers.push('Ball Squeeze');
            }
            if (finalChallengeTypes.stroking_2finger && Math.random() * 100 < finalChallengeModifierChances.stroking_2finger) {
                appliedModifiers.push('2 Finger');
            }
            
            // Build modifier text
            let modifierText = '';
            if (appliedModifiers.length > 0) {
                modifierText = ' with ' + appliedModifiers.join(', ');
            }
            
            const difficulty = finalChallengeDifficulties.stroking;
            const count = difficulty === 'easy' ? 8 : difficulty === 'hard' ? 16 : 12;
            
            return `
                <strong>üèÜ Final Challenge! üèÜ</strong>
                <p>Complete ${count} hand stroking${modifierText} at ${difficulty} difficulty.</p>
                <button onclick="revealFinalPrize('stroking', '${prizeType}')" 
                        style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    I Completed the Challenge
                </button>
                <div id="prizeReveal_stroking" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    <!-- Prize will be revealed here -->
                </div>
                <img src="https://picsum.photos/seed/finalstroking/800/600"/>
            `;
        }
    },
    {
        id: 'vibe',
        // VIBRANIUM TASK: Only if vibe probability > 0%
        canSelect: (c) => {
            return finalChallengeSettings.vibe > 0;
        },
        getDifficulty: (d, c, diffMap, prizeType) => {
            // Roll for each modifier based on percentage chance
            const appliedModifiers = [];
            if (finalChallengeTypes.vibe_icyhot && Math.random() * 100 < finalChallengeModifierChances.vibe_icyhot) {
                appliedModifiers.push('Icy Hot');
            }
            if (finalChallengeTypes.vibe_icewater && Math.random() * 100 < finalChallengeModifierChances.vibe_icewater) {
                appliedModifiers.push('Ice Water');
            }
            
            // Build modifier text
            let modifierText = '';
            if (appliedModifiers.length > 0) {
                modifierText = ' with ' + appliedModifiers.join(', ');
            }
            
            const difficulty = finalChallengeDifficulties.vibe;
            const seconds = difficulty === 'easy' ? 30 : difficulty === 'hard' ? 60 : 45;
            
            return `
                <strong>üèÜ Final Challenge! üèÜ</strong>
                <p>Hold vibe${modifierText} for ${seconds} seconds at ${difficulty} difficulty.</p>
                <button onclick="revealFinalPrize('vibe', '${prizeType}')" 
                        style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    I Completed the Challenge
                </button>
                <div id="prizeReveal_vibe" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    <!-- Prize will be revealed here -->
                </div>
                <img src="https://picsum.photos/seed/finalvibe/800/600"/>
            `;
        }
    },
    {
        id: 'anal',
        // ANALYSE TASK: Only if anal probability > 0%
        canSelect: (c) => {
            return finalChallengeSettings.anal > 0;
        },
        getDifficulty: (d, c, diffMap, prizeType) => {
            // Roll for modifier based on percentage chance
            let modifierText = '';
            if (finalChallengeTypes.anal_vibe && Math.random() * 100 < finalChallengeModifierChances.anal_vibe) {
                modifierText = ' with Vibe';
            }
            
            const difficulty = finalChallengeDifficulties.anal;
            const count = difficulty === 'easy' ? 3 : difficulty === 'hard' ? 7 : 5;
            
            return `
                <strong>üèÜ Final Challenge! üèÜ</strong>
                <p>Anal ${count} dildos${modifierText} at ${difficulty} difficulty.</p>
                <button onclick="revealFinalPrize('anal', '${prizeType}')" 
                        style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    I Completed the Challenge
                </button>
                <div id="prizeReveal_anal" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    <!-- Prize will be revealed here -->
                </div>
                <img src="https://picsum.photos/seed/finalanal/800/600"/>
            `;
        }
    },
    {
        id: 'special',
        // EXAMPLE: ALWAYS task - only triggers if specific condition met
        // This demonstrates how to add conditional "always" tasks
        alwaysSelect: (c) => {
            // Example: Only show this task if player completed 10+ turns
            // return c.turnCount >= 10;
            return false; // Disabled by default - set to true or add condition to enable
        },
        getDifficulty: (d, c, diffMap, prizeType) => {
            return `
                <strong>üèÜ Special Final Challenge! üèÜ</strong>
                <p>You've been selected for a special challenge based on your game progress!</p>
                <p>This is an example of an "always" task that only appears when specific conditions are met.</p>
                <button onclick="revealFinalPrize('special', '${prizeType}')" 
                        style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    I Completed the Challenge
                </button>
                <div id="prizeReveal_special" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    <!-- Prize will be revealed here -->
                </div>
                <img src="https://picsum.photos/seed/finalspecial/800/600"/>
            `;
        }
    },
    {
        id: 'fallback',
        // FALLBACK TASK: Always available, no challenge
        getDifficulty: (d, c, diffMap, prizeType) => {
            // Immediately show prize with modifiers
            const prizeHTML = generatePrizeHTML(prizeType);
            
            return `
                <strong>üèÜ Final Challenge! üèÜ</strong>
                <p>Let's see what your prize is...</p>
                <div style="margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    ${prizeHTML}
                </div>
                <img src="https://picsum.photos/seed/finalfallback/800/600"/>
            `;
        }
    }
];

// Generate prize HTML with modifiers
function generatePrizeHTML(prizeType) {
    let html = '<div style="text-align: center;">';
    html += '<div style="font-size: 24px; margin-bottom: 10px;">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>';
    html += '<div style="font-size: 20px; font-weight: 600; margin-bottom: 15px;">üéâ Prize Result üéâ</div>';
    
    if (prizeType === 'full') {
        html += '<div style="font-size: 28px; font-weight: bold; color: #ffd93d; margin-bottom: 10px;">üèÜ FULL PRIZE! üèÜ</div>';
        html += '<p style="font-size: 16px; margin-bottom: 15px;">Congratulations! You won big!</p>';
        
        // Add modifiers for Major (CE + PF if enabled)
        if (finalChallengeModifiers.ce) {
            html += '<div style="background: #fff3cd; padding: 10px; border-radius: 6px; margin-bottom: 10px; text-align: left;">';
            html += '<strong>ü•õ CE (Cum Eating):</strong> Complete the CE requirement.';
            html += '</div>';
        }
        if (finalChallengeModifiers.pf) {
            html += '<div style="background: #cfe2ff; padding: 10px; border-radius: 6px; margin-bottom: 10px; text-align: left;">';
            html += '<strong>‚è±Ô∏è PF (Post Finish):</strong> Complete the PF requirement.';
            html += '</div>';
        }
    } else if (prizeType === 'ruin') {
        html += '<div style="font-size: 28px; font-weight: bold; color: #51cf66; margin-bottom: 10px;">üéâ Ruin üéâ</div>';
        html += '<p style="font-size: 16px; margin-bottom: 15px;">You got ruined!</p>';
        
        // Add modifiers for Ruin (CE only if enabled)
        if (finalChallengeModifiers.ce) {
            html += '<div style="background: #fff3cd; padding: 10px; border-radius: 6px; margin-bottom: 10px; text-align: left;">';
            html += '<strong>ü•õ CE (Cum Eating):</strong> Complete the CE requirement.';
            html += '</div>';
        }
    } else {
        html += '<div style="font-size: 28px; font-weight: bold; color: #adb5bd; margin-bottom: 10px;">‚ùå Denial ‚ùå</div>';
        html += '<p style="font-size: 16px; margin-bottom: 15px;">Better luck next time!</p>';
        // No modifiers for Denial
    }
    
    html += '</div>';
    return html;
}

// Reveal prize after button click
function revealFinalPrize(taskId, prizeType) {
    const revealDiv = document.getElementById(`prizeReveal_${taskId}`);
    if (revealDiv) {
        revealDiv.innerHTML = generatePrizeHTML(prizeType);
        revealDiv.style.display = 'block';
    }
}

// Storage Functions
function saveGameState() {
    localStorage.setItem('snakesLaddersGameState', JSON.stringify({
        gameStarted,
        playerPosition,
        turnCount,
        turnCountBySet,
        turnCountByToy,
        lastSelectedSet,
        completedOnlyOnceTasks,
        selectedSets,
        toyDifficulties,
        prizeSettings,
        toyQuantities,
        toyModifiers,
        bodyPartState,
        playerName,
        toySetEnabled,
        toyChecked,
        cageLocked,
        cageWorn,
        finalChallengeSettings,
        finalChallengeTypes,
        finalChallengeModifierChances,
        finalChallengeDifficulties,
        finalChallengeModifiers,
        diceResultText: diceResult.textContent,
        currentInstruction: instructions.innerHTML,
        instructionsActive: instructions.classList.contains('active'),
        lastTaskInfo: window.lastTaskInfo || null
    }));
}

function loadGameState() {
    const saved = localStorage.getItem('snakesLaddersGameState');
    if (!saved) return false;
    
    try {
        const gs = JSON.parse(saved);
        gameStarted = gs.gameStarted;
        playerPosition = gs.playerPosition;
        turnCount = gs.turnCount || 0;
        turnCountBySet = gs.turnCountBySet || {};
        turnCountByToy = gs.turnCountByToy || {};
        lastSelectedSet = gs.lastSelectedSet || {};
        completedOnlyOnceTasks = gs.completedOnlyOnceTasks || {};
        selectedSets = gs.selectedSets || [];
        toyDifficulties = gs.toyDifficulties || {};
        toyQuantities = gs.toyQuantities || {};
        toyModifiers = gs.toyModifiers || {};
        playerName = gs.playerName || '';
        toySetEnabled = gs.toySetEnabled || {};
        toyChecked = gs.toyChecked || {};
        cageLocked = gs.cageLocked || false;
        cageWorn = gs.cageWorn || false;
        finalChallengeSettings = gs.finalChallengeSettings || {stroking: 33, vibe: 33, anal: 34};
        finalChallengeTypes = gs.finalChallengeTypes || {
            stroking_icyhot: false, stroking_icewater: false, stroking_ktb: false,
            stroking_ballsqueeze: false, stroking_2finger: false, vibe_icyhot: false,
            vibe_icewater: false, anal_vibe: false
        };
        finalChallengeModifierChances = gs.finalChallengeModifierChances || {
            stroking_icyhot: 10, stroking_icewater: 10, stroking_ktb: 10,
            stroking_ballsqueeze: 10, stroking_2finger: 10, vibe_icyhot: 10,
            vibe_icewater: 10, anal_vibe: 10
        };
        finalChallengeDifficulties = gs.finalChallengeDifficulties || {stroking: 'medium', vibe: 'medium', anal: 'medium'};
        finalChallengeModifiers = gs.finalChallengeModifiers || {ce: false, pf: false};
        
        if (gs.bodyPartState) {
            bodyPartState = gs.bodyPartState;
        }
        
        if (gs.prizeSettings) {
            prizeSettings = gs.prizeSettings;
            updateSliderDisplays(true);
        }
        
        document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => {
            cb.checked = selectedSets.includes(cb.value);
        });
        
        // Restore final challenge sliders
        document.getElementById('strokingSlider').value = finalChallengeSettings.stroking;
        document.getElementById('vibeSlider').value = finalChallengeSettings.vibe;
        document.getElementById('analSlider').value = finalChallengeSettings.anal;
        document.getElementById('strokingPercent').textContent = finalChallengeSettings.stroking + '%';
        document.getElementById('vibePercent').textContent = finalChallengeSettings.vibe + '%';
        document.getElementById('analPercent').textContent = finalChallengeSettings.anal + '%';
        
        // Restore final challenge type checkboxes
        Object.keys(finalChallengeTypes).forEach(key => {
            const checkbox = document.getElementById(key);
            if (checkbox) checkbox.checked = finalChallengeTypes[key];
        });
        
        // Restore final challenge difficulty dropdowns
        Object.keys(finalChallengeDifficulties).forEach(type => {
            const dropdown = document.getElementById(`${type}Difficulty`);
            if (dropdown) dropdown.value = finalChallengeDifficulties[type];
        });
        
        // Restore final challenge modifier chance inputs
        Object.keys(finalChallengeModifierChances).forEach(key => {
            const input = document.getElementById(`${key}_chance`);
            if (input) input.value = finalChallengeModifierChances[key];
        });
        
        // Restore final challenge modifier checkboxes
        Object.keys(finalChallengeModifiers).forEach(mod => {
            const checkbox = document.getElementById(`modifier_${mod}`);
            if (checkbox) checkbox.checked = finalChallengeModifiers[mod];
        });
        
        if (gameStarted) {
            startButton.style.display = 'none';
            rollDiceButton.style.display = 'block';
            diceResult.style.display = 'block';
            turnCounter.style.display = 'block';
            diceResult.textContent = gs.diceResultText || 'Dice: -';
            turnCounter.textContent = `Turn: ${turnCount}`;
            
            const leftCol = document.querySelector('.settings-column-left');
            const rightCol = document.querySelector('.settings-column-right');
            if (leftCol) leftCol.style.display = 'none';
            if (rightCol) rightCol.style.display = 'none';
            
            createBoard();
            
            if (playerPosition > 0) {
                const sq = document.getElementById(`square-${playerPosition}`);
                if (sq) sq.appendChild(player);
            }
            
            if (gs.lastTaskInfo && gs.lastTaskInfo.taskType) {
                window.lastTaskInfo = gs.lastTaskInfo;
                instructions.classList.add('active');
                
                if (gs.lastTaskInfo.taskType === 'metronome') {
                    currentMetronomeTask = createMetronomeTask(gs.lastTaskInfo.beatCount);
                    instructions.innerHTML = '';
                    instructions.appendChild(currentMetronomeTask.element);
                } else if (gs.lastTaskInfo.taskType === 'redlight') {
                    currentMetronomeTask = createRedLightGreenLightTask(gs.lastTaskInfo.duration);
                    instructions.innerHTML = '';
                    instructions.appendChild(currentMetronomeTask.element);
                } else if (gs.currentInstruction) {
                    instructions.innerHTML = gs.currentInstruction;
                }
            } else if (gs.currentInstruction && gs.currentInstruction.trim() !== '') {
                instructions.innerHTML = gs.currentInstruction;
                if (gs.instructionsActive) instructions.classList.add('active');
            }
        } else {
            document.getElementById('playerNameInput').value = playerName;
            renderToyLibrary();
        }
        
        return true;
    } catch (e) {
        console.error('Load error:', e);
        return false;
    }
}

// Prize Functions
function updateSliderDisplays(skipSave = false) {
    prizeSettings.ruin = Math.round(prizeSettings.ruin * 10) / 10;
    prizeSettings.full = Math.round(prizeSettings.full * 10) / 10;
    prizeSettings.denied = Math.round(prizeSettings.denied * 10) / 10;
    
    document.getElementById('ruinPercent').textContent = prizeSettings.ruin.toFixed(1) + '%';
    document.getElementById('fullPercent').textContent = prizeSettings.full.toFixed(1) + '%';
    document.getElementById('deniedPercent').textContent = prizeSettings.denied.toFixed(1) + '%';
    
    document.getElementById('ruinSlider').value = prizeSettings.ruin;
    document.getElementById('fullSlider').value = prizeSettings.full;
    document.getElementById('deniedSlider').value = prizeSettings.denied;
    
    if (!skipSave) saveGameState();
}

document.getElementById('ruinSlider').addEventListener('input', function() {
    const newRuin = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(prizeSettings.denied);
    prizeSettings.ruin = newRuin > maxAllowed ? maxAllowed : newRuin;
    prizeSettings.full = 100 - prizeSettings.denied - prizeSettings.ruin;
    updateSliderDisplays();
});

document.getElementById('fullSlider').addEventListener('input', function() {
    const newFull = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(prizeSettings.denied);
    prizeSettings.full = newFull > maxAllowed ? maxAllowed : newFull;
    prizeSettings.ruin = 100 - prizeSettings.denied - prizeSettings.full;
    updateSliderDisplays();
});

document.getElementById('deniedSlider').addEventListener('input', function() {
    const newDenied = Math.round(parseFloat(this.value));
    
    // Special case: if denied is 100%, force the others to 0
    if (newDenied >= 100) {
        prizeSettings.ruin = 0;
        prizeSettings.full = 0;
        prizeSettings.denied = 100;
    } else {
        const available = 100 - newDenied;
        const currentTotal = Math.round(prizeSettings.ruin) + Math.round(prizeSettings.full);
        
        // Changed: use equal split for BOTH directions (not just when increasing)
        if (available !== currentTotal) {
            const change = available - currentTotal;
            const half = change / 2;
            prizeSettings.ruin = Math.max(0, Math.round(prizeSettings.ruin + half));
            prizeSettings.full = Math.max(0, Math.round(prizeSettings.full + half));
            
            // Ensure total is exactly 100 by adjusting denied if values were clamped
            const actualTotal = prizeSettings.ruin + prizeSettings.full;
            prizeSettings.denied = Math.max(0, 100 - actualTotal);
        } else {
            prizeSettings.denied = Math.max(0, newDenied);
        }
    }
    
    updateSliderDisplays();
});

function determinePrize() {
    const roll = Math.random() * 100;
    return roll < prizeSettings.full ? 'full' : 
           roll < prizeSettings.full + prizeSettings.ruin ? 'ruin' : 'none';
}

function displayPrizeResult(prize) {
    return prize === 'full' ? 
        '<div class="prize-result prize-full">üèÜ FULL PRIZE! üèÜ<br>Congratulations!</div>' :
        prize === 'ruin' ? 
        '<div class="prize-result prize-ruin">üéâ Ruin! üéâ<br>You got ruined!</div>' :
        '<div class="prize-result prize-denied">‚ùå Denial<br>Better luck next time!</div>';
}

// Body Part Functions
function canAddToyToBodyPart(bodyPart, toyId) {
    if (toyId === 'pegs') {
        // Clothes Pegs case
        // Can't add if body part has regular toys
        if (hasRegularToys(bodyPart)) {
            return false;
        }
        // Check if under max count
        const currentCount = hasClothesPegCount(bodyPart);
        const maxCount = getClothesPegMax(bodyPart);
        return currentCount < maxCount;
    } else {
        // Regular toy case
        // Body part must be completely empty (no regular toys AND no clothespegs)
        return isBodyPartEmpty(bodyPart);
    }
}

function addToyToBodyPart(bodyPart, toyId) {
    if (canAddToyToBodyPart(bodyPart, toyId)) {
        bodyPartState[bodyPart].items.push(toyId);
        saveGameState();
        return true;
    }
    return false;
}

function removeToyFromBodyPart(bodyPart, toyId) {
    const index = bodyPartState[bodyPart].items.indexOf(toyId);
    if (index > -1) {
        bodyPartState[bodyPart].items.splice(index, 1);
        saveGameState();
        return true;
    }
    return false;
}

function getAvailableBodyPartsForToy(toyId) {
    const available = [];
    
    for (const [partKey, part] of Object.entries(bodyPartState)) {
        if (canAddToyToBodyPart(partKey, toyId)) {
            available.push({
                key: partKey,
                name: part.name,
                available: toyId === 'pegs' ? 
                    (getClothesPegMax(partKey) - hasClothesPegCount(partKey)) : 
                    1
            });
        }
    }
    
    return available;
}

function getBodyPartsHoldingToy(toyId) {
    const holding = [];
    
    for (const [partKey, part] of Object.entries(bodyPartState)) {
        if (part.items.includes(toyId)) {
            holding.push({
                key: partKey,
                name: part.name
            });
        }
    }
    
    return holding;
}

// Add/Remove Task Functions
function createAddToyTaskWithBodyPart(toyKey, toyName, bodyPart, quantity = 1) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_');
    
    // For clothespegs, check if we can add the requested quantity
    if (toyId === 'pegs') {
        const currentCount = hasClothesPegCount(bodyPart);
        const maxCount = getClothesPegMax(bodyPart);
        const spaceAvailable = maxCount - currentCount;
        
        // If we can't add any or if body part has regular toys, return null
        if (spaceAvailable <= 0 || hasRegularToys(bodyPart)) {
            return null;
        }
        
        // Cap the quantity at what's available
        const actualQuantity = Math.min(quantity, spaceAvailable);
        
        return {
            type: 'add',
            toyId: toyId,
            toyKey: toyKey,
            toyName: toyName,
            bodyPart: bodyPart,
            bodyPartName: bodyPartState[bodyPart].name,
            quantity: actualQuantity,
            execute: function() {
                // Add multiple clothespegs
                for (let i = 0; i < this.quantity; i++) {
                    if (!addToyToBodyPart(this.bodyPart, this.toyId)) {
                        return false;
                    }
                }
                return true;
            },
            getHTML: function() {
                return `<strong>üì• Pick Up Task</strong><p>Pick up ${this.quantity} ${this.toyName} and hold them in your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">These will stay with you until a task tells you to put them down.</p>`;
            }
        };
    } else {
        // Regular toy - check if body part is empty
        let heldCount = 0;
        for (const part of Object.values(bodyPartState)) {
            heldCount += part.items.filter(item => item === toyId).length;
        }
        
        const totalAvailable = toyQuantities[toyKey] || 0;
        if (heldCount >= totalAvailable) {
            return null;
        }
        
        // Check if the specific body part can hold this toy
        if (!canAddToyToBodyPart(bodyPart, toyId)) {
            return null;
        }
        
        return {
            type: 'add',
            toyId: toyId,
            toyKey: toyKey,
            toyName: toyName,
            bodyPart: bodyPart,
            bodyPartName: bodyPartState[bodyPart].name,
            quantity: 1,
            execute: function() {
                return addToyToBodyPart(this.bodyPart, this.toyId);
            },
            getHTML: function() {
                return `<strong>üì• Pick Up Task</strong><p>Pick up the ${this.toyName} and hold it in your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">This toy will stay with you until a task tells you to put it down.</p>`;
            }
        };
    }
}

function createRemoveToyTaskWithBodyPart(toyKey, toyName, bodyPart, quantity = 1) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_');
    
    // For clothespegs, check if we have enough to remove
    if (toyId === 'pegs') {
        const currentCount = hasClothesPegCount(bodyPart);
        
        if (currentCount <= 0) {
            return null;
        }
        
        // Cap the quantity at what's actually there
        const actualQuantity = Math.min(quantity, currentCount);
        
        return {
            type: 'remove',
            toyId: toyId,
            toyKey: toyKey,
            toyName: toyName,
            bodyPart: bodyPart,
            bodyPartName: bodyPartState[bodyPart].name,
            quantity: actualQuantity,
            execute: function() {
                // Remove multiple clothespegs
                for (let i = 0; i < this.quantity; i++) {
                    if (!removeToyFromBodyPart(this.bodyPart, this.toyId)) {
                        return false;
                    }
                }
                return true;
            },
            getHTML: function() {
                return `<strong>üì§ Put Down Task</strong><p>Put down ${this.quantity} ${this.toyName} from your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">You can now use this space again.</p>`;
            }
        };
    } else {
        // Regular toy - check if this specific body part is holding the toy
        if (!bodyPartState[bodyPart].items.includes(toyId)) {
            return null;
        }
        
        return {
            type: 'remove',
            toyId: toyId,
            toyKey: toyKey,
            toyName: toyName,
            bodyPart: bodyPart,
            bodyPartName: bodyPartState[bodyPart].name,
            quantity: 1,
            execute: function() {
                return removeToyFromBodyPart(this.bodyPart, this.toyId);
            },
            getHTML: function() {
                return `<strong>üì§ Put Down Task</strong><p>Put down the ${this.toyName} from your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">You can now use this body part freely again.</p>`;
            }
        };
    }
}

function toyHasAddRemoveTasks(toyKey) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_');
    
    if (!instructionSets[setId] || !instructionSets[setId].tasks[toyId]) return false;
    
    const tasks = instructionSets[setId].tasks[toyId];
    const hasAdd = tasks.some(task => task.type === 'add');
    const hasRemove = tasks.some(task => task.type === 'remove');
    
    return hasAdd && hasRemove;
}

function rollForAddRemoveTasks() {
    const addTasks = [];
    const removeTasks = [];
    
    for (const [toyKey, quantity] of Object.entries(toyQuantities)) {
        if (quantity > 0) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_');
            
            // Only roll for toys whose set is selected, toy is checked, and set-toy combo is enabled
            if (!selectedSets.includes(setId)) continue;
            if (!toyChecked[toyId]) continue;
            if (!toySetEnabled[toyKey]) continue;
            
            if (!isToyWearable(toyId)) continue;
            
            if (!instructionSets[setId] || !instructionSets[setId].tasks[toyId]) continue;
            
            const tasks = instructionSets[setId].tasks[toyId];
            const difficulty = toyDifficulties[toyKey] || 'medium';
            
            // Find add and remove tasks with body parts
            const addTask = tasks.find(task => task.type === 'add' && task.bodyPart);
            const removeTask = tasks.find(task => task.type === 'remove' && task.bodyPart);
            
            if (!addTask || !removeTask) continue;
            
            // If cage is locked, set add/remove chances to 0
            let effectiveAddChance = toyModifiers[toyKey]?.addChance ?? 10;
            let effectiveRemoveChance = toyModifiers[toyKey]?.removeChance ?? 20;
            
            if (toyId === 'cage' && cageLocked) {
                effectiveAddChance = 0;
                effectiveRemoveChance = 0;
            }
            
            // Use effective chances instead of direct toyModifiers
            const shouldAdd = Math.random() * 100 < effectiveAddChance;
            const shouldRemove = Math.random() * 100 < effectiveRemoveChance;
            
            if (shouldAdd) {
                let toyName = toyId;
                
                if (instructionSets[setId]) {
                    const toy = instructionSets[setId].toys.find(t => t.id === toyId);
                    if (toy) toyName = toy.name;
                }
                
                const taskQuantity = addTask.quantity ? addTask.quantity(difficulty) : 1;
                const task = createAddToyTaskWithBodyPart(toyKey, toyName, addTask.bodyPart, taskQuantity);
                if (task) addTasks.push(task);
            }
            
            if (shouldRemove) {
                let toyName = toyId;
                
                if (instructionSets[setId]) {
                    const toy = instructionSets[setId].toys.find(t => t.id === toyId);
                    if (toy) toyName = toy.name;
                }
                
                const taskQuantity = removeTask.quantity ? removeTask.quantity(difficulty) : 1;
                const task = createRemoveToyTaskWithBodyPart(toyKey, toyName, removeTask.bodyPart, taskQuantity);
                if (task) removeTasks.push(task);
            }
        }
    }
    
    const allTasks = [...addTasks, ...removeTasks];
    if (allTasks.length > 0) {
        return allTasks[Math.floor(Math.random() * allTasks.length)];
    }
    
    return null;
}

// Metronome Task
function createMetronomeTask(beatCount) {
    let metronomeInterval = null;
    let countdownInterval = null;
    let isComplete = false;
    
    const wrapper = document.createElement('div');
    const textDiv = document.createElement('div');
    textDiv.innerHTML = '<strong>üèÄ Bounce to the Beat!</strong><p>Bounce the basketball in rhythm.</p>';
    wrapper.appendChild(textDiv);
    
    const container = document.createElement('div');
    container.className = 'metronome-container';
    container.innerHTML = `
        <div class="metronome-beat" id="metronomeBeat"></div>
        <div class="metronome-display" id="metronomeDisplay">Ready?</div>
        <button class="metronome-btn" id="startMetronome">‚ñ∂Ô∏è Start</button>
    `;
    wrapper.appendChild(container);
    
    const startBtn = container.querySelector('#startMetronome');
    const display = container.querySelector('#metronomeDisplay');
    const beat = container.querySelector('#metronomeBeat');
    
    startBtn.addEventListener('click', function() {
        startBtn.disabled = true;
        let count = 3;
        display.textContent = count;
        
        countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                display.textContent = count;
            } else {
                clearInterval(countdownInterval);
                display.textContent = "Bounce!";
                startMetronome();
            }
        }, 1000);
    });
    
    function playBeep() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.type = 'sine';
        osc.frequency.value = 440;
        gain.gain.setValueAtTime(0.3, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
        osc.start(audioContext.currentTime);
        osc.stop(audioContext.currentTime + 0.05);
    }
    
    function startMetronome() {
        let beatsLeft = beatCount;
        const bpm = 100;
        const interval = 60000 / bpm;
        
        function doBeat() {
            beatsLeft--;
            beat.classList.add('active');
            playBeep();
            display.textContent = `${beatsLeft} bounces left`;
            
            setTimeout(() => {
                beat.classList.remove('active');
            }, 100);
            
            if (beatsLeft <= 0) {
                clearInterval(metronomeInterval);
                display.textContent = "Complete! ‚úì";
                isComplete = true;
                continueButton.disabled = false;
                continueButton.style.opacity = '1';
            }
        }
        
        doBeat();
        metronomeInterval = setInterval(doBeat, interval);
        continueButton.disabled = true;
        continueButton.style.opacity = '0.5';
    }
    
    return {
        element: wrapper,
        isComplete: () => isComplete,
        cleanup: () => {
            if (metronomeInterval) clearInterval(metronomeInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        },
        hasStarted: () => startBtn.disabled
    };
}

// Red Light Green Light Task
function createRedLightGreenLightTask(totalDuration) {
    let gameInterval = null;
    let countdownInterval = null;
    let isComplete = false;
    let timeRemaining = totalDuration;
    
    const imagePatterns = [
        {image: 'chair.jpg', name: 'Chair', type: 'red'},
        {image: 'broom.jpg', name: 'Broom', type: 'green'},
        {image: 'hat.jpg', name: 'Hat', type: 'red'},
        {image: 'ball.jpg', name: 'Ball', type: 'green'},
        {image: 'books.jpg', name: 'Books', type: 'red'},
        {image: 'car.jpg', name: 'Car', type: 'green'},
        {image: 'tree.jpg', name: 'Tree', type: 'red'},
        {image: 'guitar.jpg', name: 'Guitar', type: 'green'},
        {image: 'apple.jpg', name: 'Apple', type: 'red'},
        {image: 'bike.jpg', name: 'Bike', type: 'green'}
    ];
    
    const lightPatterns = [
        {duration: 2000}, {duration: 1500}, {duration: 1500}, {duration: 2500},
        {duration: 1000}, {duration: 3000}, {duration: 2000}, {duration: 1500}
    ];
    
    const container = document.createElement('div');
    container.className = 'metronome-container';
    container.style.background = 'linear-gradient(135deg, #845ef7 0%, #5f3dc4 100%)';
    container.innerHTML = `
        <div><strong>üö¶ Red Light, Green Light!</strong></div>
        <p style="color: white; margin: 10px 0;">üü¢ GREEN = Jump! | üî¥ RED = Stop!</p>
        <div style="background: rgba(255, 255, 255, 0.2); border-radius: 15px; padding: 20px; margin: 15px 0;">
            <div style="width: 150px; height: 150px; margin: 0 auto 10px; background: white; border-radius: 10px; display: flex; align-items: center; justify-content: center; overflow: hidden;" id="imageContainer">
                <div style="font-size: 3em; color: #845ef7;">üö¶</div>
            </div>
            <div style="color: white; font-size: 1.2em; font-weight: bold;" id="imageName">Get Ready!</div>
        </div>
        <div style="width: 120px; height: 120px; border-radius: 50%; background: rgba(255, 255, 255, 0.3); margin: 20px auto; display: flex; align-items: center; justify-content: center; font-size: 4em; transition: all 0.3s ease;" id="lightIndicator">‚è∏Ô∏è</div>
        <div class="metronome-display" id="lightDisplay">Press Start!</div>
        <div style="color: white; font-size: 18px; margin: 10px 0;" id="timeDisplay"></div>
        <button class="metronome-btn" id="startRedLight">‚ñ∂Ô∏è Start</button>
    `;
    
    const startBtn = container.querySelector('#startRedLight');
    const display = container.querySelector('#lightDisplay');
    const lightIndicator = container.querySelector('#lightIndicator');
    const timeDisplay = container.querySelector('#timeDisplay');
    const imageContainer = container.querySelector('#imageContainer');
    const imageName = container.querySelector('#imageName');
    
    startBtn.addEventListener('click', function() {
        startBtn.disabled = true;
        let count = 3;
        imageContainer.innerHTML = `<div style="font-size: 4em; color: #845ef7;">${count}</div>`;
        imageName.textContent = 'Starting...';
        lightIndicator.textContent = '‚è≥';
        display.textContent = 'Get ready...';
        
        countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                imageContainer.innerHTML = `<div style="font-size: 4em; color: #845ef7;">${count}</div>`;
            } else {
                clearInterval(countdownInterval);
                startGame();
            }
        }, 1000);
    });
    
    function startGame() {
        let currentImageIndex = 0;
        let currentPatternIndex = 0;
        
        function showNextLight() {
            if (timeRemaining <= 0) {
                clearInterval(gameInterval);
                display.textContent = "Game Complete! ‚úì";
                lightIndicator.textContent = "‚úì";
                lightIndicator.style.background = "linear-gradient(135deg, #51cf66 0%, #37b24d 100%)";
                imageContainer.innerHTML = '<div style="font-size: 4em; color: #51cf66;">üéâ</div>';
                imageName.textContent = "Great Job!";
                timeDisplay.textContent = "";
                isComplete = true;
                continueButton.disabled = false;
                continueButton.style.opacity = '1';
                return;
            }
            
            const currentImage = imagePatterns[currentImageIndex];
            const pattern = lightPatterns[currentPatternIndex];
            
            imageContainer.innerHTML = `<img src="${currentImage.image}" alt="${currentImage.name}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'font-size: 3em; color: #845ef7;\\'>${currentImage.name[0]}</div>';">`;
            imageName.textContent = currentImage.name;
            lightIndicator.textContent = currentImage.type === 'green' ? 'üü¢' : 'üî¥';
            display.textContent = currentImage.type === 'green' ? 'GREEN LIGHT - JUMP!' : 'RED LIGHT - STOP!';
            
            if (currentImage.type === 'green') {
                lightIndicator.style.background = 'linear-gradient(135deg, #51cf66 0%, #37b24d 100%)';
                lightIndicator.style.transform = 'scale(1.2)';
            } else {
                lightIndicator.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)';
                lightIndicator.style.transform = 'scale(1)';
            }
            
            const displayDuration = Math.min(pattern.duration, timeRemaining);
            timeRemaining -= displayDuration;
            timeDisplay.textContent = `${Math.ceil(timeRemaining / 1000)}s remaining`;
            
            setTimeout(() => {
                currentImageIndex++;
                if (currentImageIndex >= imagePatterns.length) {
                    currentImageIndex = 0;
                }
                currentPatternIndex++;
                if (currentPatternIndex >= lightPatterns.length) {
                    currentPatternIndex = 0;
                }
                showNextLight();
            }, displayDuration);
        }
        
        continueButton.disabled = true;
        continueButton.style.opacity = '0.5';
        showNextLight();
    }
    
    return {
        element: container,
        isComplete: () => isComplete,
        cleanup: () => {
            if (gameInterval) clearInterval(gameInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        },
        hasStarted: () => startBtn.disabled
    };
}

// Board Functions
function createBoard() {
    let reverse = false;
    let currentNumber = 1;
    
    for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
            const actualCol = reverse ? boardSize - col - 1 : col;
            const square = document.createElement('div');
            square.classList.add('square');
            square.textContent = currentNumber;
            square.id = `square-${currentNumber}`;
            square.style.gridRow = boardSize - row;
            square.style.gridColumn = actualCol + 1;
            
            if (snakes[currentNumber]) {
                square.classList.add('snake');
                square.setAttribute('data-destination', '‚Üì' + snakes[currentNumber]);
            } else if (ladders[currentNumber]) {
                square.classList.add('ladder');
                square.setAttribute('data-destination', '‚Üë' + ladders[currentNumber]);
            }
            
            board.appendChild(square);
            currentNumber++;
        }
        reverse = !reverse;
    }
}

function animatePlayer(start, end, callback, instant = false) {
    if (instant) {
        const targetSquare = document.getElementById(`square-${end}`);
        if (targetSquare) targetSquare.appendChild(player);
        if (callback) callback();
        return;
    }
    
    let current = start;
    const step = current < end ? 1 : -1;
    
    const interval = setInterval(() => {
        current += step;
        const currentSquare = document.getElementById(`square-${current}`);
        if (currentSquare) currentSquare.appendChild(player);
        
        if (current === end) {
            clearInterval(interval);
            if (callback) callback();
        }
    }, 200);
}

// Check if any toys have "always" tasks that meet their conditions
function checkForAlwaysTasks(toys, conditions) {
    const alwaysTasks = [];
    for (const toyObj of toys) {
        const tasks = instructionSets[toyObj.setId].tasks[toyObj.toyId];
        if (!tasks) continue;
        
        for (const task of tasks) {
            // Skip add/remove tasks
            if (task.type === 'add' || task.type === 'remove') continue;
            // Check if this is an "always" task
            if (task.alwaysSelect) {
                // Create unique task ID for onlyOnce tracking
                const taskId = `${toyObj.setId}_${toyObj.toyId}_always`;
                
                // Skip if this is a onlyOnce task that's already been completed
                if (task.onlyOnce && completedOnlyOnceTasks[taskId]) {
                    continue;
                }
                
                const result = task.alwaysSelect(conditions);
                if (result) {
                    alwaysTasks.push({task, toyObj, taskId});
                }
            }
        }
    }
    return alwaysTasks;
}

// Toy Selection Functions
function getSelectedToys() {
    const allToys = [];
    for (const [toyKey, quantity] of Object.entries(toyQuantities)) {
        if (quantity > 0) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_');
            
            // Only include toy if: toy is checked, set-toy combo is enabled, AND the set is selected
            if (toyChecked[toyId] && toySetEnabled[toyKey] && selectedSets.includes(setId)) {
                allToys.push({
                    toyId,
                    setId,
                    difficulty: toyDifficulties[toyKey] || 'medium'
                });
            }
        }
    }
    return allToys;
}

function displayRandomInstruction() {
    const toys = getSelectedToys();
    
    if (currentMetronomeTask) {
        currentMetronomeTask.cleanup();
        currentMetronomeTask = null;
    }
    
    if (toys.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>üéØ Select instruction sets and toys to get started!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const conditions = getTaskConditions();
    
    // First, check if any toys have "always" tasks
    const alwaysTasks = checkForAlwaysTasks(toys, conditions);
    
    if (alwaysTasks.length > 0) {
        const selectedAlways = alwaysTasks[Math.floor(Math.random() * alwaysTasks.length)];
        const {task, toyObj, taskId} = selectedAlways;
        
        // Increment turn counts
        const selectedToyKey = `${toyObj.setId}_${toyObj.toyId}`;
        turnCountBySet[toyObj.setId] = (turnCountBySet[toyObj.setId] || 0) + 1;
        turnCountByToy[selectedToyKey] = (turnCountByToy[selectedToyKey] || 0) + 1;
        lastSelectedSet[toyObj.toyId] = toyObj.setId;
        
        // Execute the task if it has an execute function
        if (task.execute) {
            task.execute();
        }
        
        // Mark onlyOnce task as completed
        if (task.onlyOnce && taskId) {
            completedOnlyOnceTasks[taskId] = true;
        }
        
        window.lastTaskInfo = {
            toyId: toyObj.toyId,
            setId: toyObj.setId,
            difficulty: toyObj.difficulty,
            taskType: 'always'
        };
        
        instructions.classList.add('active');
        
        // Create difficulty map
        const difficultyMap = {};
        for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_');
            if (!difficultyMap[toyId]) {
                difficultyMap[toyId] = diff;
            }
        }
        
        const content = task.getDifficulty(toyObj.difficulty, conditions, difficultyMap);
        instructions.innerHTML = content;
        saveGameState();
        return;
    }
    
    // No "always" tasks - proceed with normal task selection
    // Filter toys to only those with available tasks
    const toysWithAvailableTasks = toys.filter(toyObj => {
        const tasks = instructionSets[toyObj.setId].tasks[toyObj.toyId];
        if (!tasks || tasks.length === 0) return false;
        
        const availableTasks = tasks.filter(task => {
            // Filter out add/remove tasks - they're handled separately
            if (task.type === 'add' || task.type === 'remove') return false;
            // Filter out tasks excluded from normal pool
            if (task.excludeFromNormalPool) return false;
            // Check canSelect condition if it exists
            return !task.canSelect || task.canSelect(conditions);
        });
        
        return availableTasks.length > 0;
    });
    
    if (toysWithAvailableTasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>No available tasks for current conditions!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const randomToyObj = toysWithAvailableTasks[Math.floor(Math.random() * toysWithAvailableTasks.length)];
    const tasks = instructionSets[randomToyObj.setId].tasks[randomToyObj.toyId];
    
    const availableTasks = tasks.filter(task => {
        // Filter out add/remove tasks - they're handled separately
        if (task.type === 'add' || task.type === 'remove') return false;
        // Filter out tasks excluded from normal pool
        if (task.excludeFromNormalPool) return false;
        // Check canSelect condition if it exists
        return !task.canSelect || task.canSelect(conditions);
    });
    
    const randomTask = availableTasks[Math.floor(Math.random() * availableTasks.length)];
    
    // Increment turn counts for this set and toy
    const selectedToyKey = `${randomToyObj.setId}_${randomToyObj.toyId}`;
    turnCountBySet[randomToyObj.setId] = (turnCountBySet[randomToyObj.setId] || 0) + 1;
    turnCountByToy[selectedToyKey] = (turnCountByToy[selectedToyKey] || 0) + 1;
    lastSelectedSet[randomToyObj.toyId] = randomToyObj.setId;
    
    window.lastTaskInfo = {
        toyId: randomToyObj.toyId,
        setId: randomToyObj.setId,
        difficulty: randomToyObj.difficulty,
        taskType: randomTask.type || 'normal'
    };
    
    instructions.classList.add('active');
    
    // Create difficulty map for all toys
    const difficultyMap = {};
    for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
        const [setId, ...toyIdParts] = toyKey.split('_');
        const toyId = toyIdParts.join('_');
        if (!difficultyMap[toyId]) {
            difficultyMap[toyId] = diff;
        }
    }
    
    if (randomTask.type === 'metronome') {
        const beatCount = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        window.lastTaskInfo.beatCount = beatCount;
        currentMetronomeTask = createMetronomeTask(beatCount);
        instructions.innerHTML = '';
        instructions.appendChild(currentMetronomeTask.element);
    } else if (randomTask.type === 'redlight') {
        const duration = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        window.lastTaskInfo.duration = duration;
        currentMetronomeTask = createRedLightGreenLightTask(duration);
        instructions.innerHTML = '';
        instructions.appendChild(currentMetronomeTask.element);
    } else {
        const content = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        instructions.innerHTML = content;
    }
}

function displaySnakeLadderTask(type, fromPos, toPos) {
    const conditions = getTaskConditions();
    
    // Calculate distance (positive for ladder up, negative for snake down)
    const distance = toPos - fromPos;
    
    const snakeLadderInfo = {
        type: type, // 'snake' or 'ladder'
        from: fromPos,
        to: toPos,
        distance: distance
    };
    
    // Get the appropriate task list
    const taskListKey = type === 'snake' ? 'snakeTasks' : 'ladderTasks';
    const taskList = snakeLadderTasks && snakeLadderTasks[taskListKey];
    
    // Build debug info
    let debugInfo = '<div style="background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; font-family: monospace; font-size: 0.85em;">';
    debugInfo += '<strong>üîç DEBUG INFO:</strong><br>';
    debugInfo += `Type: ${type}<br>`;
    debugInfo += `snakeLadderTasks exists: ${typeof snakeLadderTasks !== 'undefined'}<br>`;
    debugInfo += `taskListKey: ${taskListKey}<br>`;
    debugInfo += `taskList exists: ${!!taskList}<br>`;
    debugInfo += `taskList length: ${taskList ? taskList.length : 'N/A'}<br>`;
    
    if (!taskList || taskList.length === 0) {
        debugInfo += '<strong style="color: red;">ERROR: No task list found!</strong><br>';
        debugInfo += 'This means snakeTasks or ladderTasks is missing from snakeLadderTasks object';
        debugInfo += '</div>';
        
        instructions.classList.add('active');
        instructions.innerHTML = type === 'snake' ? 
            `<div><strong>Snake Slide! üêç</strong><p>You slid down ${Math.abs(distance)} spaces from ${fromPos} to ${toPos}.</p>${debugInfo}</div>` :
            `<div><strong>Ladder Climb! ü™ú</strong><p>You climbed ${distance} spaces from ${fromPos} to ${toPos}!</p>${debugInfo}</div>`;
        return;
    }
    
    // Check conditions for first task if it has canSelect
    if (taskList[0].canSelect) {
        debugInfo += '<br><strong>Condition Checks:</strong><br>';
        debugInfo += `- hasSet(teaseanddenial): ${conditions.hasSet('teaseanddenial')}<br>`;
        debugInfo += `- toyChecked(hand): ${conditions.toyChecked('hand')}<br>`;
        debugInfo += `- toyChecked(vibe): ${conditions.toyChecked('vibe')}<br>`;
        debugInfo += `- toySetEnabled(teaseanddenial_hand): ${conditions.toySetEnabled('teaseanddenial_hand')}<br>`;
        debugInfo += `- toySetEnabled(teaseanddenial_vibe): ${conditions.toySetEnabled('teaseanddenial_vibe')}<br>`;
        debugInfo += `- toyQuantity(teaseanddenial_hand): ${conditions.toyQuantity('teaseanddenial_hand')}<br>`;
        debugInfo += `- toyQuantity(teaseanddenial_vibe): ${conditions.toyQuantity('teaseanddenial_vibe')}<br>`;
        debugInfo += `- canBodyPartHold(Ha, hand): ${conditions.canBodyPartHold('Ha', 'hand')}<br>`;
        debugInfo += `- isHolding(vibe): ${conditions.isHolding('vibe')}<br>`;
    }
    
    // Filter available tasks
    const availableTasks = taskList.filter(task => {
        const canSelect = !task.canSelect || task.canSelect(conditions);
        return canSelect;
    });
    
    debugInfo += `<br><strong>Available tasks: ${availableTasks.length} / ${taskList.length}</strong><br>`;
    
    if (availableTasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = `<div>No snake/ladder tasks available!${debugInfo}</div>`;
        return;
    }
    
    // Prioritize conditional tasks (those with canSelect) over fallback tasks
    const conditionalTasks = availableTasks.filter(t => t.canSelect);
    const selectedTask = conditionalTasks.length > 0 ? 
        conditionalTasks[Math.floor(Math.random() * conditionalTasks.length)] :
        availableTasks[Math.floor(Math.random() * availableTasks.length)];
    
    debugInfo += `Conditional tasks available: ${conditionalTasks.length}<br>`;
    debugInfo += `Task selected: ${selectedTask.canSelect ? 'CONDITIONAL' : 'FALLBACK'}`;
    debugInfo += '</div>';
    
    // Create difficulty map
    const difficultyMap = {};
    for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
        const [setId, ...toyIdParts] = toyKey.split('_');
        const toyId = toyIdParts.join('_');
        if (!difficultyMap[toyId]) {
            difficultyMap[toyId] = diff;
        }
    }
    
    // Get the primary difficulty (use 'medium' as default)
    const primaryDifficulty = 'medium';
    
    // Display the task
    instructions.classList.add('active');
    const content = selectedTask.getDifficulty(primaryDifficulty, conditions, difficultyMap, snakeLadderInfo);
    instructions.innerHTML = content + debugInfo;
    
    saveGameState();
}

function displayRandomInstructionWithAddRemove(addRemoveTask) {
    const toys = getSelectedToys();
    
    if (currentMetronomeTask) {
        currentMetronomeTask.cleanup();
        currentMetronomeTask = null;
    }
    
    if (toys.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>üéØ Select instruction sets and toys to get started!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const conditions = getTaskConditions();
    
    // First, check if any toys have "always" tasks
    const alwaysTasks = checkForAlwaysTasks(toys, conditions);
    
    if (alwaysTasks.length > 0) {
        const selectedAlways = alwaysTasks[Math.floor(Math.random() * alwaysTasks.length)];
        const {task, toyObj, taskId} = selectedAlways;
        
        // Increment turn counts
        const selectedToyKey = `${toyObj.setId}_${toyObj.toyId}`;
        turnCountBySet[toyObj.setId] = (turnCountBySet[toyObj.setId] || 0) + 1;
        turnCountByToy[selectedToyKey] = (turnCountByToy[selectedToyKey] || 0) + 1;
        lastSelectedSet[toyObj.toyId] = toyObj.setId;
        
        // Execute the task if it has an execute function
        if (task.execute) {
            task.execute();
        }
        
        // Mark onlyOnce task as completed
        if (task.onlyOnce && taskId) {
            completedOnlyOnceTasks[taskId] = true;
        }
        
        window.lastTaskInfo = {
            toyId: toyObj.toyId,
            setId: toyObj.setId,
            difficulty: toyObj.difficulty,
            taskType: 'always'
        };
        
        instructions.classList.add('active');
        
        // Create difficulty map
        const difficultyMap = {};
        for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_');
            if (!difficultyMap[toyId]) {
                difficultyMap[toyId] = diff;
            }
        }
        
        const content = task.getDifficulty(toyObj.difficulty, conditions, difficultyMap);
        instructions.innerHTML = content;
        saveGameState();
        return;
    }
    
    // No "always" tasks - proceed with normal task selection
    // Filter toys to only those with available tasks
    const toysWithAvailableTasks = toys.filter(toyObj => {
        const tasks = instructionSets[toyObj.setId].tasks[toyObj.toyId];
        if (!tasks || tasks.length === 0) return false;
        
        const availableTasks = tasks.filter(task => {
            // Filter out add/remove tasks - they're handled separately
            if (task.type === 'add' || task.type === 'remove') return false;
            // Filter out tasks excluded from normal pool
            if (task.excludeFromNormalPool) return false;
            // Check canSelect condition if it exists
            return !task.canSelect || task.canSelect(conditions);
        });
        
        return availableTasks.length > 0;
    });
    
    if (toysWithAvailableTasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>No available tasks for current conditions!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const randomToyObj = toysWithAvailableTasks[Math.floor(Math.random() * toysWithAvailableTasks.length)];
    const tasks = instructionSets[randomToyObj.setId].tasks[randomToyObj.toyId];
    
    const availableTasks = tasks.filter(task => {
        // Filter out add/remove tasks - they're handled separately
        if (task.type === 'add' || task.type === 'remove') return false;
        // Filter out tasks excluded from normal pool
        if (task.excludeFromNormalPool) return false;
        // Check canSelect condition if it exists
        return !task.canSelect || task.canSelect(conditions);
    });
    
    const randomTask = availableTasks[Math.floor(Math.random() * availableTasks.length)];
    
    // Increment turn counts for this set and toy
    const selectedToyKey = `${randomToyObj.setId}_${randomToyObj.toyId}`;
    turnCountBySet[randomToyObj.setId] = (turnCountBySet[randomToyObj.setId] || 0) + 1;
    turnCountByToy[selectedToyKey] = (turnCountByToy[selectedToyKey] || 0) + 1;
    lastSelectedSet[randomToyObj.toyId] = randomToyObj.setId;
    
    window.lastTaskInfo = {
        toyId: randomToyObj.toyId,
        setId: randomToyObj.setId,
        difficulty: randomToyObj.difficulty,
        taskType: randomTask.type || 'normal'
    };
    
    instructions.classList.add('active');
    
    let addRemoveHTML = '';
    if (addRemoveTask) {
        const html = addRemoveTask.getHTML();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const strong = doc.querySelector('strong');
        const paragraphs = doc.querySelectorAll('p');
        let text = '';
        if (strong) text += `<strong>${strong.textContent}</strong>`;
        paragraphs.forEach(p => text += `<p>${p.textContent}</p>`);
        addRemoveHTML = text;
    }
    
    // Create difficulty map for all toys
    const difficultyMap = {};
    for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
        const [setId, ...toyIdParts] = toyKey.split('_');
        const toyId = toyIdParts.join('_');
        if (!difficultyMap[toyId]) {
            difficultyMap[toyId] = diff;
        }
    }
    
    if (randomTask.type === 'metronome') {
        const beatCount = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        window.lastTaskInfo.beatCount = beatCount;
        currentMetronomeTask = createMetronomeTask(beatCount);
        instructions.innerHTML = addRemoveHTML;
        instructions.appendChild(currentMetronomeTask.element);
    } else if (randomTask.type === 'redlight') {
        const duration = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        window.lastTaskInfo.duration = duration;
        currentMetronomeTask = createRedLightGreenLightTask(duration);
        instructions.innerHTML = addRemoveHTML;
        instructions.appendChild(currentMetronomeTask.element);
    } else {
        const content = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        instructions.innerHTML = addRemoveHTML + content;
    }
}

// Render Toy Library  
// Calculate and update the total add/remove probabilities
function updateContinuousTaskProbabilities() {
    // Get all selected toys
    const selectedToys = getSelectedToys();
    
    // Calculate probability that at least one add task triggers
    // P(at least one) = 1 - P(none trigger) = 1 - (1-p1)(1-p2)(1-p3)...
    let probNoAddTriggers = 1.0;
    let probNoRemoveTriggers = 1.0;
    
    let hasAnyAddTasks = false;
    let hasAnyRemoveTasks = false;
    
    selectedToys.forEach(toyObj => {
        const toyKey = `${toyObj.setId}_${toyObj.toyId}`;
        const toyId = toyObj.toyId;
        const tasks = instructionSets[toyObj.setId].tasks[toyObj.toyId];
        
        if (!tasks) return;
        
        // Check if this toy has add/remove tasks
        const hasAddTask = tasks.some(task => task.type === 'add');
        const hasRemoveTask = tasks.some(task => task.type === 'remove');
        
        if (hasAddTask) {
            // Get the add probability for this toy (default 10%)
            // If cage is locked, treat as 0
            let addChance = toyModifiers[toyKey]?.addChance ?? 10;
            if (toyId === 'cage' && cageLocked) {
                addChance = 0;
            }
            // Only include in calculation if chance > 0
            if (addChance > 0) {
                const addProbability = addChance / 100;
                // Multiply by probability this one doesn't trigger
                probNoAddTriggers *= (1 - addProbability);
                hasAnyAddTasks = true;
            }
        }
        
        if (hasRemoveTask) {
            // Get the remove probability for this toy (default 20%)
            // If cage is locked, treat as 0
            let removeChance = toyModifiers[toyKey]?.removeChance ?? 20;
            if (toyId === 'cage' && cageLocked) {
                removeChance = 0;
            }
            // Only include in calculation if chance > 0
            if (removeChance > 0) {
                const removeProbability = removeChance / 100;
                // Multiply by probability this one doesn't trigger
                probNoRemoveTriggers *= (1 - removeProbability);
                hasAnyRemoveTasks = true;
            }
        }
    });
    
    // Calculate probability at least one triggers (only if there are any tasks)
    const totalAddProb = hasAnyAddTasks ? (1 - probNoAddTriggers) * 100 : 0;
    const totalRemoveProb = hasAnyRemoveTasks ? (1 - probNoRemoveTriggers) * 100 : 0;
    
    // Update the display
    document.getElementById('totalAddProbability').textContent = totalAddProb.toFixed(1) + '%';
    document.getElementById('totalRemoveProbability').textContent = totalRemoveProb.toFixed(1) + '%';
}

// Update cage input states based on locked status
function updateCageInputStates() {
    // Update all cage add/remove inputs across all sets
    // Instead of using toyData, iterate through all possible cage inputs by checking the DOM
    const allInputs = document.querySelectorAll('input[id^="add_"], input[id^="remove_"]');
    
    allInputs.forEach(input => {
        // Check if this is a cage input
        if (input.id.includes('_cage')) {
            const isAdd = input.id.startsWith('add_');
            const toyKey = input.id.replace('add_', '').replace('remove_', '');
            
            if (cageLocked) {
                input.value = 0;
                input.disabled = true;
                input.style.opacity = '0.5';
                input.style.pointerEvents = 'none';
            } else {
                if (isAdd) {
                    input.value = toyModifiers[toyKey]?.addChance ?? 10;
                } else {
                    input.value = toyModifiers[toyKey]?.removeChance ?? 20;
                }
                input.disabled = !toyChecked['cage'] || !toySetEnabled[toyKey];
                input.style.opacity = '1';
                input.style.pointerEvents = 'auto';
            }
        }
    });
}

function renderToyLibrary() {
    selectedSets = Array.from(document.querySelectorAll('#instructionSetCheckboxes input:checked'))
        .map(cb => cb.value);
    
    const container = document.getElementById('toyLibraryContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    const setEmojis = {dressup: 'üé®', apple: 'üçé', digging: '‚õèÔ∏è', teaseanddenial: 'üéØ'};
    const allToys = {};
    
    // Always add cage toy first with empty sets array
    allToys['cage'] = {
        id: 'cage',
        name: 'Cage üîí',
        sets: [],
        alwaysVisible: true
    };
    
    selectedSets.forEach(setId => {
        if (instructionSets[setId]) {
            instructionSets[setId].toys.forEach(toy => {
                if (toy.id === 'cage') {
                    // Add this set to cage's sets array
                    allToys['cage'].sets.push({
                        setId,
                        setName: instructionSets[setId].name,
                        emoji: setEmojis[setId] || ''
                    });
                } else {
                    // Regular toy handling
                    if (!allToys[toy.id]) {
                        allToys[toy.id] = {id: toy.id, name: toy.name, sets: []};
                    }
                    allToys[toy.id].sets.push({
                        setId,
                        setName: instructionSets[setId].name,
                        emoji: setEmojis[setId] || ''
                    });
                }
            });
        }
    });
    
    for (const [toyId, toyData] of Object.entries(allToys)) {
        const toyItem = document.createElement('div');
        toyItem.className = 'toy-library-item';
        
        const toyKeys = toyData.sets.map(s => `${s.setId}_${toyId}`);
        
        toyKeys.forEach(key => {
            if (toyQuantities[key] === undefined) toyQuantities[key] = 1;
            if (!toyModifiers[key]) toyModifiers[key] = {addChance: 10, removeChance: 20};
            if (!toyDifficulties[key]) toyDifficulties[key] = 'medium';
            if (toySetEnabled[key] === undefined) toySetEnabled[key] = true;
        });
        
        if (toyChecked[toyId] === undefined) toyChecked[toyId] = true;
        
        const enabledKeys = toyKeys.filter(key => toySetEnabled[key]);
        
        const toyQuantity = toyQuantities[toyKeys[0]] || 1;
        
        const header = document.createElement('div');
        header.className = 'toy-header';
        
        const checkboxWrapper = document.createElement('div');
        checkboxWrapper.className = 'toy-checkbox-wrapper';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = toyChecked[toyId];
        checkbox.style.cursor = 'pointer';
        checkbox.onchange = () => {
            toyChecked[toyId] = checkbox.checked;
            
            // Update disabled states for this toy's sets and inputs
            toyData.sets.forEach(setInfo => {
                const toyKey = `${setInfo.setId}_${toyId}`;
                
                // Update set checkbox
                const setCheckbox = document.querySelector(`input[type="checkbox"][data-toy-key="${toyKey}"]`);
                if (setCheckbox) {
                    setCheckbox.disabled = !checkbox.checked;
                }
                
                // Update difficulty dropdown
                const diffSelect = document.getElementById(`difficulty_${toyKey}`);
                if (diffSelect) {
                    diffSelect.disabled = !checkbox.checked || !toySetEnabled[toyKey];
                }
                
                // Update add/remove inputs
                const addInput = document.getElementById(`add_${toyKey}`);
                const removeInput = document.getElementById(`remove_${toyKey}`);
                if (addInput) {
                    addInput.disabled = !checkbox.checked || !toySetEnabled[toyKey] || (toyId === 'cage' && cageLocked);
                }
                if (removeInput) {
                    removeInput.disabled = !checkbox.checked || !toySetEnabled[toyKey] || (toyId === 'cage' && cageLocked);
                }
            });
            
            updateContinuousTaskProbabilities();
            saveGameState();
        };
        checkboxWrapper.appendChild(checkbox);
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'toy-name';
        nameSpan.textContent = toyData.name;
        
        header.appendChild(checkboxWrapper);
        header.appendChild(nameSpan);
        toyItem.appendChild(header);
        
        // Special handling for cage toy
        if (toyId === 'cage') {
            const cageControls = document.createElement('div');
            cageControls.className = 'toy-controls';
            cageControls.style.cssText = 'margin-left: 28px; margin-top: 10px; display: flex; flex-direction: row; gap: 16px; align-items: center;';
            
            // Worn checkbox (now first)
            const wornLabel = document.createElement('label');
            wornLabel.style.cssText = 'display: flex; align-items: center; gap: 8px; cursor: pointer;';
            
            const wornCheckbox = document.createElement('input');
            wornCheckbox.type = 'checkbox';
            wornCheckbox.checked = cageWorn;
            wornCheckbox.disabled = !toyChecked[toyId];
            wornCheckbox.style.cssText = 'width: 18px; height: 18px; cursor: pointer; accent-color: #667eea;';
            
            const wornText = document.createElement('span');
            wornText.textContent = 'üëï Start Worn';
            wornText.style.cssText = 'font-weight: 600; color: #333;';
            
            wornLabel.appendChild(wornCheckbox);
            wornLabel.appendChild(wornText);
            cageControls.appendChild(wornLabel);
            
            // Locked checkbox (now second)
            const lockedLabel = document.createElement('label');
            lockedLabel.style.cssText = 'display: flex; align-items: center; gap: 8px; cursor: pointer;';
            
            const lockedCheckbox = document.createElement('input');
            lockedCheckbox.type = 'checkbox';
            lockedCheckbox.checked = cageLocked;
            lockedCheckbox.disabled = !toyChecked[toyId];
            lockedCheckbox.style.cssText = 'width: 18px; height: 18px; cursor: pointer; accent-color: #667eea;';
            lockedCheckbox.onchange = () => {
                cageLocked = lockedCheckbox.checked;
                saveGameState();
                // Update all cage add/remove inputs to show locked state
                updateCageInputStates();
            };
            
            const lockedText = document.createElement('span');
            lockedText.textContent = 'üîí Locked';
            lockedText.style.cssText = 'font-weight: 600; color: #333;';
            
            lockedLabel.appendChild(lockedCheckbox);
            lockedLabel.appendChild(lockedText);
            cageControls.appendChild(lockedLabel);
            
            // Worn checkbox change handler
            wornCheckbox.onchange = () => {
                cageWorn = wornCheckbox.checked;
                
                // If unchecking worn, also uncheck and disable locked
                if (!cageWorn) {
                    cageLocked = false;
                    lockedCheckbox.checked = false;
                    lockedCheckbox.disabled = true;
                    lockedCheckbox.style.opacity = '0.5';
                    lockedText.style.color = '#999';
                } else {
                    lockedCheckbox.disabled = false;
                    lockedCheckbox.style.opacity = '1';
                    lockedText.style.color = '#333';
                }
                
                saveGameState();
            };
            
            // Set initial locked state based on worn
            if (!cageWorn) {
                lockedCheckbox.disabled = true;
                lockedCheckbox.style.opacity = '0.5';
                lockedText.style.color = '#999';
            }
            
            toyItem.appendChild(cageControls);
            
            // If cage has sets (Tease And Denial or Anal selected), show difficulty/modifiers
            if (toyData.sets.length > 0) {
                const setDifficultyContainer = document.createElement('div');
                setDifficultyContainer.className = 'set-difficulty';
                
                toyData.sets.forEach(setInfo => {
                    const toyKey = `${setInfo.setId}_${toyId}`;
                    const setItem = document.createElement('div');
                    setItem.className = 'set-difficulty-item';
                    
                    const diffRow = document.createElement('div');
                    diffRow.className = 'difficulty-row';
                    
                    const setCheckboxWrapper = document.createElement('div');
                    setCheckboxWrapper.style.cssText = 'display:flex;align-items:center;gap:8px;';
                    
                    const setCheckbox = document.createElement('input');
                    setCheckbox.type = 'checkbox';
                    setCheckbox.checked = toySetEnabled[toyKey];
                    setCheckbox.setAttribute('data-toy-key', toyKey);
                    setCheckbox.style.cssText = 'width:16px;height:16px;cursor:pointer;accent-color:#667eea;';
                    setCheckbox.disabled = !toyChecked[toyId];
                    setCheckbox.onchange = () => {
                        toySetEnabled[toyKey] = setCheckbox.checked;
                        
                        // Update difficulty dropdown
                        const diffSelect = document.getElementById(`difficulty_${toyKey}`);
                        if (diffSelect) {
                            diffSelect.disabled = !toyChecked[toyId] || !setCheckbox.checked;
                        }
                        
                        // Update add/remove inputs
                        const addInput = document.getElementById(`add_${toyKey}`);
                        const removeInput = document.getElementById(`remove_${toyKey}`);
                        if (addInput) {
                            addInput.disabled = !toyChecked[toyId] || !setCheckbox.checked || (toyId === 'cage' && cageLocked);
                        }
                        if (removeInput) {
                            removeInput.disabled = !toyChecked[toyId] || !setCheckbox.checked || (toyId === 'cage' && cageLocked);
                        }
                        
                        updateContinuousTaskProbabilities();
                        saveGameState();
                    };
                    setCheckboxWrapper.appendChild(setCheckbox);
                    
                    const setNameSpan = document.createElement('span');
                    setNameSpan.textContent = `${setInfo.emoji} ${setInfo.setName}`;
                    setCheckboxWrapper.appendChild(setNameSpan);
                    diffRow.appendChild(setCheckboxWrapper);
                    
                    const diffControls = document.createElement('div');
                    diffControls.className = 'difficulty-controls';
                    
                    const diffSelect = document.createElement('select');
                    diffSelect.id = `difficulty_${toyKey}`;
                    diffSelect.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
                    
                    ['easy', 'medium', 'hard'].forEach(level => {
                        const opt = document.createElement('option');
                        opt.value = level;
                        opt.textContent = level == 'easy' ? 'Easy üòä' : level == 'medium' ? 'Medium üòê' : 'Hard üò§';
                        if (level == (toyDifficulties[toyKey] || 'medium')) opt.selected = true;
                        diffSelect.appendChild(opt);
                    });
                    
                    diffSelect.onchange = () => {
                        toyDifficulties[toyKey] = diffSelect.value;
                        applyPreset(toyKey, diffSelect.value);
                        saveGameState();
                    };
                    diffControls.appendChild(diffSelect);
                    
                    const isWearable = isToyWearable(toyId);
                    const hasAddRemove = toyHasAddRemoveTasks(toyKey);
                    const gearBtn = document.createElement('button');
                    gearBtn.className = 'gear-btn';
                    gearBtn.textContent = '‚öôÔ∏è';
                    gearBtn.title = !isWearable ? 'This toy cannot be worn/held' : !hasAddRemove ? 'This toy has no add/remove tasks' : 'Advanced Settings';
                    gearBtn.disabled = !isWearable || !hasAddRemove || !toyChecked[toyId] || !toySetEnabled[toyKey];
                    gearBtn.id = `gear_${toyKey}`;
                    
                    // Restore active state if it was previously expanded
                    if (expandedAdvancedSettings[toyKey]) {
                        gearBtn.classList.add('active');
                    }
                    
                    if (isWearable && hasAddRemove) {
                        gearBtn.onclick = (e) => {
                            e.preventDefault();
                            const advSettings = setItem.querySelector('.advanced-settings');
                            if (advSettings.classList.contains('visible')) {
                                advSettings.classList.remove('visible');
                                gearBtn.classList.remove('active');
                                expandedAdvancedSettings[toyKey] = false;
                            } else {
                                advSettings.classList.add('visible');
                                gearBtn.classList.add('active');
                                expandedAdvancedSettings[toyKey] = true;
                            }
                        };
                    }
                    diffControls.appendChild(gearBtn);
                    diffRow.appendChild(diffControls);
                    setItem.appendChild(diffRow);
                    
                    if (isWearable && hasAddRemove) {
                        const advSettings = document.createElement('div');
                        advSettings.className = 'advanced-settings';
                        
                        // Restore expanded state if it was previously expanded
                        if (expandedAdvancedSettings[toyKey]) {
                            advSettings.classList.add('visible');
                        }
                        
                        const addLabel = document.createElement('label');
                        addLabel.textContent = 'Add: ';
                        const addInput = document.createElement('input');
                        addInput.type = 'number';
                        addInput.min = '0';
                        addInput.max = '100';
                        // Show 0 if cage is locked, otherwise show stored value
                        addInput.value = (toyId === 'cage' && cageLocked) ? 0 : (toyModifiers[toyKey]?.addChance ?? 10);
                        addInput.id = `add_${toyKey}`;
                        // Disable if locked or if toy/set disabled
                        addInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey] || (toyId === 'cage' && cageLocked);
                        addInput.oninput = (e) => {
                            const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                            e.target.value = val;
                            if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                            toyModifiers[toyKey].addChance = val;
                            updateContinuousTaskProbabilities();
                            saveGameState();
                        };
                        addLabel.appendChild(addInput);
                        const addPercent = document.createTextNode('%');
                        addLabel.appendChild(addPercent);
                        advSettings.appendChild(addLabel);
                        
                        const removeLabel = document.createElement('label');
                        removeLabel.textContent = 'Remove: ';
                        const removeInput = document.createElement('input');
                        removeInput.type = 'number';
                        removeInput.min = '0';
                        removeInput.max = '100';
                        // Show 0 if cage is locked, otherwise show stored value
                        removeInput.value = (toyId === 'cage' && cageLocked) ? 0 : (toyModifiers[toyKey]?.removeChance ?? 20);
                        removeInput.id = `remove_${toyKey}`;
                        // Disable if locked or if toy/set disabled
                        removeInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey] || (toyId === 'cage' && cageLocked);
                        removeInput.oninput = (e) => {
                            const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                            e.target.value = val;
                            if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                            toyModifiers[toyKey].removeChance = val;
                            updateContinuousTaskProbabilities();
                            saveGameState();
                        };
                        removeLabel.appendChild(removeInput);
                        const removePercent = document.createTextNode('%');
                        removeLabel.appendChild(removePercent);
                        advSettings.appendChild(removeLabel);
                        
                        setItem.appendChild(advSettings);
                    }
                    
                    setDifficultyContainer.appendChild(setItem);
                });
                
                toyItem.appendChild(setDifficultyContainer);
            }
            
            container.appendChild(toyItem);
            
            // Apply locked state to inputs after rendering
            if (typeof updateCageInputStates === 'function') {
                updateCageInputStates();
            }
            
            continue; // Skip normal rendering for cage
        }
        
        const controls = document.createElement('div');
        controls.className = 'toy-controls';
        
        const qtyLabel = document.createElement('label');
        qtyLabel.textContent = 'Qty:';
        controls.appendChild(qtyLabel);
        
        const qtyInput = document.createElement('input');
        qtyInput.type = 'number';
        qtyInput.min = '1';
        qtyInput.value = toyQuantity;
        qtyInput.id = `qty_total_${toyId}`;
        qtyInput.disabled = !toyChecked[toyId];
        qtyInput.onchange = () => {
            const newQty = Math.max(1, parseInt(qtyInput.value) || 1);
            toyKeys.forEach(key => {
                toyQuantities[key] = newQty;
            });
            renderToyLibrary();
            saveGameState();
        };
        controls.appendChild(qtyInput);
        toyItem.appendChild(controls);
        
        const setDifficultyContainer = document.createElement('div');
        setDifficultyContainer.className = 'set-difficulty';
        
        toyData.sets.forEach(setInfo => {
            const toyKey = `${setInfo.setId}_${toyId}`;
            const setItem = document.createElement('div');
            setItem.className = 'set-difficulty-item';
            
            const diffRow = document.createElement('div');
            diffRow.className = 'difficulty-row';
            
            const setCheckboxWrapper = document.createElement('div');
            setCheckboxWrapper.style.cssText = 'display:flex;align-items:center;gap:8px;';
            
            const setCheckbox = document.createElement('input');
            setCheckbox.type = 'checkbox';
            setCheckbox.checked = toySetEnabled[toyKey];
            setCheckbox.setAttribute('data-toy-key', toyKey);
            setCheckbox.style.cssText = 'width:16px;height:16px;cursor:pointer;accent-color:#667eea;';
            
            setCheckbox.disabled = !toyChecked[toyId];
            
            setCheckbox.onchange = () => {
                toySetEnabled[toyKey] = setCheckbox.checked;
                
                // Update difficulty dropdown
                const diffSelect = document.getElementById(`difficulty_${toyKey}`);
                if (diffSelect) {
                    diffSelect.disabled = !toyChecked[toyId] || !setCheckbox.checked;
                }
                
                // Update add/remove inputs
                const addInput = document.getElementById(`add_${toyKey}`);
                const removeInput = document.getElementById(`remove_${toyKey}`);
                if (addInput) {
                    addInput.disabled = !toyChecked[toyId] || !setCheckbox.checked || (toyId === 'cage' && cageLocked);
                }
                if (removeInput) {
                    removeInput.disabled = !toyChecked[toyId] || !setCheckbox.checked || (toyId === 'cage' && cageLocked);
                }
                
                updateContinuousTaskProbabilities();
                saveGameState();
            };
            setCheckboxWrapper.appendChild(setCheckbox);
            
            const setNameSpan = document.createElement('span');
            setNameSpan.textContent = `${setInfo.emoji} ${setInfo.setName}`;
            setCheckboxWrapper.appendChild(setNameSpan);
            diffRow.appendChild(setCheckboxWrapper);
            
            const diffControls = document.createElement('div');
            diffControls.className = 'difficulty-controls';
            
            const diffSelect = document.createElement('select');
            diffSelect.id = `difficulty_${toyKey}`;
            diffSelect.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
            
            ['easy', 'medium', 'hard'].forEach(level => {
                const opt = document.createElement('option');
                opt.value = level;
                opt.textContent = level == 'easy' ? 'Easy üòä' : level == 'medium' ? 'Medium üòê' : 'Hard üò§';
                if (level == (toyDifficulties[toyKey] || 'medium')) opt.selected = true;
                diffSelect.appendChild(opt);
            });
            
            diffSelect.onchange = () => {
                toyDifficulties[toyKey] = diffSelect.value;
                applyPreset(toyKey, diffSelect.value);
                saveGameState();
            };
            diffControls.appendChild(diffSelect);
            
            const isWearable = isToyWearable(toyId);
            const hasAddRemove = toyHasAddRemoveTasks(toyKey);
            const gearBtn = document.createElement('button');
            gearBtn.className = 'gear-btn';
            gearBtn.textContent = '‚öôÔ∏è';
            gearBtn.title = !isWearable ? 'This toy cannot be worn/held' : !hasAddRemove ? 'This toy has no add/remove tasks' : 'Advanced Settings';
            gearBtn.disabled = !isWearable || !hasAddRemove || !toyChecked[toyId] || !toySetEnabled[toyKey];
            gearBtn.id = `gear_${toyKey}`;
            
            // Restore active state if it was previously expanded
            if (expandedAdvancedSettings[toyKey]) {
                gearBtn.classList.add('active');
            }
            
            if (isWearable && hasAddRemove) {
                gearBtn.onclick = (e) => {
                    e.preventDefault();
                    const advSettings = setItem.querySelector('.advanced-settings');
                    if (advSettings.classList.contains('visible')) {
                        advSettings.classList.remove('visible');
                        gearBtn.classList.remove('active');
                        expandedAdvancedSettings[toyKey] = false;
                    } else {
                        advSettings.classList.add('visible');
                        gearBtn.classList.add('active');
                        expandedAdvancedSettings[toyKey] = true;
                    }
                };
            }
            diffControls.appendChild(gearBtn);
            diffRow.appendChild(diffControls);
            setItem.appendChild(diffRow);
            
            if (isWearable && hasAddRemove) {
                const advSettings = document.createElement('div');
                advSettings.className = 'advanced-settings';
                
                // Restore expanded state if it was previously expanded
                if (expandedAdvancedSettings[toyKey]) {
                    advSettings.classList.add('visible');
                }
                
                const addLabel = document.createElement('label');
                addLabel.textContent = 'Add: ';
                const addInput = document.createElement('input');
                addInput.type = 'number';
                addInput.min = '0';
                addInput.max = '100';
                addInput.value = toyModifiers[toyKey]?.addChance ?? 10;
                addInput.id = `add_${toyKey}`;
                addInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
                addInput.oninput = (e) => {
                    const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                    e.target.value = val;
                    if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                    toyModifiers[toyKey].addChance = val;
                    updateContinuousTaskProbabilities();
                    saveGameState();
                };
                addLabel.appendChild(addInput);
                const addPercent = document.createTextNode('%');
                addLabel.appendChild(addPercent);
                advSettings.appendChild(addLabel);
                
                const removeLabel = document.createElement('label');
                removeLabel.textContent = 'Remove: ';
                const removeInput = document.createElement('input');
                removeInput.type = 'number';
                removeInput.min = '0';
                removeInput.max = '100';
                removeInput.value = toyModifiers[toyKey]?.removeChance ?? 20;
                removeInput.id = `remove_${toyKey}`;
                removeInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
                removeInput.oninput = (e) => {
                    const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                    e.target.value = val;
                    if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                    toyModifiers[toyKey].removeChance = val;
                    updateContinuousTaskProbabilities();
                    saveGameState();
                };
                removeLabel.appendChild(removeInput);
                const removePercent = document.createTextNode('%');
                removeLabel.appendChild(removePercent);
                advSettings.appendChild(removeLabel);
                
                setItem.appendChild(advSettings);
            }
            
            setDifficultyContainer.appendChild(setItem);
        });
        
        toyItem.appendChild(setDifficultyContainer);
        container.appendChild(toyItem);
    }
    
    // Update cage input states after rendering
    updateCageInputStates();
    
    // Update continuous task probabilities
    updateContinuousTaskProbabilities();
    
    saveGameState();
}

function applyPreset(toyKey, difficulty) {
    const presets = {
        easy: {addChance: 5, removeChance: 25},
        medium: {addChance: 10, removeChance: 20},
        hard: {addChance: 15, removeChance: 15}
    };
    
    if (presets[difficulty]) {
        const [setId, ...toyIdParts] = toyKey.split('_');
        const toyId = toyIdParts.join('_');
        
        // If this is cage and it's locked, don't change add/remove values
        if (toyId === 'cage' && cageLocked) {
            toyDifficulties[toyKey] = difficulty;
            // Don't update toyModifiers or inputs
            saveGameState();
            return;
        }
        
        toyModifiers[toyKey] = {...presets[difficulty]};
        toyDifficulties[toyKey] = difficulty;
        
        const addInput = document.getElementById(`add_${toyKey}`);
        const removeInput = document.getElementById(`remove_${toyKey}`);
        if (addInput) addInput.value = toyModifiers[toyKey].addChance;
        if (removeInput) removeInput.value = toyModifiers[toyKey].removeChance;
        
        updateContinuousTaskProbabilities();
        saveGameState();
    }
}

// Event Listeners
document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => {
    cb.addEventListener('change', () => {
        renderToyLibrary();
        saveGameState();
    });
});

// Final Challenge probability sliders
const strokingSlider = document.getElementById('strokingSlider');
const vibeSlider = document.getElementById('vibeSlider');
const analSlider = document.getElementById('analSlider');

function updateFinalChallengeDisplays() {
    document.getElementById('strokingPercent').textContent = finalChallengeSettings.stroking + '%';
    document.getElementById('vibePercent').textContent = finalChallengeSettings.vibe + '%';
    document.getElementById('analPercent').textContent = finalChallengeSettings.anal + '%';
    
    strokingSlider.value = finalChallengeSettings.stroking;
    vibeSlider.value = finalChallengeSettings.vibe;
    analSlider.value = finalChallengeSettings.anal;
    
    saveGameState();
}

strokingSlider.addEventListener('input', function() {
    const newStroking = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(finalChallengeSettings.anal);
    finalChallengeSettings.stroking = newStroking > maxAllowed ? maxAllowed : newStroking;
    finalChallengeSettings.vibe = 100 - finalChallengeSettings.anal - finalChallengeSettings.stroking;
    updateFinalChallengeDisplays();
});

vibeSlider.addEventListener('input', function() {
    const newVibe = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(finalChallengeSettings.anal);
    finalChallengeSettings.vibe = newVibe > maxAllowed ? maxAllowed : newVibe;
    finalChallengeSettings.stroking = 100 - finalChallengeSettings.anal - finalChallengeSettings.vibe;
    updateFinalChallengeDisplays();
});

analSlider.addEventListener('input', function() {
    const newAnal = Math.round(parseFloat(this.value));
    
    // Special case: if anal is 100%, force the others to 0
    if (newAnal >= 100) {
        finalChallengeSettings.stroking = 0;
        finalChallengeSettings.vibe = 0;
        finalChallengeSettings.anal = 100;
    } else {
        const available = 100 - newAnal;
        const currentTotal = Math.round(finalChallengeSettings.stroking) + Math.round(finalChallengeSettings.vibe);
        
        // Changed: use equal split for BOTH directions (not just when increasing)
        if (available !== currentTotal) {
            const change = available - currentTotal;
            const half = change / 2;
            finalChallengeSettings.stroking = Math.max(0, Math.round(finalChallengeSettings.stroking + half));
            finalChallengeSettings.vibe = Math.max(0, Math.round(finalChallengeSettings.vibe + half));
            
            // Ensure total is exactly 100 by adjusting anal if values were clamped
            const actualTotal = finalChallengeSettings.stroking + finalChallengeSettings.vibe;
            finalChallengeSettings.anal = Math.max(0, 100 - actualTotal);
        } else {
            finalChallengeSettings.anal = Math.max(0, newAnal);
        }
    }
    
    updateFinalChallengeDisplays();
});

// Final challenge type checkboxes
['stroking_icyhot', 'stroking_icewater', 'stroking_ktb', 'stroking_ballsqueeze', 'stroking_2finger',
 'vibe_icyhot', 'vibe_icewater', 'anal_vibe'].forEach(id => {
    document.getElementById(id).addEventListener('change', function() {
        finalChallengeTypes[id] = this.checked;
        saveGameState();
    });
});

// Final challenge difficulty dropdowns
['stroking', 'vibe', 'anal'].forEach(type => {
    document.getElementById(`${type}Difficulty`).addEventListener('change', function() {
        finalChallengeDifficulties[type] = this.value;
        saveGameState();
    });
});

// Final challenge modifier percentage inputs
['stroking_icyhot', 'stroking_icewater', 'stroking_ktb', 'stroking_ballsqueeze', 'stroking_2finger',
 'vibe_icyhot', 'vibe_icewater', 'anal_vibe'].forEach(id => {
    document.getElementById(`${id}_chance`).addEventListener('input', function() {
        let value = parseInt(this.value) || 0;
        value = Math.max(0, Math.min(100, value)); // Clamp between 0-100
        this.value = value;
        finalChallengeModifierChances[id] = value;
        saveGameState();
    });
});

// Final challenge modifier checkboxes
['ce', 'pf'].forEach(mod => {
    document.getElementById(`modifier_${mod}`).addEventListener('change', function() {
        finalChallengeModifiers[mod] = this.checked;
        saveGameState();
    });
});

document.getElementById('playerNameInput').addEventListener('input', function() {
    playerName = this.value;
    saveGameState();
});

function startGame() {
    const toys = getSelectedToys();
    if (toys.length === 0) {
        alert('‚ö†Ô∏è Please select at least one toy from the instruction sets before starting!');
        return;
    }
    
    playerName = document.getElementById('playerNameInput').value.trim();
    if (!playerName) {
        alert('‚ö†Ô∏è Please enter your name before starting!');
        return;
    }
    
    // Add cage to Pe if "Start Worn" is checked
    if (cageWorn && toyChecked['cage']) {
        addToyToBodyPart('Pe', 'cage');
    }
    
    gameStarted = true;
    saveGameState();
    
    startButton.style.display = 'none';
    const leftCol = document.querySelector('.settings-column-left');
    const rightCol = document.querySelector('.settings-column-right');
    if (leftCol) leftCol.style.display = 'none';
    if (rightCol) rightCol.style.display = 'none';
    
    instructions.classList.add('active');
    instructions.innerHTML = `
        <div style="font-size: 2em; font-weight: bold; color: #667eea; margin-bottom: 20px;">
            üçÄ Good Luck${playerName ? ' ' + playerName : ''}! üçÄ
        </div>
        <div style="font-size: 1.2em; color: #666; margin-bottom: 20px;">
            Roll the dice to begin!
        </div>
    `;
    
    rollDiceButton.style.display = 'block';
    diceResult.style.display = 'block';
    turnCounter.style.display = 'block';
    turnCounter.textContent = 'Turn: 0';
    document.getElementById('testJumpInput').style.display = 'block';
}

// Display final challenge task
function displayFinalChallenge() {
    // Roll prize type first (secretly)
    const prizeType = determinePrize();
    
    // Get condition helpers
    const conditionHelpers = getTaskConditions();
    
    // FIRST: Check for "always" tasks (priority tasks with specific conditions)
    const alwaysTasks = [];
    finalChallengeTasks.forEach((task, index) => {
        if (task.alwaysSelect && task.alwaysSelect(conditionHelpers)) {
            alwaysTasks.push({task, index});
        }
    });
    
    // If there are "always" tasks, randomly pick one
    if (alwaysTasks.length > 0) {
        const randomIndex = Math.floor(Math.random() * alwaysTasks.length);
        const selectedTask = alwaysTasks[randomIndex].task;
        const taskHTML = selectedTask.getDifficulty(null, conditionHelpers, toyDifficulties, prizeType);
        instructions.innerHTML = taskHTML;
        instructions.classList.add('active');
        return;
    }
    
    // SECOND: Use weighted probability to select task type
    const roll = Math.random() * 100;
    let targetTaskId = null;
    
    // Determine which task type based on weighted probability
    if (roll < finalChallengeSettings.stroking) {
        targetTaskId = 'stroking';
    } else if (roll < finalChallengeSettings.stroking + finalChallengeSettings.vibe) {
        targetTaskId = 'vibe';
    } else {
        targetTaskId = 'anal';
    }
    
    // Find the task with matching ID
    let selectedTask = finalChallengeTasks.find(task => task.id === targetTaskId);
    
    // If task not found or doesn't pass canSelect, use fallback
    if (!selectedTask || (selectedTask.canSelect && !selectedTask.canSelect(conditionHelpers))) {
        selectedTask = finalChallengeTasks.find(task => task.id === 'fallback');
    }
    
    // Display the task with secret prize type
    const taskHTML = selectedTask.getDifficulty(null, conditionHelpers, toyDifficulties, prizeType);
    
    instructions.innerHTML = taskHTML;
    instructions.classList.add('active');
}

function rollDice() {
    rollDiceButton.disabled = true;
    
    // Check if there's a jump value
    const jumpInput = document.getElementById('testJumpInput');
    const jumpValue = parseInt(jumpInput.value);
    
    let diceRoll, nextPosition;
    
    if (jumpValue >= 1 && jumpValue <= 100) {
        // Jump mode
        turnCount++; // Increment turn counter
        diceRoll = jumpValue - playerPosition; // Calculate "virtual" dice roll for display
        diceResult.textContent = `Jump to: ${jumpValue} üéØ`;
        turnCounter.textContent = `Turn: ${turnCount}`;
        nextPosition = jumpValue;
        jumpInput.value = ''; // Clear the input after jumping
    } else {
        // Normal dice roll
        turnCount++; // Increment turn counter
        diceRoll = Math.floor(Math.random() * 6) + 1;
        diceResult.textContent = `Dice: ${diceRoll} üé≤`;
        turnCounter.textContent = `Turn: ${turnCount}`;
        nextPosition = playerPosition + diceRoll;
        if (nextPosition > totalSquares) nextPosition = totalSquares;
    }
    
    let finalPosition = nextPosition;
    let showContinueButton = false;
    
    const isSnake = snakes[nextPosition];
    const isLadder = ladders[nextPosition];
    
    if (isSnake || isLadder) {
        finalPosition = isSnake ? snakes[nextPosition] : ladders[nextPosition];
        showContinueButton = true;
    }
    
    const addRemoveTask = rollForAddRemoveTasks();
    
    animatePlayer(playerPosition, nextPosition, () => {
        playerPosition = nextPosition;
        
        if (addRemoveTask) {
            addRemoveTask.execute();
        }
        
        // If landed on snake or ladder, show that task immediately
        if (isSnake || isLadder) {
            displaySnakeLadderTask(isSnake ? 'snake' : 'ladder', nextPosition, finalPosition);
        } else {
            displayRandomInstructionWithAddRemove(addRemoveTask);
        }
        saveGameState();
        
        if (playerPosition === totalSquares) {
            rollDiceButton.disabled = true;
            displayFinalChallenge();
            return;
        }
        
        instructions.appendChild(continueButton);
        continueButton.style.display = "block";
        
        if (showContinueButton) {
            continueButton.onclick = () => {
                if (currentMetronomeTask && !currentMetronomeTask.isComplete()) return;
                continueButton.style.display = "none";
                animatePlayer(nextPosition, finalPosition, () => {
                    playerPosition = finalPosition;
                    if (playerPosition === totalSquares) {
                        rollDiceButton.disabled = true;
                        displayFinalChallenge();
                        saveGameState();
                    } else {
                        rollDiceButton.disabled = false;
                        // After sliding down/climbing up, show normal task
                        displayRandomInstruction();
                        saveGameState();
                    }
                }, true);
            };
        } else {
            continueButton.onclick = () => {
                if (currentMetronomeTask && !currentMetronomeTask.isComplete()) return;
                continueButton.style.display = "none";
                rollDiceButton.disabled = false;
            };
        }
    });
}

// Modal Functions
const modal = document.getElementById('patchNotesModal');
const btn = document.getElementById('patchNotesBtn');
const span = document.getElementsByClassName('close-btn')[0];

btn.onclick = () => modal.style.display = 'block';
span.onclick = () => modal.style.display = 'none';
window.onclick = e => {
    if (e.target == modal) modal.style.display = 'none';
};

// Reset Functions
const resetBtn = document.getElementById('resetBtn');
const resetModal = document.getElementById('resetModal');
const confirmResetBtn = document.getElementById('confirmReset');
const cancelResetBtn = document.getElementById('cancelReset');

resetBtn.addEventListener('click', () => resetModal.style.display = 'block');
cancelResetBtn.addEventListener('click', () => resetModal.style.display = 'none');

confirmResetBtn.addEventListener('click', function() {
    resetModal.style.display = 'none';
    localStorage.removeItem('snakesLaddersGameState');
    
    gameStarted = false;
    playerPosition = 0;
    turnCount = 0;
    turnCountBySet = {};
    turnCountByToy = {};
    lastSelectedSet = {};
    playerName = '';
    player.remove();
    bodyPartState = JSON.parse(JSON.stringify(bodyParts));
    cageLocked = false;
    cageWorn = false;
    
    startButton.style.display = 'block';
    rollDiceButton.style.display = 'none';
    rollDiceButton.disabled = false;
    continueButton.style.display = 'none';
    instructions.classList.remove('active');
    instructions.innerHTML = '';
    diceResult.textContent = 'Dice: -';
    diceResult.style.display = 'none';
    turnCounter.textContent = 'Turn: 0';
    turnCounter.style.display = 'none';
    document.getElementById('testJumpInput').style.display = 'none';
    document.getElementById('testJumpInput').value = '';
    
    document.getElementById('playerNameInput').value = '';
    
    const leftCol = document.querySelector('.settings-column-left');
    const rightCol = document.querySelector('.settings-column-right');
    if (leftCol) leftCol.style.display = 'block';
    if (rightCol) rightCol.style.display = 'block';
    
    document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => cb.checked = false);
    
    toySetEnabled = {};
    toyChecked = {};
    selectedSets = [];
    toyDifficulties = {};
    toyQuantities = {};
    toyModifiers = {};
    prizeSettings = {full: 33, ruin: 33, denied: 34};
    
    updateSliderDisplays();
    renderToyLibrary();
});

// Initialize
startButton.addEventListener('click', startGame);
rollDiceButton.addEventListener('click', rollDice);
createBoard();
renderToyLibrary();

loadGameState();
    </script>
</body>
</html>
