<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snakes and Ladders</title>
    <style>
* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
}

body { 
    font-family: 'Segoe UI', sans-serif; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    min-height: 100vh; 
    padding: 20px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    color: #fff; 
}

h1 { 
    font-size: 3em; 
    margin-bottom: 30px; 
    text-shadow: 3px 3px 6px rgba(0,0,0,0.3); 
    animation: float 3s ease-in-out infinite; 
}

@keyframes float { 
    0%, 100% { transform: translateY(0); } 
    50% { transform: translateY(-10px); } 
}

#gameContainer { 
    background: rgba(255,255,255,0.95); 
    padding: 30px; 
    border-radius: 20px; 
    box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
    max-width: 1200px; 
    width: 100%; 
}

#board { 
    display: grid; 
    grid-template-columns: repeat(10, 1fr); 
    grid-template-rows: repeat(10, 1fr); 
    border: 4px solid #333; 
    border-radius: 15px; 
    margin: 0 auto 20px; 
    width: 100%; 
    max-width: 700px; 
    aspect-ratio: 1; 
    background: #fff; 
    box-shadow: inset 0 0 20px rgba(0,0,0,0.1); 
    overflow: hidden; 
}

.square { 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    border: 1px solid rgba(0,0,0,0.1); 
    background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%); 
    font-weight: bold; 
    font-size: 0.9em; 
    color: #333; 
    position: relative; 
    transition: all 0.3s ease; 
}

.square:hover { 
    transform: scale(1.05); 
    z-index: 5; 
}

.snake { 
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); 
    color: white; 
}

.snake::before { 
    content: 'üêç'; 
    position: absolute; 
    font-size: 3em; 
    opacity: 0.3; 
}

.snake::after { 
    content: attr(data-destination); 
    position: absolute; 
    bottom: 2px; 
    right: 2px; 
    background: rgba(0,0,0,0.7); 
    color: white; 
    font-size: 0.7em; 
    padding: 2px 5px; 
    border-radius: 5px; 
    font-weight: bold; 
}

.ladder { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    color: white; 
}

.ladder::before { 
    content: 'ü™ú'; 
    position: absolute; 
    font-size: 3em; 
    opacity: 0.3; 
}

.ladder::after { 
    content: attr(data-destination); 
    position: absolute; 
    top: 2px; 
    right: 2px; 
    background: rgba(0,0,0,0.7); 
    color: white; 
    font-size: 0.7em; 
    padding: 2px 5px; 
    border-radius: 5px; 
    font-weight: bold; 
}

.player { 
    width: 30px; 
    height: 30px; 
    background: radial-gradient(circle, #4dabf7 0%, #1864ab 100%); 
    border-radius: 50%; 
    position: absolute; 
    z-index: 10; 
    box-shadow: 0 4px 8px rgba(0,0,0,0.3); 
    animation: pulse 1s ease-in-out infinite; 
    border: 3px solid white; 
}

@keyframes pulse { 
    0%, 100% { transform: scale(1); } 
    50% { transform: scale(1.1); } 
}

#controls { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 15px; 
    margin-bottom: 20px; 
}

button { 
    padding: 15px 40px; 
    font-size: 20px; 
    font-weight: bold; 
    cursor: pointer; 
    color: white; 
    border: none; 
    border-radius: 50px; 
    transition: all 0.3s ease; 
    text-transform: uppercase; 
    letter-spacing: 1px; 
}

#startButton { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    box-shadow: 0 8px 20px rgba(81,207,102,0.4); 
}

#startButton:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 12px 25px rgba(81,207,102,0.5); 
}

#rollDice { 
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
    box-shadow: 0 8px 20px rgba(79,172,254,0.4); 
}

#rollDice:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 12px 25px rgba(79,172,254,0.5); 
}

button:disabled { 
    background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); 
    cursor: not-allowed; 
    box-shadow: none; 
}

#diceResult { 
    font-size: 28px; 
    font-weight: bold; 
    padding: 15px 30px; 
    background: linear-gradient(135deg, #ffd93d 0%, #ffbc00 100%); 
    border-radius: 15px; 
    color: #333; 
    box-shadow: 0 4px 15px rgba(255,188,0,0.3); 
    min-width: 150px; 
    text-align: center; 
}

#instructions { 
    margin-top: 20px; 
    font-size: 18px; 
    text-align: left; 
    min-height: 80px; 
    padding: 50px 80px; 
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); 
    border-radius: 15px; 
    color: #333; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.1); 
    display: none; 
    line-height: 1.8; 
    max-width: 900px; 
    margin-left: auto; 
    margin-right: auto; 
}

#instructions.active { 
    display: block; 
}

#instructions img { 
    margin: 40px 0; 
    max-width: 100%; 
    height: auto; 
    border-radius: 10px; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.2); 
}

#instructions p { 
    margin: 25px 0; 
    font-size: 17px; 
    line-height: 2; 
}

#instructions strong { 
    font-size: 26px; 
    display: block; 
    margin-bottom: 20px; 
    text-align: center; 
    color: #667eea; 
}

#continueButton { 
    margin-top: 15px; 
    padding: 12px 30px; 
    font-size: 18px; 
    background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); 
    box-shadow: 0 6px 20px rgba(250,82,82,0.4); 
    display: block; 
    margin-left: auto; 
    margin-right: auto; 
}

#continueButton:hover { 
    transform: translateY(-2px); 
    box-shadow: 0 8px 25px rgba(250,82,82,0.5); 
}

#buttoncontainer { 
    margin-top: 20px; 
    display: flex; 
    gap: 15px; 
    justify-content: center; 
    flex-wrap: wrap; 
    width: 100%; 
}

.settings-column-left, .settings-column-right { 
    width: 100%; 
    max-width: 900px; 
}

.settings-column-left {
    margin-bottom: 400px;
}

@media (min-width: 900px) {
    #buttoncontainer { 
        max-width: 1200px; 
        margin-left: auto; 
        margin-right: auto; 
        flex-wrap: nowrap; 
    }
    .settings-column-left { 
        width: 50%; 
        max-width: none; 
    }
    .settings-column-right { 
        width: 50%; 
        max-width: none; 
    }
}

.prize-settings { 
    margin-top: 0px; 
    padding: 20px; 
    background: white; 
    border-radius: 15px; 
    border: 2px solid #667eea; 
}

.prize-settings h3 { 
    color: #667eea; 
    margin-bottom: 15px; 
    text-align: center; 
    display: none;
}

.slider-container { 
    margin: 15px 0; 
}

.slider-label { 
    display: flex; 
    justify-content: space-between; 
    margin-bottom: 5px; 
    color: #333; 
    font-weight: bold; 
}

.slider-label .percentage { 
    color: #667eea; 
}

input[type="range"] { 
    width: 100%; 
    height: 8px; 
    border-radius: 5px; 
    outline: none; 
    -webkit-appearance: none; 
}

input[type="range"]::-webkit-slider-thumb { 
    -webkit-appearance: none; 
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #667eea; 
    cursor: pointer; 
}

input[type="range"]::-moz-range-thumb { 
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #667eea; 
    cursor: pointer; 
}

#minorSlider { 
    background: linear-gradient(to right, #51cf66, #37b24d); 
}

#majorSlider { 
    background: linear-gradient(to right, #ffd93d, #ffbc00); 
}

#noPrizeSlider { 
    background: linear-gradient(to right, #adb5bd, #868e96); 
}

#gesturesSlider {
    background: linear-gradient(to right, #748ffc, #5c7cfa);
}

#vibraniumSlider {
    background: linear-gradient(to right, #a78bfa, #8b5cf6);
}

#analyseSlider {
    background: linear-gradient(to right, #f59f0b, #d97706);
}

.toy-library-item { 
    border: 2px solid #e9ecef; 
    border-radius: 10px; 
    padding: 8px; 
    margin-bottom: 8px; 
    transition: all 0.3s ease; 
}

.toy-library-item:hover { 
    border-color: #667eea; 
    box-shadow: 0 4px 12px rgba(102,126,234,0.2); 
}

.toy-header { 
    display: flex; 
    align-items: center; 
    gap: 10px; 
    font-size: 1em; 
    font-weight: bold; 
    color: #333; 
    margin-bottom: 6px; 
}

.toy-checkbox-wrapper { 
    display: flex; 
    align-items: center; 
}

.toy-checkbox-wrapper input[type="checkbox"] { 
    width: 18px; 
    height: 18px; 
    margin: 0; 
    cursor: pointer; 
    accent-color: #51cf66; 
}

.toy-name { 
    flex: 1; 
}

.toy-controls { 
    display: flex; 
    gap: 8px; 
    align-items: center; 
    flex-wrap: wrap; 
    margin-left: 28px; 
    margin-bottom: 6px; 
}

.toy-controls label { 
    font-size: 0.85em; 
    color: #333; 
    font-weight: 600; 
}

.toy-controls input[type="number"] { 
    width: 55px; 
    padding: 4px; 
    border: 2px solid #667eea; 
    border-radius: 6px; 
    text-align: center; 
}

.set-difficulty { 
    margin-left: 28px; 
    padding: 6px; 
    background: #f8f9fa; 
    border-radius: 6px; 
    margin-top: 6px; 
}

.toy-controls input[type="number"]:disabled { 
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.difficulty-row select:disabled {
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.advanced-settings input:disabled {
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.set-difficulty input[type="checkbox"]:disabled {
    opacity: 0.5;
    cursor: default;
}

.set-difficulty input[type="checkbox"]:disabled + span,
.set-difficulty-item:has(input[type="checkbox"]:disabled) {
    opacity: 0.5;
}

.set-difficulty-item { 
    padding: 4px 0; 
    border-bottom: 1px solid #e9ecef; 
}

.set-difficulty-item:last-child { 
    border-bottom: none; 
}

.difficulty-row { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
}

.difficulty-row > span { 
    font-weight: 600; 
    color: #495057; 
    font-size: 0.9em; 
}

.difficulty-controls { 
    display: flex; 
    gap: 8px; 
    align-items: center; 
}

.difficulty-row select { 
    padding: 3px 6px; 
    border: 2px solid #667eea; 
    border-radius: 4px; 
    background: white; 
    color: #333; 
    cursor: pointer; 
    font-size: 0.9em; 
}

.gear-btn { 
    background: #667eea; 
    color: white; 
    border: none; 
    width: 24px; 
    height: 24px; 
    border-radius: 6px; 
    cursor: pointer; 
    font-size: 12px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    transition: background 0.2s ease; 
}

.gear-btn:hover { 
    background: #5568d3; 
}

.gear-btn.active { 
    background: #51cf66; 
}

.gear-btn:disabled { 
    background: #adb5bd; 
    cursor: default; 
    opacity: 0.5; 
}

.gear-btn:disabled:hover { 
    background: #adb5bd; 
}

.advanced-settings { 
    margin-left: 20px; 
    padding: 6px 10px; 
    background: white; 
    border-radius: 4px; 
    border-left: 3px solid #667eea; 
    font-size: 0.8em; 
    color: #666; 
    display: none; 
    gap: 12px; 
    margin-top: 6px; 
}

.advanced-settings.visible { 
    display: flex; 
}

.advanced-settings label { 
    display: flex; 
    align-items: center; 
    gap: 4px; 
}

.advanced-settings input { 
    width: 45px; 
    padding: 2px 4px; 
    border: 1px solid #dee2e6; 
    border-radius: 3px; 
    text-align: center; 
}

#toyLibraryContainer { 
    background: white; 
    border-radius: 10px; 
    padding: 15px; 
    color: #333;
}

.metronome-container { 
    margin: 20px 0; 
    padding: 20px; 
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
    border-radius: 15px; 
    box-shadow: 0 4px 15px rgba(79,172,254,0.3); 
}

.metronome-display { 
    font-size: 48px; 
    font-weight: bold; 
    color: white; 
    text-align: center; 
    margin: 15px 0; 
    min-height: 60px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
}

.metronome-beat { 
    width: 80px; 
    height: 80px; 
    border-radius: 50%; 
    background: rgba(255,255,255,0.3); 
    margin: 0 auto; 
    transition: all 0.1s ease; 
}

.metronome-beat.active { 
    background: white; 
    transform: scale(1.2); 
    box-shadow: 0 0 20px rgba(255,255,255,0.8); 
}

.metronome-btn { 
    padding: 12px 30px; 
    font-size: 18px; 
    background: white; 
    color: #4facfe; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
    margin: 10px auto; 
    display: block; 
}

.metronome-btn:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 6px 20px rgba(0,0,0,0.3); 
}

.metronome-btn:disabled { 
    opacity: 0.5; 
}

.modal { 
    display: none; 
    position: fixed; 
    z-index: 2000; 
    left: 0; 
    top: 0; 
    width: 100%; 
    height: 100%; 
    background-color: rgba(0,0,0,0.7); 
    backdrop-filter: blur(5px); 
    padding-top: 60px; 
}

.modal-content { 
    background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); 
    margin: 5% auto; 
    padding: 30px; 
    width: 80%; 
    max-width: 600px; 
    border-radius: 20px; 
    box-shadow: 0 20px 60px rgba(0,0,0,0.4); 
    color: #333; 
}

.modal-content h2 { 
    color: #667eea; 
    margin-bottom: 20px; 
}

.modal-content p { 
    line-height: 1.8; 
    margin-bottom: 15px; 
}

.close-btn { 
    color: #aaa; 
    float: right; 
    font-size: 32px; 
    font-weight: bold; 
    cursor: pointer; 
    transition: all 0.3s ease; 
}

.close-btn:hover { 
    color: #667eea; 
    transform: rotate(90deg); 
}

#patchNotesBtn, #resetBtn { 
    position: fixed; 
    top: 20px; 
    padding: 10px 20px; 
    font-size: 14px; 
    font-weight: 600; 
    z-index: 10; 
}

#patchNotesBtn { 
    right: 20px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    box-shadow: 0 4px 15px rgba(102,126,234,0.4); 
}

#resetBtn { 
    left: 20px; 
    background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); 
    box-shadow: 0 4px 15px rgba(250,82,82,0.4); 
}

.prize-result { 
    font-size: 2em; 
    text-align: center; 
    margin: 20px 0; 
    padding: 30px; 
    border-radius: 15px; 
    animation: prizeReveal 0.5s ease-out; 
}

@keyframes prizeReveal { 
    0% { transform: scale(0); opacity: 0; } 
    50% { transform: scale(1.2); } 
    100% { transform: scale(1); opacity: 1; } 
}

.prize-minor { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    color: white; 
}

.prize-major { 
    background: linear-gradient(135deg, #ffd93d 0%, #ffbc00 100%); 
    color: #333; 
}

.prize-none { 
    background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); 
    color: white; 
}

.instruction-set-selector { 
    background: white; 
    border-radius: 10px; 
    padding: 15px; 
    border: 2px solid #667eea; 
    margin-bottom: 15px; 
}

.instruction-set-selector label { 
    display: block; 
    padding: 8px; 
    cursor: pointer; 
    color: #333; 
}

.instruction-set-selector input[type="checkbox"] { 
    margin-right: 10px; 
    width: 18px; 
    height: 18px; 
    accent-color: #667eea; 
}

@media (max-width: 600px) { 
    h1 { 
        font-size: 2em; 
    } 
    #gameContainer { 
        padding: 20px; 
    } 
    .square { 
        font-size: 0.7em; 
    } 
    .player { 
        width: 20px; 
        height: 20px; 
    } 
}
    </style>
</head>
<body>
    <h1>üé≤ Snakes and Ladders üé≤</h1>
    <div id="gameContainer">
        <div id="board"></div>
        <div id="controls">
            <button id="startButton">üéÆ Start Game</button>
            <button id="rollDice" style="display: none;">üé≤ Roll Dice</button>
            <div style="display: flex; gap: 10px; align-items: center;">
                <label style="font-size: 14px; color: #333;">Test Jump:</label>
                <input type="number" id="testJumpInput" min="1" max="100" placeholder="Square" 
                       style="width: 80px; padding: 8px; border: 2px solid #667eea; border-radius: 8px; font-size: 14px;">
                <button id="testJumpButton" style="padding: 8px 15px; background: #f39c12; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    Jump
                </button>
            </div>
            <div style="display: flex; gap: 15px; align-items: center;">
                <div id="diceResult" style="display: none;">Dice: -</div>
                <div id="turnCounter" style="display: none; font-size: 20px; font-weight: bold; padding: 12px 25px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; color: white; box-shadow: 0 4px 15px rgba(102,126,234,0.3);">Turn: 0</div>
            </div>
        </div>
        <div id="instructions"></div>
        <div id="buttoncontainer">
            <div class="settings-column-left">
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üë§ Player Name:</label>
                <input type="text" id="playerNameInput" placeholder="Enter your name" style="width: 100%; padding: 12px; border: 2px solid #667eea; border-radius: 10px; font-size: 16px; margin-bottom: 15px; box-sizing: border-box;">
                
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üì¶ Select Instruction Sets:</label>
                <div id="instructionSetCheckboxes" class="instruction-set-selector">
                    <label><input type="checkbox" value="apple"> Analyse Set üçé</label>
                    <label><input type="checkbox" value="digging"> Deepthread Set ‚õèÔ∏è</label>
                    <label><input type="checkbox" value="dressup"> Pinplay Set üé®</label>
                    <label><input type="checkbox" value="tnd"> TnD üéØ</label>
                </div>

                <label style="display: block; font-weight: bold; color: #333; margin-top: 15px; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üéÆ Select Toys:</label>
                <div id="toyLibraryContainer"></div>
            </div>
            
            <div class="settings-column-right">
                <!-- Final Challenges Section -->
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üèÜ Final Challenges:</label>
                <div class="prize-settings">
                    <h3>üèÜ Final Challenges</h3>
                    <p style="color: #666; font-size: 14px; margin-bottom: 15px;">Set probabilities for each final challenge type. These are separate from the main game toys.</p>
                    
                    <div class="slider-container">
                        <div class="slider-label"><span>ü§≤ Gestures:</span><span class="percentage" id="gesturesPercent">33%</span></div>
                        <input type="range" id="gesturesSlider" min="0" max="100" value="33">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>üíé Vibranium:</span><span class="percentage" id="vibraniumPercent">33%</span></div>
                        <input type="range" id="vibraniumSlider" min="0" max="100" value="33">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>üîç Analyse:</span><span class="percentage" id="analysePercent">34%</span></div>
                        <input type="range" id="analyseSlider" min="0" max="100" value="34">
                    </div>
                    
                    <!-- Challenge Types -->
                    <div style="margin-top: 25px; padding-top: 20px; border-top: 2px solid #e9ecef;">
                        <h4 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">Challenge Types & Difficulty:</h4>
                        
                        <!-- Gestures -->
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div style="font-weight: 600; color: #5c7cfa;">ü§≤ Gestures:</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 12px; color: #666;">Difficulty:</span>
                                    <select id="gesturesDifficulty" style="padding: 4px 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px; cursor: pointer; background: white;">
                                        <option value="easy">Easy</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="gestures_ihot" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">I-Hot</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="gestures_icewater" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">Ice Water</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="gestures_spikeyband" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">Spikeyband</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="gestures_squeezing" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">Squeezing</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="gestures_2finger" style="width: 16px; height: 16px; cursor: pointer; accent-color: #5c7cfa;">
                                    <span style="color: #495057; font-size: 14px;">2 Finger</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Vibranium -->
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div style="font-weight: 600; color: #8b5cf6;">üíé Vibranium:</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 12px; color: #666;">Difficulty:</span>
                                    <select id="vibraniumDifficulty" style="padding: 4px 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px; cursor: pointer; background: white;">
                                        <option value="easy">Easy</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="vibranium_ihot" style="width: 16px; height: 16px; cursor: pointer; accent-color: #8b5cf6;">
                                    <span style="color: #495057; font-size: 14px;">I-Hot</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="vibranium_icewater" style="width: 16px; height: 16px; cursor: pointer; accent-color: #8b5cf6;">
                                    <span style="color: #495057; font-size: 14px;">Ice Water</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Analyse -->
                        <div style="margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div style="font-weight: 600; color: #d97706;">üîç Analyse:</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="font-size: 12px; color: #666;">Difficulty:</span>
                                    <select id="analyseDifficulty" style="padding: 4px 8px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 13px; cursor: pointer; background: white;">
                                        <option value="easy">Easy</option>
                                        <option value="medium" selected>Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                </div>
                            </div>
                            <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="analyse_vibranium" style="width: 16px; height: 16px; cursor: pointer; accent-color: #d97706;">
                                    <span style="color: #495057; font-size: 14px;">Vibranium</span>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Modifiers -->
                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #e9ecef;">
                            <div style="font-weight: 600; color: #333; margin-bottom: 8px;">üé≤ Modifiers (chance-based):</div>
                            <div style="margin-left: 20px; display: flex; flex-direction: column; gap: 6px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="modifier_ce" style="width: 16px; height: 16px; cursor: pointer; accent-color: #667eea;">
                                    <span style="color: #495057; font-size: 14px;">CE (Cum Eating)</span>
                                </label>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="modifier_pf" style="width: 16px; height: 16px; cursor: pointer; accent-color: #667eea;">
                                    <span style="color: #495057; font-size: 14px;">PF (Post Finish)</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px; margin-top: 20px;">üéÅ Prize Probabilities:</label>
                <div class="prize-settings">
                    <h3>üéÅ Prize Probabilities</h3>
                    <div class="slider-container">
                        <div class="slider-label"><span>üèÜ Major:</span><span class="percentage" id="majorPercent">33%</span></div>
                        <input type="range" id="majorSlider" min="0" max="100" value="33">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>üéâ Minor:</span><span class="percentage" id="minorPercent">33%</span></div>
                        <input type="range" id="minorSlider" min="0" max="100" value="33">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>‚ùå None:</span><span class="percentage" id="noPrizePercent">34%</span></div>
                        <input type="range" id="noPrizeSlider" min="0" max="100" value="34">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <button id="resetBtn">üîÑ Reset</button>
    <button id="patchNotesBtn">üìã Notes</button>
    
    <div id="patchNotesModal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>üìã Patch Notes</h2>
            <p><strong>Ver 0.5:</strong> Modifier system with add/remove chances & toy quantities</p>
        </div>
    </div>
    
    <div id="resetModal" class="modal">
        <div class="modal-content">
            <h2>‚ö†Ô∏è Reset Game?</h2>
            <p style="font-size: 18px; margin: 20px 0;">You will lose all progress!</p>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                <button id="confirmReset" style="padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold;">Yes</button>
                <button id="cancelReset" style="padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold;">Cancel</button>
            </div>
        </div>
    </div>
    
    <script>
// DOM Elements
const board = document.getElementById('board');
const diceResult = document.getElementById('diceResult');
const turnCounter = document.getElementById('turnCounter');
const instructions = document.getElementById('instructions');
const startButton = document.getElementById('startButton');
const rollDiceButton = document.getElementById('rollDice');
const continueButton = document.createElement('button');
continueButton.id = "continueButton";
continueButton.textContent = "‚úì Complete";

// Game Constants
const boardSize = 10;
const totalSquares = 100;
const player = document.createElement('div');
player.classList.add('player');

const snakes = {16:6, 47:26, 49:11, 56:53, 62:19, 64:60, 87:24, 93:73, 95:75, 98:78};
const ladders = {1:38, 4:14, 9:31, 21:42, 28:84, 36:44, 51:67, 71:91, 80:99};

// Game State
let audioContext = null;
let currentMetronomeTask = null;
let toyDifficulties = {};
let gameStarted = false;
let playerPosition = 0;
let turnCount = 0;
let turnCountBySet = {}; // Track turns per set (e.g., {dressup: 5, tnd: 3})
let turnCountByToy = {}; // Track turns per set-toy combo (e.g., {dressup_stickers: 3, tnd_prison: 2})
let lastSelectedSet = {}; // Track which set each toy was last selected from (e.g., {stickers: 'dressup', prison: 'tnd'})
let selectedSets = [];
let prizeSettings = {major: 33, minor: 33, noPrize: 34};
let toyQuantities = {};
let toyModifiers = {};
let playerName = '';
let toySetEnabled = {};
let toyChecked = {};

// Prison-specific state (always available, not tied to TnD selection)
let prisonLocked = false;
let prisonWorn = false;

// Final challenge state
let finalChallengeSettings = {
    gestures: 33,
    vibranium: 33,
    analyse: 34
};

// Final challenge types enabled
let finalChallengeTypes = {
    gestures_ihot: false,
    gestures_icewater: false,
    gestures_spikeyband: false,
    gestures_squeezing: false,
    gestures_2finger: false,
    vibranium_ihot: false,
    vibranium_icewater: false,
    analyse_vibranium: false
};

// Final challenge difficulties
let finalChallengeDifficulties = {
    gestures: 'medium',
    vibranium: 'medium',
    analyse: 'medium'
};

// Final challenge modifiers
let finalChallengeModifiers = {
    ce: false,
    pf: false
};

// Body part capacity system
const bodyParts = {
    Mo: { name: "Mo", items: [] },
    Ba: { name: "Ba", items: [] },
    Bu: { name: "Bu", items: [] },
    As: { name: "As", items: [] },
    Ni: { name: "Ni", items: [] },
    Ha: { name: "Ha", items: [] },
    Bo: { name: "Bo", items: [] },
    Pe: { name: "Pe", items: [] }
};

// Clothestickers max count per body part
const clothestickersMaxCount = {
    'Ba': 20,
    'Ni': 2,
    'Mo': 3,
    'Bu': 1,
    'As': 1,
    'Ha': 1,
    'Bo': 1,
    'Pe': 1
};

// List of toys that can be worn/held on body parts
const wearableToys = new Set(['stickers', 'silly_shirt', 'stick_a', 'stick_m', 'metal_stick', 'tail', 'prison', 'hand', 'vibranium']);

function isToyWearable(toyId) {
    return wearableToys.has(toyId);
}

function isBodyPartEmpty(bodyPart) {
    return bodyPartState[bodyPart].items.length === 0;
}

function hasClothestickers(bodyPart) {
    return bodyPartState[bodyPart].items.some(item => item === 'stickers');
}

function hasRegularToys(bodyPart) {
    return bodyPartState[bodyPart].items.some(item => item !== 'stickers');
}

function getClothestickerCount(bodyPart) {
    return bodyPartState[bodyPart].items.filter(item => item === 'stickers').length;
}

function getClothestickerMax(bodyPart) {
    return clothestickersMaxCount[bodyPart] || 1;
}

let bodyPartState = JSON.parse(JSON.stringify(bodyParts));

function getTaskConditions() {
    return {
        // Player info
        name: playerName || 'Player',
        playerPosition: playerPosition,
        turnCount: turnCount,
        
        // Turn count tracking
        getTurnCountForSet: (setId) => turnCountBySet[setId] || 0,
        getTurnCountForToy: (toyKey) => turnCountByToy[toyKey] || 0,
        getLastSelectedSet: (toyId) => lastSelectedSet[toyId] || null,
        
        // Prison state
        prisonLocked: prisonLocked,
        
        // Selected sets
        selectedSets: selectedSets,
        hasSet: (setId) => selectedSets.includes(setId),
        
        // Toy availability checks
        toyChecked: (toyId) => toyChecked[toyId] === true,
        toySetEnabled: (toyKey) => toySetEnabled[toyKey] === true,
        toyQuantity: (toyKey) => toyQuantities[toyKey] || 0,
        
        // Toy holding checks
        isHolding: (toyId) => {
            for (const part of Object.values(bodyPartState)) {
                if (part.items.includes(toyId)) return true;
            }
            return false;
        },
        
        // Get all body parts holding a specific toy
        getBodyPartsHolding: (toyId) => {
            const parts = [];
            for (const [partKey, part] of Object.entries(bodyPartState)) {
                if (part.items.includes(toyId)) {
                    parts.push({ key: partKey, name: part.name });
                }
            }
            return parts;
        },
        
        // Count toys
        countToy: (toyId) => {
            let count = 0;
            for (const part of Object.values(bodyPartState)) {
                count += part.items.filter(item => item === toyId).length;
            }
            return count;
        },
        
        countToyInBodyPart: (toyId, bodyPart) => {
            return bodyPartState[bodyPart].items.filter(item => item === toyId).length;
        },
        
        // Body part checks
        getBodyPart: (bodyPartKey) => {
            return bodyPartState[bodyPartKey];
        },
        
        bodyPartEmpty: (bodyPartKey) => {
            return isBodyPartEmpty(bodyPartKey);
        },
        
        bodyPartHas: (bodyPartKey, toyId) => {
            return bodyPartState[bodyPartKey].items.includes(toyId);
        },
        
        bodyPartHasRegularToys: (bodyPartKey) => {
            return hasRegularToys(bodyPartKey);
        },
        
        bodyPartHasClothestickers: (bodyPartKey) => {
            return hasClothestickers(bodyPartKey);
        },
        
        isBodyPartOccupied: (bodyPartKey) => {
            return bodyPartState[bodyPartKey] && !isBodyPartEmpty(bodyPartKey);
        },
        
        canBodyPartHold: (bodyPartKey, toyId) => {
            return canAddToyToBodyPart(bodyPartKey, toyId);
        },
        
        // Multiple toy checks
        hasMultiple: (toyIds) => {
            return toyIds.every(toyId => {
                for (const part of Object.values(bodyPartState)) {
                    if (part.items.includes(toyId)) return true;
                }
                return false;
            });
        },
        
        hasAny: (toyIds) => {
            return toyIds.some(toyId => {
                for (const part of Object.values(bodyPartState)) {
                    if (part.items.includes(toyId)) return true;
                }
                return false;
            });
        },
        
        // Get all held items
        getAllHeldItems: () => {
            const items = [];
            for (const part of Object.values(bodyPartState)) {
                items.push(...part.items);
            }
            return items;
        },
        
        // Get full body part state
        getBodyPartState: () => bodyPartState,
        
        // Utility
        randomChance: (percent) => {
            return Math.random() * 100 < percent;
        }
    };
}

// Helper function to get difficulty value based on difficulty setting
function getDifficultyValue(difficulty, easyVal, mediumVal, hardVal) {
    if (difficulty === 'easy') return easyVal;
    if (difficulty === 'medium') return mediumVal;
    if (difficulty === 'hard') return hardVal;
    return mediumVal; // default
}

// Instruction Sets
const instructionSets = {
    dressup: {
        name: "Pinplay Set",
        toys: [
            {id: "stickers", name: "Clothestickers üé®"},
            {id: "silly_shirt", name: "Clampshirt üëï"},
            {id: "wristband", name: "Spikeyband ‚åö"},
            {id: "hand", name: "Hand ‚úã"},
            {id: "vibranium", name: "Vibranium üíé"}
        ],
        tasks: {
            stickers: [
                {
                    // STANDARD TASK: Apply clothestickers
                    // Difficulty: Easy=3, Medium=5, Hard=8 clothestickers
                    // No conditions - always available
                    getDifficulty: d => `<strong>Clothesticker Challenge</strong><p>Apply ${d=='easy'?3:d=='medium'?5:8} clothestickers to yourself.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard clothesticker task. Difficulty: Easy=3, Medium=5, Hard=8 stickers.</em></p><img src="https://picsum.photos/seed/sticker1/800/600"/>`
                },
                {
                    // ADD TASK: Add clothestickers to Ba
                    // Difficulty: Easy=3, Medium=5, Hard=8 clothestickers
                    type: 'add', 
                    bodyPart: 'Ba', 
                    quantity: d => d=='easy'?3:d=='medium'?5:8
                },
                {
                    // REMOVE TASK: Remove clothestickers from Ba
                    // Difficulty: Easy=3, Medium=5, Hard=8 clothestickers
                    type: 'remove', 
                    bodyPart: 'Ba', 
                    quantity: d => d=='easy'?3:d=='medium'?5:8
                }
            ],
            silly_shirt: [
                {
                    // DYNAMIC TASK: Multi-toy task with conditions
                    // CONDITIONS:
                    //   - Only available if: Analyse set is selected OR Ba has clothestickers
                    // DYNAMIC BEHAVIOR:
                    //   - If wearing clampshirt: asks to spin (uses clampshirt difficulty: Easy=5s, Medium=10s, Hard=15s)
                    //   - If not wearing: asks to put it on
                    //   - Adds special comment if Analyse set is active
                    //   - If Ba can hold more stickers: adds requirement to add clothestickers (uses sticker difficulty: Easy=3, Medium=5, Hard=8)
                    //   - Comments on existing clothesticker count in Ba (0, <5, <15, 15+)
                    canSelect: (c) => {
                        return c.hasSet('apple') || c.countToyInBodyPart('stickers', 'Ba') > 0;
                    },
                    getDifficulty: (primaryDifficulty, c, diffMap) => {
                        let html = '<strong>Clampshirt Task</strong><p>';
                        
                        const shirtDiff = diffMap['silly_shirt'] || 'medium';
                        const stickerDiff = diffMap['stickers'] || 'medium';
                        
                        if (c.bodyPartHas('Ni', 'silly_shirt')) {
                            const spinTime = getDifficultyValue(shirtDiff, 5, 10, 15);
                            html += `Spin around with the clampshirt on for ${spinTime} seconds!`;
                        } else {
                            html += 'Put on the clampshirt';
                            if (c.hasSet('apple')) {
                                html += ' (the Analyse set appreciates fashion)';
                            }
                            html += '.';
                        }
                        
                        const baStickers = c.countToyInBodyPart('stickers', 'Ba');
                        const stickerCount = getDifficultyValue(stickerDiff, 3, 5, 8);
                        
                        if (c.canBodyPartHold('Ba', 'stickers')) {
                            html += `<br><br>Also add ${stickerCount} clothestickers to Ba.`;
                        }
                        
                        if (baStickers > 0) {
                            html += '<br><br><em>';
                            if (baStickers < 5) {
                                html += "Just a few clothestickers... not bad.";
                            } else if (baStickers < 15) {
                                html += "That's quite a few clothestickers!";
                            } else {
                                html += "Wow! So many clothestickers!";
                            }
                            html += '</em>';
                        }
                        
                        html += '</p>';
                        html += '<p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Dynamic multi-toy task. ';
                        html += 'Condition: Only appears if Analyse set selected OR Ba has clothestickers. ';
                        html += 'Clampshirt difficulty (Easy=5s, Med=10s, Hard=15s). ';
                        html += 'Clothesticker difficulty (Easy=3, Med=5, Hard=8). ';
                        html += 'Changes based on: wearing shirt, Analyse set active, Ba sticker count, if Ba can hold more.</em></p>';
                        html += '<img src="https://picsum.photos/seed/shirt1/800/600"/>';
                        return html;
                    }
                },
                {
                    // ADD TASK: Put on clampshirt to Ni
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Ni'
                },
                {
                    // REMOVE TASK: Take off clampshirt from Ni
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Ni'
                }
            ],
            wristband: [
                {
                    // STANDARD TASK: Spin spikeyband
                    // Difficulty: Easy=5, Medium=10, Hard=15 spins
                    // No conditions - always available
                    getDifficulty: d => `<strong>Spikeyband Spin</strong><p>Spin the spikeyband around your wrist ${d=='easy'?5:d=='medium'?10:15} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard spikeyband task. Difficulty: Easy=5, Medium=10, Hard=15 spins.</em></p><img src="https://picsum.photos/seed/wrist1/800/600"/>`
                }
            ],
            hand: [
                {
                    // STANDARD TASK: Wave hand
                    // Difficulty: Easy=10, Medium=15, Hard=20 waves
                    // No conditions - always available
                    getDifficulty: d => `<strong>Hand Wave</strong><p>Wave your hand ${d=='easy'?10:d=='medium'?15:20} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard hand wave task. Difficulty: Easy=10, Medium=15, Hard=20 waves.</em></p><img src="https://picsum.photos/seed/hand1/800/600"/>`
                },
                {
                    // RED LIGHT GREEN LIGHT TASK: Jump on green, stop on red
                    // Difficulty: Easy=15s, Medium=20s, Hard=25s duration
                    // No conditions - always available
                    type: 'redlight', 
                    getDifficulty: d => d=='easy'?15000:d=='medium'?20000:25000
                }
            ],
            vibranium: [
                {
                    // STANDARD TASK: Hold vibranium steady
                    // Difficulty: Easy=5, Medium=10, Hard=15 seconds
                    // No conditions - always available
                    getDifficulty: d => `<strong>Vibranium Hold</strong><p>Hold the vibranium steady for ${d=='easy'?5:d=='medium'?10:15} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard vibranium task. Difficulty: Easy=5s, Medium=10s, Hard=15s.</em></p><img src="https://picsum.photos/seed/vibranium1/800/600"/>`
                }
            ]
        }
    },
    apple: {
        name: "Analyse Set",
        toys: [
            {id: "stick_a", name: "Dillstick A ü™µ"},
            {id: "metal_stick", name: "Metal Dillstick üî©"},
            {id: "tail", name: "Plugtail ü¶ä"},
            {id: "vibranium", name: "Vibranium üíé"},
            {id: "prison", name: "Prison üîí"}
        ],
        tasks: {
            stick_a: [
                {
                    // STANDARD TASK: Balance dillstick A
                    // Difficulty: Easy=3, Medium=5, Hard=8 seconds
                    // No conditions - always available
                    getDifficulty: d => `<strong>Dillstick A Balance</strong><p>Balance the dillstick A on your hand for ${d=='easy'?3:d=='medium'?5:8} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard dillstick A task. Difficulty: Easy=3s, Medium=5s, Hard=8s.</em></p><img src="https://picsum.photos/seed/stick1/800/600"/>`
                },
                {
                    // ADD TASK: Add dillstick A to Bu
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Bu'
                },
                {
                    // REMOVE TASK: Remove dillstick A from Bu
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Bu'
                }
            ],
            metal_stick: [
                {
                    // STANDARD TASK: Tap metal dillstick
                    // Difficulty: Easy=10, Medium=15, Hard=20 taps
                    // No conditions - always available
                    getDifficulty: d => `<strong>Metal Dillstick Tap</strong><p>Tap the metal dillstick on the ground ${d=='easy'?10:d=='medium'?15:20} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard metal dillstick task. Difficulty: Easy=10, Medium=15, Hard=20 taps.</em></p><img src="https://picsum.photos/seed/metal1/800/600"/>`
                },
                {
                    // ADD TASK: Add metal dillstick to Bu
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Bu'
                },
                {
                    // REMOVE TASK: Remove metal dillstick from Bu
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Bu'
                }
            ],
            tail: [
                {
                    // STANDARD TASK: Wag plugtail
                    // Difficulty: Easy=5, Medium=10, Hard=15 wags
                    // No conditions - always available
                    getDifficulty: d => `<strong>Plugtail Wag</strong><p>Wag your plugtail ${d=='easy'?5:d=='medium'?10:15} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard plugtail task. Difficulty: Easy=5, Medium=10, Hard=15 wags.</em></p><img src="https://picsum.photos/seed/tail1/800/600"/>`
                },
                {
                    // ADD TASK: Add plugtail to Bu
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Bu'
                },
                {
                    // REMOVE TASK: Remove plugtail from Bu
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Bu'
                }
            ],
            vibranium: [
                {
                    // STANDARD TASK: Shake vibranium
                    // Difficulty: Easy=5, Medium=10, Hard=15 shakes
                    // No conditions - always available
                    getDifficulty: d => `<strong>Vibranium Shake</strong><p>Shake the vibranium ${d=='easy'?5:d=='medium'?10:15} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard vibranium shake task. Difficulty: Easy=5, Medium=10, Hard=15 shakes.</em></p><img src="https://picsum.photos/seed/vibranium2/800/600"/>`
                }
            ],
            prison: [
                {
                    // TASK: Inspect the prison
                    // DIFFICULTY: Easy=5sec, Medium=10sec, Hard=15sec
                    // CONDITIONS: None (always available)
                    getDifficulty: d => `<strong>Prison Inspection</strong><p>Carefully inspect the prison for ${d=='easy'?5:d=='medium'?10:15} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Analyse prison task. Difficulty: Easy=5s, Medium=10s, Hard=15s.</em></p><img src="https://picsum.photos/seed/prison2/800/600"/>`
                },
                {
                    // ADD TASK: Add prison to Pe
                    // Locked status affects whether this can be rolled
                    type: 'add', 
                    bodyPart: 'Pe'
                },
                {
                    // REMOVE TASK: Remove prison from Pe
                    // Locked status affects whether this can be rolled
                    type: 'remove', 
                    bodyPart: 'Pe'
                }
            ]
        }
    },
    digging: {
        name: "Deepthread Set",
        toys: [
            {id: "stick_m", name: "Dillstick M ü™µ"},
            {id: "hand", name: "Hand ‚úã"}
        ],
        tasks: {
            stick_m: [
                {
                    // STANDARD TASK: Dig with dillstick M
                    // Difficulty: Easy=3, Medium=5, Hard=8 digging motions
                    // No conditions - always available
                    getDifficulty: d => `<strong>Dig with Dillstick M</strong><p>Use the dillstick M to make ${d=='easy'?3:d=='medium'?5:8} digging motions.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard dillstick M task. Difficulty: Easy=3, Medium=5, Hard=8 motions.</em></p><img src="https://picsum.photos/seed/dig1/800/600"/>`
                },
                {
                    // ADD TASK: Add dillstick M to Mo
                    // No difficulty variation - always 1 item
                    type: 'add', 
                    bodyPart: 'Mo'
                },
                {
                    // REMOVE TASK: Remove dillstick M from Mo
                    // No difficulty variation - always 1 item
                    type: 'remove', 
                    bodyPart: 'Mo'
                }
            ],
            hand: [
                {
                    // STANDARD TASK: Hand digging motions
                    // Difficulty: Easy=10, Medium=15, Hard=20 motions
                    // No conditions - always available
                    getDifficulty: d => `<strong>Hand Digging</strong><p>Make digging motions with your hands ${d=='easy'?10:d=='medium'?15:20} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard hand digging task. Difficulty: Easy=10, Medium=15, Hard=20 motions.</em></p><img src="https://picsum.photos/seed/dighand1/800/600"/>`
                }
            ]
        }
    },
    tnd: {
        name: "TnD",
        toys: [
            {id: "vibranium", name: "Vibranium üíé"},
            {id: "hand", name: "Hand ‚úã"},
            {id: "prison", name: "Prison üîí"}
        ],
        tasks: {
            vibranium: [
                {
                    // STANDARD TASK: Control vibranium settings
                    // Difficulty: Easy=10, Medium=20, Hard=30 seconds
                    // No conditions - always available
                    getDifficulty: d => `<strong>Vibranium Control</strong><p>Control the vibranium settings for ${d=='easy'?10:d=='medium'?20:30} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard vibranium control task. Difficulty: Easy=10s, Medium=20s, Hard=30s.</em></p><img src="https://picsum.photos/seed/vibranium3/800/600"/>`
                }
            ],
            hand: [
                {
                    // STANDARD TASK: Hand gestures
                    // Difficulty: Easy=8, Medium=12, Hard=16 gestures
                    // No conditions - always available
                    getDifficulty: d => `<strong>Hand Gesture</strong><p>Make hand gestures ${d=='easy'?8:d=='medium'?12:16} times.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Standard hand gesture task. Difficulty: Easy=8, Medium=12, Hard=16 gestures.</em></p><img src="https://picsum.photos/seed/handtnd1/800/600"/>`
                }
            ],
            prison: [
                {
                    // SPECIAL ALWAYS TASK: Put on prison after 2 TnD hand tasks
                    // CONDITIONS: TnD selected, Prison can be worn on Pe, Rolled 2+ TnD hand tasks
                    // This task is "always" selected when conditions are met (overrides normal task selection)
                    alwaysSelect: (c) => {
                        // Check if we've rolled at least 2 TnD hand tasks
                        if (c.getTurnCountForToy('tnd_hand') < 2) return false;
                        // Check TnD is selected
                        if (!c.hasSet('tnd')) return false;
                        // Check if prison toy is checked
                        if (!c.toyChecked('prison')) return false;
                        // Check if Pe can hold prison
                        return c.canBodyPartHold('Pe', 'prison');
                    },
                    getDifficulty: (d, c, diffMap) => {
                        const handCount = c.getTurnCountForToy('tnd_hand');
                        return `<strong>üîí Special Prison Task!</strong><p>You've completed ${handCount} hand tasks from TnD. Time to put on the prison!</p><p>Place the prison on your Pe.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: ALWAYS task - only triggers after rolling 2+ TnD hand tasks if TnD selected, prison checked, and Pe can hold prison. This overrides normal task selection.</em></p><img src="https://picsum.photos/seed/prisonhand/800/600"/>`;
                    },
                    execute: function() {
                        // Add prison to Pe
                        return addToyToBodyPart('Pe', 'prison');
                    }
                },
                {
                    // TASK: Control prison settings
                    // DIFFICULTY: Easy=10sec, Medium=15sec, Hard=20sec
                    // CONDITIONS: None (always available)
                    getDifficulty: d => `<strong>Prison Control</strong><p>Adjust the prison settings for ${d=='easy'?10:d=='medium'?15:20} seconds.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: TnD prison task. Difficulty: Easy=10s, Medium=15s, Hard=20s.</em></p><img src="https://picsum.photos/seed/prison1/800/600"/>`
                },
                {
                    // ADD TASK: Add prison to Pe
                    // Locked status affects whether this can be rolled
                    type: 'add', 
                    bodyPart: 'Pe'
                },
                {
                    // REMOVE TASK: Remove prison from Pe
                    // Locked status affects whether this can be rolled
                    type: 'remove', 
                    bodyPart: 'Pe'
                }
            ]
        }
    }
};

// Snake and Ladder special tasks (at root level, not tied to a specific set)
const snakeLadderTasks = {
    snakeTasks: [
        {
            // SNAKE TASK: Conditional vibranium task
            // CONDITIONS: TnD selected AND vibranium available AND vibranium not currently held
            // DIFFICULTY: Easy=5sec, Medium=10sec, Hard=15sec
            canSelect: (c) => {
                // Check TnD is selected
                if (!c.hasSet('tnd')) return false;
                // Check if vibranium toy is checked/enabled
                if (!c.toyChecked('vibranium')) return false;
                // Check if any vibranium toy key is enabled (could be from TnD or other sets)
                const tndVibKey = 'tnd_vibranium';
                const hasVibranium = c.toySetEnabled(tndVibKey) && (c.toyQuantity(tndVibKey) > 0);
                if (!hasVibranium) return false;
                // Check if vibranium is free (not currently held on any body part)
                return !c.isHolding('vibranium');
            },
            getDifficulty: (d, c, diffMap, snakeLadderInfo) => {
                const vibDiff = diffMap['vibranium'] || 'medium';
                const seconds = getDifficultyValue(vibDiff, 5, 10, 15);
                return `<strong>Snake Slide! üêç</strong><p>You fell ${Math.abs(snakeLadderInfo.distance)} spaces from ${snakeLadderInfo.from} to ${snakeLadderInfo.to}!</p><p>Hold the vibranium steady for ${seconds} seconds to steady yourself.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: Conditional snake task with vibranium. Only appears if TnD selected, vibranium checked, tnd_vibranium enabled with quantity > 0, and vibranium is NOT currently being held. Difficulty: Easy=5s, Medium=10s, Hard=15s. Fall distance: ${Math.abs(snakeLadderInfo.distance)} spaces.</em></p><img src="https://picsum.photos/seed/snakevib/800/600"/>`;
            }
        },
        {
            // SNAKE TASK: Fallback task (always available)
            // CONDITIONS: None
            getDifficulty: (d, c, diffMap, snakeLadderInfo) => {
                return `<strong>Snake Slide! üêç</strong><p>You slid down ${Math.abs(snakeLadderInfo.distance)} spaces from ${snakeLadderInfo.from} to ${snakeLadderInfo.to}.</p><p>Take a moment to recover from the fall.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: FALLBACK snake task (no toys, no conditions). Always available when conditional tasks don't pass. Fall distance: ${Math.abs(snakeLadderInfo.distance)} spaces.</em></p><img src="https://picsum.photos/seed/snakefallback/800/600"/>`;
            }
        }
    ],
    ladderTasks: [
        {
            // LADDER TASK: Conditional hand task
            // CONDITIONS: TnD selected AND hand available AND Ha available
            // DIFFICULTY: Easy=8, Medium=12, Hard=16 gestures
            canSelect: (c) => {
                // Check TnD is selected
                if (!c.hasSet('tnd')) return false;
                // Check if hand toy is checked/enabled
                if (!c.toyChecked('hand')) return false;
                // Check if TnD hand is enabled with quantity > 0
                const tndHandKey = 'tnd_hand';
                const hasHand = c.toySetEnabled(tndHandKey) && (c.toyQuantity(tndHandKey) > 0);
                if (!hasHand) return false;
                // Check if Ha can hold hand
                return c.canBodyPartHold('Ha', 'hand');
            },
            getDifficulty: (d, c, diffMap, snakeLadderInfo) => {
                const handDiff = diffMap['hand'] || 'medium';
                const gestures = getDifficultyValue(handDiff, 8, 12, 16);
                return `<strong>Ladder Climb! ü™ú</strong><p>You climbed ${snakeLadderInfo.distance} spaces from ${snakeLadderInfo.from} to ${snakeLadderInfo.to}!</p><p>Make ${gestures} celebratory hand gestures for your climb.</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: CONDITIONAL ladder task with hand. Only appears if TnD selected, hand checked, tnd_hand enabled with quantity > 0, and Ha can hold it. Difficulty: Easy=8, Medium=12, Hard=16 gestures. Climb distance: ${snakeLadderInfo.distance} spaces.</em></p><img src="https://picsum.photos/seed/ladderhand/800/600"/>`;
            }
        },
        {
            // LADDER TASK: Fallback task (always available)
            // CONDITIONS: None
            getDifficulty: (d, c, diffMap, snakeLadderInfo) => {
                return `<strong>Ladder Climb! ü™ú</strong><p>You climbed ${snakeLadderInfo.distance} spaces from ${snakeLadderInfo.from} to ${snakeLadderInfo.to}!</p><p>Celebrate your good fortune!</p><p style="font-size: 0.85em; color: #666; margin-top: 10px;"><em>Testing: FALLBACK ladder task (no toys, no conditions). Always available when conditional tasks don't pass. Climb distance: ${snakeLadderInfo.distance} spaces.</em></p><img src="https://picsum.photos/seed/ladderfallback/800/600"/>`;
            }
        }
    ]
};

// Final Challenge Tasks
const finalChallengeTasks = [
    {
        // GESTURES TASK: Only if gestures challenges enabled
        canSelect: (c) => {
            return finalChallengeTypes.gestures_ihot || 
                   finalChallengeTypes.gestures_icewater || 
                   finalChallengeTypes.gestures_spikeyband || 
                   finalChallengeTypes.gestures_squeezing || 
                   finalChallengeTypes.gestures_2finger;
        },
        getDifficulty: (d, c, diffMap, prizeType) => {
            // Pick from enabled gestures challenges
            const enabledGestures = [];
            if (finalChallengeTypes.gestures_ihot) enabledGestures.push('I-Hot');
            if (finalChallengeTypes.gestures_icewater) enabledGestures.push('Ice Water');
            if (finalChallengeTypes.gestures_spikeyband) enabledGestures.push('Spikeyband');
            if (finalChallengeTypes.gestures_squeezing) enabledGestures.push('Squeezing');
            if (finalChallengeTypes.gestures_2finger) enabledGestures.push('2 Finger');
            
            const subtype = enabledGestures[Math.floor(Math.random() * enabledGestures.length)];
            const difficulty = finalChallengeDifficulties.gestures;
            const count = difficulty === 'easy' ? 8 : difficulty === 'hard' ? 16 : 12;
            
            return `
                <strong>üèÜ Final Challenge! üèÜ</strong>
                <p>Complete ${count} hand gestures with ${subtype} at ${difficulty} difficulty.</p>
                <button onclick="revealFinalPrize('gestures', '${prizeType}')" 
                        style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    I Completed the Challenge
                </button>
                <div id="prizeReveal_gestures" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    <!-- Prize will be revealed here -->
                </div>
                <img src="https://picsum.photos/seed/finalgestures/800/600"/>
            `;
        }
    },
    {
        // VIBRANIUM TASK: Only if vibranium challenges enabled
        canSelect: (c) => {
            return finalChallengeTypes.vibranium_ihot || finalChallengeTypes.vibranium_icewater;
        },
        getDifficulty: (d, c, diffMap, prizeType) => {
            // Pick from enabled vibranium challenges
            const enabledVibranium = [];
            if (finalChallengeTypes.vibranium_ihot) enabledVibranium.push('I-Hot');
            if (finalChallengeTypes.vibranium_icewater) enabledVibranium.push('Ice Water');
            
            const subtype = enabledVibranium[Math.floor(Math.random() * enabledVibranium.length)];
            const difficulty = finalChallengeDifficulties.vibranium;
            const seconds = difficulty === 'easy' ? 30 : difficulty === 'hard' ? 60 : 45;
            
            return `
                <strong>üèÜ Final Challenge! üèÜ</strong>
                <p>Hold vibranium with ${subtype} for ${seconds} seconds at ${difficulty} difficulty.</p>
                <button onclick="revealFinalPrize('vibranium', '${prizeType}')" 
                        style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    I Completed the Challenge
                </button>
                <div id="prizeReveal_vibranium" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    <!-- Prize will be revealed here -->
                </div>
                <img src="https://picsum.photos/seed/finalvibranium/800/600"/>
            `;
        }
    },
    {
        // ANALYSE TASK: Only if analyse challenges enabled
        canSelect: (c) => {
            return finalChallengeTypes.analyse_vibranium;
        },
        getDifficulty: (d, c, diffMap, prizeType) => {
            const difficulty = finalChallengeDifficulties.analyse;
            const count = difficulty === 'easy' ? 3 : difficulty === 'hard' ? 7 : 5;
            
            return `
                <strong>üèÜ Final Challenge! üèÜ</strong>
                <p>Analyse ${count} dillsticks with Vibranium at ${difficulty} difficulty.</p>
                <button onclick="revealFinalPrize('analyse', '${prizeType}')" 
                        style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    I Completed the Challenge
                </button>
                <div id="prizeReveal_analyse" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    <!-- Prize will be revealed here -->
                </div>
                <img src="https://picsum.photos/seed/finalanalyse/800/600"/>
            `;
        }
    },
    {
        // EXAMPLE: ALWAYS task - only triggers if specific condition met
        // This demonstrates how to add conditional "always" tasks
        alwaysSelect: (c) => {
            // Example: Only show this task if player completed 10+ turns
            // return c.turnCount >= 10;
            return false; // Disabled by default - set to true or add condition to enable
        },
        getDifficulty: (d, c, diffMap, prizeType) => {
            return `
                <strong>üèÜ Special Final Challenge! üèÜ</strong>
                <p>You've been selected for a special challenge based on your game progress!</p>
                <p>This is an example of an "always" task that only appears when specific conditions are met.</p>
                <button onclick="revealFinalPrize('special', '${prizeType}')" 
                        style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                    I Completed the Challenge
                </button>
                <div id="prizeReveal_special" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    <!-- Prize will be revealed here -->
                </div>
                <img src="https://picsum.photos/seed/finalspecial/800/600"/>
            `;
        }
    },
    {
        // FALLBACK TASK: Always available, no challenge
        getDifficulty: (d, c, diffMap, prizeType) => {
            // Immediately show prize with modifiers
            const prizeHTML = generatePrizeHTML(prizeType);
            
            return `
                <strong>üèÜ Final Challenge! üèÜ</strong>
                <p>Let's see what your prize is...</p>
                <div style="margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                    ${prizeHTML}
                </div>
                <img src="https://picsum.photos/seed/finalfallback/800/600"/>
            `;
        }
    }
];

// Generate prize HTML with modifiers
function generatePrizeHTML(prizeType) {
    let html = '<div style="text-align: center;">';
    html += '<div style="font-size: 24px; margin-bottom: 10px;">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>';
    html += '<div style="font-size: 20px; font-weight: 600; margin-bottom: 15px;">üéâ Prize Result üéâ</div>';
    
    if (prizeType === 'major') {
        html += '<div style="font-size: 28px; font-weight: bold; color: #ffd93d; margin-bottom: 10px;">üèÜ MAJOR PRIZE! üèÜ</div>';
        html += '<p style="font-size: 16px; margin-bottom: 15px;">Congratulations! You won big!</p>';
        
        // Add modifiers for Major (CE + PF if enabled)
        if (finalChallengeModifiers.ce) {
            html += '<div style="background: #fff3cd; padding: 10px; border-radius: 6px; margin-bottom: 10px; text-align: left;">';
            html += '<strong>ü•õ CE (Cum Eating):</strong> Complete the CE requirement.';
            html += '</div>';
        }
        if (finalChallengeModifiers.pf) {
            html += '<div style="background: #cfe2ff; padding: 10px; border-radius: 6px; margin-bottom: 10px; text-align: left;">';
            html += '<strong>‚è±Ô∏è PF (Post Finish):</strong> Complete the PF requirement.';
            html += '</div>';
        }
    } else if (prizeType === 'minor') {
        html += '<div style="font-size: 28px; font-weight: bold; color: #51cf66; margin-bottom: 10px;">üéâ Minor Prize üéâ</div>';
        html += '<p style="font-size: 16px; margin-bottom: 15px;">Not bad! You got a small reward.</p>';
        
        // Add modifiers for Minor (CE only if enabled)
        if (finalChallengeModifiers.ce) {
            html += '<div style="background: #fff3cd; padding: 10px; border-radius: 6px; margin-bottom: 10px; text-align: left;">';
            html += '<strong>ü•õ CE (Cum Eating):</strong> Complete the CE requirement.';
            html += '</div>';
        }
    } else {
        html += '<div style="font-size: 28px; font-weight: bold; color: #adb5bd; margin-bottom: 10px;">‚ùå No Prize ‚ùå</div>';
        html += '<p style="font-size: 16px; margin-bottom: 15px;">Better luck next time!</p>';
        // No modifiers for None
    }
    
    html += '</div>';
    return html;
}

// Reveal prize after button click
function revealFinalPrize(taskId, prizeType) {
    const revealDiv = document.getElementById(`prizeReveal_${taskId}`);
    if (revealDiv) {
        revealDiv.innerHTML = generatePrizeHTML(prizeType);
        revealDiv.style.display = 'block';
    }
}

// Storage Functions
function saveGameState() {
    localStorage.setItem('snakesLaddersGameState', JSON.stringify({
        gameStarted,
        playerPosition,
        turnCount,
        turnCountBySet,
        turnCountByToy,
        lastSelectedSet,
        selectedSets,
        toyDifficulties,
        prizeSettings,
        toyQuantities,
        toyModifiers,
        bodyPartState,
        playerName,
        toySetEnabled,
        toyChecked,
        prisonLocked,
        prisonWorn,
        finalChallengeSettings,
        finalChallengeTypes,
        finalChallengeDifficulties,
        finalChallengeModifiers,
        diceResultText: diceResult.textContent,
        currentInstruction: instructions.innerHTML,
        instructionsActive: instructions.classList.contains('active'),
        lastTaskInfo: window.lastTaskInfo || null
    }));
}

function loadGameState() {
    const saved = localStorage.getItem('snakesLaddersGameState');
    if (!saved) return false;
    
    try {
        const gs = JSON.parse(saved);
        gameStarted = gs.gameStarted;
        playerPosition = gs.playerPosition;
        turnCount = gs.turnCount || 0;
        turnCountBySet = gs.turnCountBySet || {};
        turnCountByToy = gs.turnCountByToy || {};
        lastSelectedSet = gs.lastSelectedSet || {};
        selectedSets = gs.selectedSets || [];
        toyDifficulties = gs.toyDifficulties || {};
        toyQuantities = gs.toyQuantities || {};
        toyModifiers = gs.toyModifiers || {};
        playerName = gs.playerName || '';
        toySetEnabled = gs.toySetEnabled || {};
        toyChecked = gs.toyChecked || {};
        prisonLocked = gs.prisonLocked || false;
        prisonWorn = gs.prisonWorn || false;
        finalChallengeSettings = gs.finalChallengeSettings || {gestures: 33, vibranium: 33, analyse: 34};
        finalChallengeTypes = gs.finalChallengeTypes || {
            gestures_ihot: false, gestures_icewater: false, gestures_spikeyband: false,
            gestures_squeezing: false, gestures_2finger: false, vibranium_ihot: false,
            vibranium_icewater: false, analyse_vibranium: false
        };
        finalChallengeDifficulties = gs.finalChallengeDifficulties || {gestures: 'medium', vibranium: 'medium', analyse: 'medium'};
        finalChallengeModifiers = gs.finalChallengeModifiers || {ce: false, pf: false};
        
        if (gs.bodyPartState) {
            bodyPartState = gs.bodyPartState;
        }
        
        if (gs.prizeSettings) {
            prizeSettings = gs.prizeSettings;
            updateSliderDisplays(true);
        }
        
        document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => {
            cb.checked = selectedSets.includes(cb.value);
        });
        
        // Restore final challenge sliders
        document.getElementById('gesturesSlider').value = finalChallengeSettings.gestures;
        document.getElementById('vibraniumSlider').value = finalChallengeSettings.vibranium;
        document.getElementById('analyseSlider').value = finalChallengeSettings.analyse;
        document.getElementById('gesturesPercent').textContent = finalChallengeSettings.gestures + '%';
        document.getElementById('vibraniumPercent').textContent = finalChallengeSettings.vibranium + '%';
        document.getElementById('analysePercent').textContent = finalChallengeSettings.analyse + '%';
        
        // Restore final challenge type checkboxes
        Object.keys(finalChallengeTypes).forEach(key => {
            const checkbox = document.getElementById(key);
            if (checkbox) checkbox.checked = finalChallengeTypes[key];
        });
        
        // Restore final challenge difficulty dropdowns
        Object.keys(finalChallengeDifficulties).forEach(type => {
            const dropdown = document.getElementById(`${type}Difficulty`);
            if (dropdown) dropdown.value = finalChallengeDifficulties[type];
        });
        
        // Restore final challenge modifier checkboxes
        Object.keys(finalChallengeModifiers).forEach(mod => {
            const checkbox = document.getElementById(`modifier_${mod}`);
            if (checkbox) checkbox.checked = finalChallengeModifiers[mod];
        });
        
        if (gameStarted) {
            startButton.style.display = 'none';
            rollDiceButton.style.display = 'block';
            diceResult.style.display = 'block';
            turnCounter.style.display = 'block';
            diceResult.textContent = gs.diceResultText || 'Dice: -';
            turnCounter.textContent = `Turn: ${turnCount}`;
            
            const leftCol = document.querySelector('.settings-column-left');
            const rightCol = document.querySelector('.settings-column-right');
            if (leftCol) leftCol.style.display = 'none';
            if (rightCol) rightCol.style.display = 'none';
            
            createBoard();
            
            if (playerPosition > 0) {
                const sq = document.getElementById(`square-${playerPosition}`);
                if (sq) sq.appendChild(player);
            }
            
            if (gs.lastTaskInfo && gs.lastTaskInfo.taskType) {
                window.lastTaskInfo = gs.lastTaskInfo;
                instructions.classList.add('active');
                
                if (gs.lastTaskInfo.taskType === 'metronome') {
                    currentMetronomeTask = createMetronomeTask(gs.lastTaskInfo.beatCount);
                    instructions.innerHTML = '';
                    instructions.appendChild(currentMetronomeTask.element);
                } else if (gs.lastTaskInfo.taskType === 'redlight') {
                    currentMetronomeTask = createRedLightGreenLightTask(gs.lastTaskInfo.duration);
                    instructions.innerHTML = '';
                    instructions.appendChild(currentMetronomeTask.element);
                } else if (gs.currentInstruction) {
                    instructions.innerHTML = gs.currentInstruction;
                }
            } else if (gs.currentInstruction && gs.currentInstruction.trim() !== '') {
                instructions.innerHTML = gs.currentInstruction;
                if (gs.instructionsActive) instructions.classList.add('active');
            }
        } else {
            document.getElementById('playerNameInput').value = playerName;
            renderToyLibrary();
        }
        
        return true;
    } catch (e) {
        console.error('Load error:', e);
        return false;
    }
}

// Prize Functions
function updateSliderDisplays(skipSave = false) {
    prizeSettings.minor = Math.round(prizeSettings.minor * 10) / 10;
    prizeSettings.major = Math.round(prizeSettings.major * 10) / 10;
    prizeSettings.noPrize = Math.round(prizeSettings.noPrize * 10) / 10;
    
    document.getElementById('minorPercent').textContent = prizeSettings.minor.toFixed(1) + '%';
    document.getElementById('majorPercent').textContent = prizeSettings.major.toFixed(1) + '%';
    document.getElementById('noPrizePercent').textContent = prizeSettings.noPrize.toFixed(1) + '%';
    
    document.getElementById('minorSlider').value = prizeSettings.minor;
    document.getElementById('majorSlider').value = prizeSettings.major;
    document.getElementById('noPrizeSlider').value = prizeSettings.noPrize;
    
    if (!skipSave) saveGameState();
}

document.getElementById('minorSlider').addEventListener('input', function() {
    const newMinor = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(prizeSettings.noPrize);
    prizeSettings.minor = newMinor > maxAllowed ? maxAllowed : newMinor;
    prizeSettings.major = 100 - prizeSettings.noPrize - prizeSettings.minor;
    updateSliderDisplays();
});

document.getElementById('majorSlider').addEventListener('input', function() {
    const newMajor = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(prizeSettings.noPrize);
    prizeSettings.major = newMajor > maxAllowed ? maxAllowed : newMajor;
    prizeSettings.minor = 100 - prizeSettings.noPrize - prizeSettings.major;
    updateSliderDisplays();
});

document.getElementById('noPrizeSlider').addEventListener('input', function() {
    const newNoPrize = Math.round(parseFloat(this.value));
    const available = 100 - newNoPrize;
    const currentTotal = Math.round(prizeSettings.minor) + Math.round(prizeSettings.major);
    
    // Changed: use equal split for BOTH directions (not just when increasing)
    if (available !== currentTotal) {
        const change = available - currentTotal;
        const half = change / 2;
        prizeSettings.minor = Math.max(0, Math.round(prizeSettings.minor + half));
        prizeSettings.major = Math.max(0, Math.round(prizeSettings.major + half));
        
        // Ensure total is exactly 100 by adjusting noPrize if values were clamped
        const actualTotal = prizeSettings.minor + prizeSettings.major;
        prizeSettings.noPrize = Math.max(0, 100 - actualTotal);
    } else {
        prizeSettings.noPrize = Math.max(0, newNoPrize);
    }
    
    updateSliderDisplays();
});

function determinePrize() {
    const roll = Math.random() * 100;
    return roll < prizeSettings.major ? 'major' : 
           roll < prizeSettings.major + prizeSettings.minor ? 'minor' : 'none';
}

function displayPrizeResult(prize) {
    return prize === 'major' ? 
        '<div class="prize-result prize-major">üèÜ MAJOR PRIZE! üèÜ<br>Congratulations!</div>' :
        prize === 'minor' ? 
        '<div class="prize-result prize-minor">üéâ Minor Prize! üéâ<br>Nice job!</div>' :
        '<div class="prize-result prize-none">‚ùå No Prize<br>Better luck next time!</div>';
}

// Body Part Functions
function canAddToyToBodyPart(bodyPart, toyId) {
    if (toyId === 'stickers') {
        // Clothestickers case
        // Can't add if body part has regular toys
        if (hasRegularToys(bodyPart)) {
            return false;
        }
        // Check if under max count
        const currentCount = getClothestickerCount(bodyPart);
        const maxCount = getClothestickerMax(bodyPart);
        return currentCount < maxCount;
    } else {
        // Regular toy case
        // Body part must be completely empty (no regular toys AND no clothestickers)
        return isBodyPartEmpty(bodyPart);
    }
}

function addToyToBodyPart(bodyPart, toyId) {
    if (canAddToyToBodyPart(bodyPart, toyId)) {
        bodyPartState[bodyPart].items.push(toyId);
        saveGameState();
        return true;
    }
    return false;
}

function removeToyFromBodyPart(bodyPart, toyId) {
    const index = bodyPartState[bodyPart].items.indexOf(toyId);
    if (index > -1) {
        bodyPartState[bodyPart].items.splice(index, 1);
        saveGameState();
        return true;
    }
    return false;
}

function getAvailableBodyPartsForToy(toyId) {
    const available = [];
    
    for (const [partKey, part] of Object.entries(bodyPartState)) {
        if (canAddToyToBodyPart(partKey, toyId)) {
            available.push({
                key: partKey,
                name: part.name,
                available: toyId === 'stickers' ? 
                    (getClothestickerMax(partKey) - getClothestickerCount(partKey)) : 
                    1
            });
        }
    }
    
    return available;
}

function getBodyPartsHoldingToy(toyId) {
    const holding = [];
    
    for (const [partKey, part] of Object.entries(bodyPartState)) {
        if (part.items.includes(toyId)) {
            holding.push({
                key: partKey,
                name: part.name
            });
        }
    }
    
    return holding;
}

// Add/Remove Task Functions
function createAddToyTaskWithBodyPart(toyKey, toyName, bodyPart, quantity = 1) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_');
    
    // For clothestickers, check if we can add the requested quantity
    if (toyId === 'stickers') {
        const currentCount = getClothestickerCount(bodyPart);
        const maxCount = getClothestickerMax(bodyPart);
        const spaceAvailable = maxCount - currentCount;
        
        // If we can't add any or if body part has regular toys, return null
        if (spaceAvailable <= 0 || hasRegularToys(bodyPart)) {
            return null;
        }
        
        // Cap the quantity at what's available
        const actualQuantity = Math.min(quantity, spaceAvailable);
        
        return {
            type: 'add',
            toyId: toyId,
            toyKey: toyKey,
            toyName: toyName,
            bodyPart: bodyPart,
            bodyPartName: bodyPartState[bodyPart].name,
            quantity: actualQuantity,
            execute: function() {
                // Add multiple clothestickers
                for (let i = 0; i < this.quantity; i++) {
                    if (!addToyToBodyPart(this.bodyPart, this.toyId)) {
                        return false;
                    }
                }
                return true;
            },
            getHTML: function() {
                return `<strong>üì• Pick Up Task</strong><p>Pick up ${this.quantity} ${this.toyName} and hold them in your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">These will stay with you until a task tells you to put them down.</p>`;
            }
        };
    } else {
        // Regular toy - check if body part is empty
        let heldCount = 0;
        for (const part of Object.values(bodyPartState)) {
            heldCount += part.items.filter(item => item === toyId).length;
        }
        
        const totalAvailable = toyQuantities[toyKey] || 0;
        if (heldCount >= totalAvailable) {
            return null;
        }
        
        // Check if the specific body part can hold this toy
        if (!canAddToyToBodyPart(bodyPart, toyId)) {
            return null;
        }
        
        return {
            type: 'add',
            toyId: toyId,
            toyKey: toyKey,
            toyName: toyName,
            bodyPart: bodyPart,
            bodyPartName: bodyPartState[bodyPart].name,
            quantity: 1,
            execute: function() {
                return addToyToBodyPart(this.bodyPart, this.toyId);
            },
            getHTML: function() {
                return `<strong>üì• Pick Up Task</strong><p>Pick up the ${this.toyName} and hold it in your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">This toy will stay with you until a task tells you to put it down.</p>`;
            }
        };
    }
}

function createRemoveToyTaskWithBodyPart(toyKey, toyName, bodyPart, quantity = 1) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_');
    
    // For clothestickers, check if we have enough to remove
    if (toyId === 'stickers') {
        const currentCount = getClothestickerCount(bodyPart);
        
        if (currentCount <= 0) {
            return null;
        }
        
        // Cap the quantity at what's actually there
        const actualQuantity = Math.min(quantity, currentCount);
        
        return {
            type: 'remove',
            toyId: toyId,
            toyKey: toyKey,
            toyName: toyName,
            bodyPart: bodyPart,
            bodyPartName: bodyPartState[bodyPart].name,
            quantity: actualQuantity,
            execute: function() {
                // Remove multiple clothestickers
                for (let i = 0; i < this.quantity; i++) {
                    if (!removeToyFromBodyPart(this.bodyPart, this.toyId)) {
                        return false;
                    }
                }
                return true;
            },
            getHTML: function() {
                return `<strong>üì§ Put Down Task</strong><p>Put down ${this.quantity} ${this.toyName} from your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">You can now use this space again.</p>`;
            }
        };
    } else {
        // Regular toy - check if this specific body part is holding the toy
        if (!bodyPartState[bodyPart].items.includes(toyId)) {
            return null;
        }
        
        return {
            type: 'remove',
            toyId: toyId,
            toyKey: toyKey,
            toyName: toyName,
            bodyPart: bodyPart,
            bodyPartName: bodyPartState[bodyPart].name,
            quantity: 1,
            execute: function() {
                return removeToyFromBodyPart(this.bodyPart, this.toyId);
            },
            getHTML: function() {
                return `<strong>üì§ Put Down Task</strong><p>Put down the ${this.toyName} from your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">You can now use this body part freely again.</p>`;
            }
        };
    }
}

function toyHasAddRemoveTasks(toyKey) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_');
    
    if (!instructionSets[setId] || !instructionSets[setId].tasks[toyId]) return false;
    
    const tasks = instructionSets[setId].tasks[toyId];
    const hasAdd = tasks.some(task => task.type === 'add');
    const hasRemove = tasks.some(task => task.type === 'remove');
    
    return hasAdd && hasRemove;
}

function rollForAddRemoveTasks() {
    const addTasks = [];
    const removeTasks = [];
    
    for (const [toyKey, quantity] of Object.entries(toyQuantities)) {
        if (quantity > 0) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_');
            
            // Only roll for toys whose set is selected, toy is checked, and set-toy combo is enabled
            if (!selectedSets.includes(setId)) continue;
            if (!toyChecked[toyId]) continue;
            if (!toySetEnabled[toyKey]) continue;
            
            if (!isToyWearable(toyId)) continue;
            
            if (!instructionSets[setId] || !instructionSets[setId].tasks[toyId]) continue;
            
            const tasks = instructionSets[setId].tasks[toyId];
            const difficulty = toyDifficulties[toyKey] || 'medium';
            
            // Find add and remove tasks with body parts
            const addTask = tasks.find(task => task.type === 'add' && task.bodyPart);
            const removeTask = tasks.find(task => task.type === 'remove' && task.bodyPart);
            
            if (!addTask || !removeTask) continue;
            
            // If prison is locked, set add/remove chances to 0
            let effectiveAddChance = toyModifiers[toyKey]?.addChance || 10;
            let effectiveRemoveChance = toyModifiers[toyKey]?.removeChance || 20;
            
            if (toyId === 'prison' && prisonLocked) {
                effectiveAddChance = 0;
                effectiveRemoveChance = 0;
            }
            
            // Use effective chances instead of direct toyModifiers
            const shouldAdd = Math.random() * 100 < effectiveAddChance;
            const shouldRemove = Math.random() * 100 < effectiveRemoveChance;
            
            if (shouldAdd) {
                let toyName = toyId;
                
                if (instructionSets[setId]) {
                    const toy = instructionSets[setId].toys.find(t => t.id === toyId);
                    if (toy) toyName = toy.name;
                }
                
                const taskQuantity = addTask.quantity ? addTask.quantity(difficulty) : 1;
                const task = createAddToyTaskWithBodyPart(toyKey, toyName, addTask.bodyPart, taskQuantity);
                if (task) addTasks.push(task);
            }
            
            if (shouldRemove) {
                let toyName = toyId;
                
                if (instructionSets[setId]) {
                    const toy = instructionSets[setId].toys.find(t => t.id === toyId);
                    if (toy) toyName = toy.name;
                }
                
                const taskQuantity = removeTask.quantity ? removeTask.quantity(difficulty) : 1;
                const task = createRemoveToyTaskWithBodyPart(toyKey, toyName, removeTask.bodyPart, taskQuantity);
                if (task) removeTasks.push(task);
            }
        }
    }
    
    const allTasks = [...addTasks, ...removeTasks];
    if (allTasks.length > 0) {
        return allTasks[Math.floor(Math.random() * allTasks.length)];
    }
    
    return null;
}

// Metronome Task
function createMetronomeTask(beatCount) {
    let metronomeInterval = null;
    let countdownInterval = null;
    let isComplete = false;
    
    const wrapper = document.createElement('div');
    const textDiv = document.createElement('div');
    textDiv.innerHTML = '<strong>üèÄ Bounce to the Beat!</strong><p>Bounce the basketball in rhythm.</p>';
    wrapper.appendChild(textDiv);
    
    const container = document.createElement('div');
    container.className = 'metronome-container';
    container.innerHTML = `
        <div class="metronome-beat" id="metronomeBeat"></div>
        <div class="metronome-display" id="metronomeDisplay">Ready?</div>
        <button class="metronome-btn" id="startMetronome">‚ñ∂Ô∏è Start</button>
    `;
    wrapper.appendChild(container);
    
    const startBtn = container.querySelector('#startMetronome');
    const display = container.querySelector('#metronomeDisplay');
    const beat = container.querySelector('#metronomeBeat');
    
    startBtn.addEventListener('click', function() {
        startBtn.disabled = true;
        let count = 3;
        display.textContent = count;
        
        countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                display.textContent = count;
            } else {
                clearInterval(countdownInterval);
                display.textContent = "Bounce!";
                startMetronome();
            }
        }, 1000);
    });
    
    function playBeep() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.type = 'sine';
        osc.frequency.value = 440;
        gain.gain.setValueAtTime(0.3, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
        osc.start(audioContext.currentTime);
        osc.stop(audioContext.currentTime + 0.05);
    }
    
    function startMetronome() {
        let beatsLeft = beatCount;
        const bpm = 100;
        const interval = 60000 / bpm;
        
        function doBeat() {
            beatsLeft--;
            beat.classList.add('active');
            playBeep();
            display.textContent = `${beatsLeft} bounces left`;
            
            setTimeout(() => {
                beat.classList.remove('active');
            }, 100);
            
            if (beatsLeft <= 0) {
                clearInterval(metronomeInterval);
                display.textContent = "Complete! ‚úì";
                isComplete = true;
                continueButton.disabled = false;
                continueButton.style.opacity = '1';
            }
        }
        
        doBeat();
        metronomeInterval = setInterval(doBeat, interval);
        continueButton.disabled = true;
        continueButton.style.opacity = '0.5';
    }
    
    return {
        element: wrapper,
        isComplete: () => isComplete,
        cleanup: () => {
            if (metronomeInterval) clearInterval(metronomeInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        },
        hasStarted: () => startBtn.disabled
    };
}

// Red Light Green Light Task
function createRedLightGreenLightTask(totalDuration) {
    let gameInterval = null;
    let countdownInterval = null;
    let isComplete = false;
    let timeRemaining = totalDuration;
    
    const imagePatterns = [
        {image: 'chair.jpg', name: 'Chair', type: 'red'},
        {image: 'broom.jpg', name: 'Broom', type: 'green'},
        {image: 'hat.jpg', name: 'Hat', type: 'red'},
        {image: 'ball.jpg', name: 'Ball', type: 'green'},
        {image: 'books.jpg', name: 'Books', type: 'red'},
        {image: 'car.jpg', name: 'Car', type: 'green'},
        {image: 'tree.jpg', name: 'Tree', type: 'red'},
        {image: 'guitar.jpg', name: 'Guitar', type: 'green'},
        {image: 'apple.jpg', name: 'Apple', type: 'red'},
        {image: 'bike.jpg', name: 'Bike', type: 'green'}
    ];
    
    const lightPatterns = [
        {duration: 2000}, {duration: 1500}, {duration: 1500}, {duration: 2500},
        {duration: 1000}, {duration: 3000}, {duration: 2000}, {duration: 1500}
    ];
    
    const container = document.createElement('div');
    container.className = 'metronome-container';
    container.style.background = 'linear-gradient(135deg, #845ef7 0%, #5f3dc4 100%)';
    container.innerHTML = `
        <div><strong>üö¶ Red Light, Green Light!</strong></div>
        <p style="color: white; margin: 10px 0;">üü¢ GREEN = Jump! | üî¥ RED = Stop!</p>
        <div style="background: rgba(255, 255, 255, 0.2); border-radius: 15px; padding: 20px; margin: 15px 0;">
            <div style="width: 150px; height: 150px; margin: 0 auto 10px; background: white; border-radius: 10px; display: flex; align-items: center; justify-content: center; overflow: hidden;" id="imageContainer">
                <div style="font-size: 3em; color: #845ef7;">üö¶</div>
            </div>
            <div style="color: white; font-size: 1.2em; font-weight: bold;" id="imageName">Get Ready!</div>
        </div>
        <div style="width: 120px; height: 120px; border-radius: 50%; background: rgba(255, 255, 255, 0.3); margin: 20px auto; display: flex; align-items: center; justify-content: center; font-size: 4em; transition: all 0.3s ease;" id="lightIndicator">‚è∏Ô∏è</div>
        <div class="metronome-display" id="lightDisplay">Press Start!</div>
        <div style="color: white; font-size: 18px; margin: 10px 0;" id="timeDisplay"></div>
        <button class="metronome-btn" id="startRedLight">‚ñ∂Ô∏è Start</button>
    `;
    
    const startBtn = container.querySelector('#startRedLight');
    const display = container.querySelector('#lightDisplay');
    const lightIndicator = container.querySelector('#lightIndicator');
    const timeDisplay = container.querySelector('#timeDisplay');
    const imageContainer = container.querySelector('#imageContainer');
    const imageName = container.querySelector('#imageName');
    
    startBtn.addEventListener('click', function() {
        startBtn.disabled = true;
        let count = 3;
        imageContainer.innerHTML = `<div style="font-size: 4em; color: #845ef7;">${count}</div>`;
        imageName.textContent = 'Starting...';
        lightIndicator.textContent = '‚è≥';
        display.textContent = 'Get ready...';
        
        countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                imageContainer.innerHTML = `<div style="font-size: 4em; color: #845ef7;">${count}</div>`;
            } else {
                clearInterval(countdownInterval);
                startGame();
            }
        }, 1000);
    });
    
    function startGame() {
        let currentImageIndex = 0;
        let currentPatternIndex = 0;
        
        function showNextLight() {
            if (timeRemaining <= 0) {
                clearInterval(gameInterval);
                display.textContent = "Game Complete! ‚úì";
                lightIndicator.textContent = "‚úì";
                lightIndicator.style.background = "linear-gradient(135deg, #51cf66 0%, #37b24d 100%)";
                imageContainer.innerHTML = '<div style="font-size: 4em; color: #51cf66;">üéâ</div>';
                imageName.textContent = "Great Job!";
                timeDisplay.textContent = "";
                isComplete = true;
                continueButton.disabled = false;
                continueButton.style.opacity = '1';
                return;
            }
            
            const currentImage = imagePatterns[currentImageIndex];
            const pattern = lightPatterns[currentPatternIndex];
            
            imageContainer.innerHTML = `<img src="${currentImage.image}" alt="${currentImage.name}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'font-size: 3em; color: #845ef7;\\'>${currentImage.name[0]}</div>';">`;
            imageName.textContent = currentImage.name;
            lightIndicator.textContent = currentImage.type === 'green' ? 'üü¢' : 'üî¥';
            display.textContent = currentImage.type === 'green' ? 'GREEN LIGHT - JUMP!' : 'RED LIGHT - STOP!';
            
            if (currentImage.type === 'green') {
                lightIndicator.style.background = 'linear-gradient(135deg, #51cf66 0%, #37b24d 100%)';
                lightIndicator.style.transform = 'scale(1.2)';
            } else {
                lightIndicator.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)';
                lightIndicator.style.transform = 'scale(1)';
            }
            
            const displayDuration = Math.min(pattern.duration, timeRemaining);
            timeRemaining -= displayDuration;
            timeDisplay.textContent = `${Math.ceil(timeRemaining / 1000)}s remaining`;
            
            setTimeout(() => {
                currentImageIndex++;
                if (currentImageIndex >= imagePatterns.length) {
                    currentImageIndex = 0;
                }
                currentPatternIndex++;
                if (currentPatternIndex >= lightPatterns.length) {
                    currentPatternIndex = 0;
                }
                showNextLight();
            }, displayDuration);
        }
        
        continueButton.disabled = true;
        continueButton.style.opacity = '0.5';
        showNextLight();
    }
    
    return {
        element: container,
        isComplete: () => isComplete,
        cleanup: () => {
            if (gameInterval) clearInterval(gameInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        },
        hasStarted: () => startBtn.disabled
    };
}

// Board Functions
function createBoard() {
    let reverse = false;
    let currentNumber = 1;
    
    for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
            const actualCol = reverse ? boardSize - col - 1 : col;
            const square = document.createElement('div');
            square.classList.add('square');
            square.textContent = currentNumber;
            square.id = `square-${currentNumber}`;
            square.style.gridRow = boardSize - row;
            square.style.gridColumn = actualCol + 1;
            
            if (snakes[currentNumber]) {
                square.classList.add('snake');
                square.setAttribute('data-destination', '‚Üì' + snakes[currentNumber]);
            } else if (ladders[currentNumber]) {
                square.classList.add('ladder');
                square.setAttribute('data-destination', '‚Üë' + ladders[currentNumber]);
            }
            
            board.appendChild(square);
            currentNumber++;
        }
        reverse = !reverse;
    }
}

function animatePlayer(start, end, callback, instant = false) {
    if (instant) {
        const targetSquare = document.getElementById(`square-${end}`);
        if (targetSquare) targetSquare.appendChild(player);
        if (callback) callback();
        return;
    }
    
    let current = start;
    const step = current < end ? 1 : -1;
    
    const interval = setInterval(() => {
        current += step;
        const currentSquare = document.getElementById(`square-${current}`);
        if (currentSquare) currentSquare.appendChild(player);
        
        if (current === end) {
            clearInterval(interval);
            if (callback) callback();
        }
    }, 200);
}

// Check if any toys have "always" tasks that meet their conditions
function checkForAlwaysTasks(toys, conditions) {
    const alwaysTasks = [];
    for (const toyObj of toys) {
        const tasks = instructionSets[toyObj.setId].tasks[toyObj.toyId];
        if (!tasks) continue;
        
        for (const task of tasks) {
            // Skip add/remove tasks
            if (task.type === 'add' || task.type === 'remove') continue;
            // Check if this is an "always" task and its condition is met
            if (task.alwaysSelect && task.alwaysSelect(conditions)) {
                alwaysTasks.push({task, toyObj});
            }
        }
    }
    return alwaysTasks;
}

// Toy Selection Functions
function getSelectedToys() {
    const allToys = [];
    for (const [toyKey, quantity] of Object.entries(toyQuantities)) {
        if (quantity > 0) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_');
            
            // Only include toy if: toy is checked, set-toy combo is enabled, AND the set is selected
            if (toyChecked[toyId] && toySetEnabled[toyKey] && selectedSets.includes(setId)) {
                allToys.push({
                    toyId,
                    setId,
                    difficulty: toyDifficulties[toyKey] || 'medium'
                });
            }
        }
    }
    return allToys;
}

function displayRandomInstruction() {
    const toys = getSelectedToys();
    
    if (currentMetronomeTask) {
        currentMetronomeTask.cleanup();
        currentMetronomeTask = null;
    }
    
    if (toys.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>üéØ Select instruction sets and toys to get started!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const conditions = getTaskConditions();
    
    // First, check if any toys have "always" tasks
    const alwaysTasks = checkForAlwaysTasks(toys, conditions);
    
    if (alwaysTasks.length > 0) {
        const selectedAlways = alwaysTasks[Math.floor(Math.random() * alwaysTasks.length)];
        const {task, toyObj} = selectedAlways;
        
        // Increment turn counts
        const selectedToyKey = `${toyObj.setId}_${toyObj.toyId}`;
        turnCountBySet[toyObj.setId] = (turnCountBySet[toyObj.setId] || 0) + 1;
        turnCountByToy[selectedToyKey] = (turnCountByToy[selectedToyKey] || 0) + 1;
        lastSelectedSet[toyObj.toyId] = toyObj.setId;
        
        // Execute the task if it has an execute function
        if (task.execute) {
            task.execute();
        }
        
        window.lastTaskInfo = {
            toyId: toyObj.toyId,
            setId: toyObj.setId,
            difficulty: toyObj.difficulty,
            taskType: 'always'
        };
        
        instructions.classList.add('active');
        
        // Create difficulty map
        const difficultyMap = {};
        for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_');
            if (!difficultyMap[toyId]) {
                difficultyMap[toyId] = diff;
            }
        }
        
        const content = task.getDifficulty(toyObj.difficulty, conditions, difficultyMap);
        instructions.innerHTML = content;
        saveGameState();
        return;
    }
    
    // No "always" tasks - proceed with normal task selection
    // Filter toys to only those with available tasks
    const toysWithAvailableTasks = toys.filter(toyObj => {
        const tasks = instructionSets[toyObj.setId].tasks[toyObj.toyId];
        if (!tasks || tasks.length === 0) return false;
        
        const availableTasks = tasks.filter(task => {
            // Filter out add/remove tasks - they're handled separately
            if (task.type === 'add' || task.type === 'remove') return false;
            // Check canSelect condition if it exists
            return !task.canSelect || task.canSelect(conditions);
        });
        
        return availableTasks.length > 0;
    });
    
    if (toysWithAvailableTasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>No available tasks for current conditions!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const randomToyObj = toysWithAvailableTasks[Math.floor(Math.random() * toysWithAvailableTasks.length)];
    const tasks = instructionSets[randomToyObj.setId].tasks[randomToyObj.toyId];
    
    const availableTasks = tasks.filter(task => {
        // Filter out add/remove tasks - they're handled separately
        if (task.type === 'add' || task.type === 'remove') return false;
        // Check canSelect condition if it exists
        return !task.canSelect || task.canSelect(conditions);
    });
    
    const randomTask = availableTasks[Math.floor(Math.random() * availableTasks.length)];
    
    // Increment turn counts for this set and toy
    const selectedToyKey = `${randomToyObj.setId}_${randomToyObj.toyId}`;
    turnCountBySet[randomToyObj.setId] = (turnCountBySet[randomToyObj.setId] || 0) + 1;
    turnCountByToy[selectedToyKey] = (turnCountByToy[selectedToyKey] || 0) + 1;
    lastSelectedSet[randomToyObj.toyId] = randomToyObj.setId;
    
    window.lastTaskInfo = {
        toyId: randomToyObj.toyId,
        setId: randomToyObj.setId,
        difficulty: randomToyObj.difficulty,
        taskType: randomTask.type || 'normal'
    };
    
    instructions.classList.add('active');
    
    // Create difficulty map for all toys
    const difficultyMap = {};
    for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
        const [setId, ...toyIdParts] = toyKey.split('_');
        const toyId = toyIdParts.join('_');
        if (!difficultyMap[toyId]) {
            difficultyMap[toyId] = diff;
        }
    }
    
    if (randomTask.type === 'metronome') {
        const beatCount = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        window.lastTaskInfo.beatCount = beatCount;
        currentMetronomeTask = createMetronomeTask(beatCount);
        instructions.innerHTML = '';
        instructions.appendChild(currentMetronomeTask.element);
    } else if (randomTask.type === 'redlight') {
        const duration = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        window.lastTaskInfo.duration = duration;
        currentMetronomeTask = createRedLightGreenLightTask(duration);
        instructions.innerHTML = '';
        instructions.appendChild(currentMetronomeTask.element);
    } else {
        const content = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        instructions.innerHTML = content;
    }
}

function displaySnakeLadderTask(type, fromPos, toPos) {
    const conditions = getTaskConditions();
    
    // Calculate distance (positive for ladder up, negative for snake down)
    const distance = toPos - fromPos;
    
    const snakeLadderInfo = {
        type: type, // 'snake' or 'ladder'
        from: fromPos,
        to: toPos,
        distance: distance
    };
    
    // Get the appropriate task list
    const taskListKey = type === 'snake' ? 'snakeTasks' : 'ladderTasks';
    const taskList = snakeLadderTasks && snakeLadderTasks[taskListKey];
    
    // Build debug info
    let debugInfo = '<div style="background: #f0f0f0; padding: 10px; margin: 10px 0; border-radius: 5px; font-family: monospace; font-size: 0.85em;">';
    debugInfo += '<strong>üîç DEBUG INFO:</strong><br>';
    debugInfo += `Type: ${type}<br>`;
    debugInfo += `snakeLadderTasks exists: ${typeof snakeLadderTasks !== 'undefined'}<br>`;
    debugInfo += `taskListKey: ${taskListKey}<br>`;
    debugInfo += `taskList exists: ${!!taskList}<br>`;
    debugInfo += `taskList length: ${taskList ? taskList.length : 'N/A'}<br>`;
    
    if (!taskList || taskList.length === 0) {
        debugInfo += '<strong style="color: red;">ERROR: No task list found!</strong><br>';
        debugInfo += 'This means snakeTasks or ladderTasks is missing from snakeLadderTasks object';
        debugInfo += '</div>';
        
        instructions.classList.add('active');
        instructions.innerHTML = type === 'snake' ? 
            `<div><strong>Snake Slide! üêç</strong><p>You slid down ${Math.abs(distance)} spaces from ${fromPos} to ${toPos}.</p>${debugInfo}</div>` :
            `<div><strong>Ladder Climb! ü™ú</strong><p>You climbed ${distance} spaces from ${fromPos} to ${toPos}!</p>${debugInfo}</div>`;
        return;
    }
    
    // Check conditions for first task if it has canSelect
    if (taskList[0].canSelect) {
        debugInfo += '<br><strong>Condition Checks:</strong><br>';
        debugInfo += `- hasSet(tnd): ${conditions.hasSet('tnd')}<br>`;
        debugInfo += `- toyChecked(hand): ${conditions.toyChecked('hand')}<br>`;
        debugInfo += `- toyChecked(vibranium): ${conditions.toyChecked('vibranium')}<br>`;
        debugInfo += `- toySetEnabled(tnd_hand): ${conditions.toySetEnabled('tnd_hand')}<br>`;
        debugInfo += `- toySetEnabled(tnd_vibranium): ${conditions.toySetEnabled('tnd_vibranium')}<br>`;
        debugInfo += `- toyQuantity(tnd_hand): ${conditions.toyQuantity('tnd_hand')}<br>`;
        debugInfo += `- toyQuantity(tnd_vibranium): ${conditions.toyQuantity('tnd_vibranium')}<br>`;
        debugInfo += `- canBodyPartHold(Ha, hand): ${conditions.canBodyPartHold('Ha', 'hand')}<br>`;
        debugInfo += `- isHolding(vibranium): ${conditions.isHolding('vibranium')}<br>`;
    }
    
    // Filter available tasks
    const availableTasks = taskList.filter(task => {
        const canSelect = !task.canSelect || task.canSelect(conditions);
        return canSelect;
    });
    
    debugInfo += `<br><strong>Available tasks: ${availableTasks.length} / ${taskList.length}</strong><br>`;
    
    if (availableTasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = `<div>No snake/ladder tasks available!${debugInfo}</div>`;
        return;
    }
    
    // Prioritize conditional tasks (those with canSelect) over fallback tasks
    const conditionalTasks = availableTasks.filter(t => t.canSelect);
    const selectedTask = conditionalTasks.length > 0 ? 
        conditionalTasks[Math.floor(Math.random() * conditionalTasks.length)] :
        availableTasks[Math.floor(Math.random() * availableTasks.length)];
    
    debugInfo += `Conditional tasks available: ${conditionalTasks.length}<br>`;
    debugInfo += `Task selected: ${selectedTask.canSelect ? 'CONDITIONAL' : 'FALLBACK'}`;
    debugInfo += '</div>';
    
    // Create difficulty map
    const difficultyMap = {};
    for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
        const [setId, ...toyIdParts] = toyKey.split('_');
        const toyId = toyIdParts.join('_');
        if (!difficultyMap[toyId]) {
            difficultyMap[toyId] = diff;
        }
    }
    
    // Get the primary difficulty (use 'medium' as default)
    const primaryDifficulty = 'medium';
    
    // Display the task
    instructions.classList.add('active');
    const content = selectedTask.getDifficulty(primaryDifficulty, conditions, difficultyMap, snakeLadderInfo);
    instructions.innerHTML = content + debugInfo;
    
    saveGameState();
}

function displayRandomInstructionWithAddRemove(addRemoveTask) {
    const toys = getSelectedToys();
    
    if (currentMetronomeTask) {
        currentMetronomeTask.cleanup();
        currentMetronomeTask = null;
    }
    
    if (toys.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>üéØ Select instruction sets and toys to get started!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const conditions = getTaskConditions();
    
    // First, check if any toys have "always" tasks
    const alwaysTasks = checkForAlwaysTasks(toys, conditions);
    
    if (alwaysTasks.length > 0) {
        const selectedAlways = alwaysTasks[Math.floor(Math.random() * alwaysTasks.length)];
        const {task, toyObj} = selectedAlways;
        
        // Increment turn counts
        const selectedToyKey = `${toyObj.setId}_${toyObj.toyId}`;
        turnCountBySet[toyObj.setId] = (turnCountBySet[toyObj.setId] || 0) + 1;
        turnCountByToy[selectedToyKey] = (turnCountByToy[selectedToyKey] || 0) + 1;
        lastSelectedSet[toyObj.toyId] = toyObj.setId;
        
        // Execute the task if it has an execute function
        if (task.execute) {
            task.execute();
        }
        
        window.lastTaskInfo = {
            toyId: toyObj.toyId,
            setId: toyObj.setId,
            difficulty: toyObj.difficulty,
            taskType: 'always'
        };
        
        instructions.classList.add('active');
        
        // Create difficulty map
        const difficultyMap = {};
        for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_');
            if (!difficultyMap[toyId]) {
                difficultyMap[toyId] = diff;
            }
        }
        
        const content = task.getDifficulty(toyObj.difficulty, conditions, difficultyMap);
        instructions.innerHTML = content;
        saveGameState();
        return;
    }
    
    // No "always" tasks - proceed with normal task selection
    // Filter toys to only those with available tasks
    const toysWithAvailableTasks = toys.filter(toyObj => {
        const tasks = instructionSets[toyObj.setId].tasks[toyObj.toyId];
        if (!tasks || tasks.length === 0) return false;
        
        const availableTasks = tasks.filter(task => {
            // Filter out add/remove tasks - they're handled separately
            if (task.type === 'add' || task.type === 'remove') return false;
            // Check canSelect condition if it exists
            return !task.canSelect || task.canSelect(conditions);
        });
        
        return availableTasks.length > 0;
    });
    
    if (toysWithAvailableTasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>No available tasks for current conditions!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const randomToyObj = toysWithAvailableTasks[Math.floor(Math.random() * toysWithAvailableTasks.length)];
    const tasks = instructionSets[randomToyObj.setId].tasks[randomToyObj.toyId];
    
    const availableTasks = tasks.filter(task => {
        // Filter out add/remove tasks - they're handled separately
        if (task.type === 'add' || task.type === 'remove') return false;
        // Check canSelect condition if it exists
        return !task.canSelect || task.canSelect(conditions);
    });
    
    const randomTask = availableTasks[Math.floor(Math.random() * availableTasks.length)];
    
    // Increment turn counts for this set and toy
    const selectedToyKey = `${randomToyObj.setId}_${randomToyObj.toyId}`;
    turnCountBySet[randomToyObj.setId] = (turnCountBySet[randomToyObj.setId] || 0) + 1;
    turnCountByToy[selectedToyKey] = (turnCountByToy[selectedToyKey] || 0) + 1;
    lastSelectedSet[randomToyObj.toyId] = randomToyObj.setId;
    
    window.lastTaskInfo = {
        toyId: randomToyObj.toyId,
        setId: randomToyObj.setId,
        difficulty: randomToyObj.difficulty,
        taskType: randomTask.type || 'normal'
    };
    
    instructions.classList.add('active');
    
    let addRemoveHTML = '';
    if (addRemoveTask) {
        const html = addRemoveTask.getHTML();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const strong = doc.querySelector('strong');
        const paragraphs = doc.querySelectorAll('p');
        let text = '';
        if (strong) text += `<strong>${strong.textContent}</strong>`;
        paragraphs.forEach(p => text += `<p>${p.textContent}</p>`);
        addRemoveHTML = text;
    }
    
    // Create difficulty map for all toys
    const difficultyMap = {};
    for (const [toyKey, diff] of Object.entries(toyDifficulties)) {
        const [setId, ...toyIdParts] = toyKey.split('_');
        const toyId = toyIdParts.join('_');
        if (!difficultyMap[toyId]) {
            difficultyMap[toyId] = diff;
        }
    }
    
    if (randomTask.type === 'metronome') {
        const beatCount = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        window.lastTaskInfo.beatCount = beatCount;
        currentMetronomeTask = createMetronomeTask(beatCount);
        instructions.innerHTML = addRemoveHTML;
        instructions.appendChild(currentMetronomeTask.element);
    } else if (randomTask.type === 'redlight') {
        const duration = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        window.lastTaskInfo.duration = duration;
        currentMetronomeTask = createRedLightGreenLightTask(duration);
        instructions.innerHTML = addRemoveHTML;
        instructions.appendChild(currentMetronomeTask.element);
    } else {
        const content = randomTask.getDifficulty(randomToyObj.difficulty, conditions, difficultyMap);
        instructions.innerHTML = addRemoveHTML + content;
    }
}

// Render Toy Library  
function renderToyLibrary() {
    selectedSets = Array.from(document.querySelectorAll('#instructionSetCheckboxes input:checked'))
        .map(cb => cb.value);
    
    const container = document.getElementById('toyLibraryContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    const setEmojis = {dressup: 'üé®', apple: 'üçé', digging: '‚õèÔ∏è', tnd: 'üéØ'};
    const allToys = {};
    
    // Always add prison toy first with empty sets array
    allToys['prison'] = {
        id: 'prison',
        name: 'Prison üîí',
        sets: [],
        alwaysVisible: true
    };
    
    selectedSets.forEach(setId => {
        if (instructionSets[setId]) {
            instructionSets[setId].toys.forEach(toy => {
                if (toy.id === 'prison') {
                    // Add this set to prison's sets array
                    allToys['prison'].sets.push({
                        setId,
                        setName: instructionSets[setId].name,
                        emoji: setEmojis[setId] || ''
                    });
                } else {
                    // Regular toy handling
                    if (!allToys[toy.id]) {
                        allToys[toy.id] = {id: toy.id, name: toy.name, sets: []};
                    }
                    allToys[toy.id].sets.push({
                        setId,
                        setName: instructionSets[setId].name,
                        emoji: setEmojis[setId] || ''
                    });
                }
            });
        }
    });
    
    for (const [toyId, toyData] of Object.entries(allToys)) {
        const toyItem = document.createElement('div');
        toyItem.className = 'toy-library-item';
        
        const toyKeys = toyData.sets.map(s => `${s.setId}_${toyId}`);
        
        toyKeys.forEach(key => {
            if (toyQuantities[key] === undefined) toyQuantities[key] = 1;
            if (!toyModifiers[key]) toyModifiers[key] = {addChance: 10, removeChance: 20};
            if (!toyDifficulties[key]) toyDifficulties[key] = 'medium';
            if (toySetEnabled[key] === undefined) toySetEnabled[key] = true;
        });
        
        if (toyChecked[toyId] === undefined) toyChecked[toyId] = true;
        
        const enabledKeys = toyKeys.filter(key => toySetEnabled[key]);
        
        const toyQuantity = toyQuantities[toyKeys[0]] || 1;
        
        const header = document.createElement('div');
        header.className = 'toy-header';
        
        const checkboxWrapper = document.createElement('div');
        checkboxWrapper.className = 'toy-checkbox-wrapper';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = toyChecked[toyId];
        checkbox.style.cursor = 'pointer';
        checkbox.onchange = () => {
            toyChecked[toyId] = checkbox.checked;
            renderToyLibrary();
            saveGameState();
        };
        checkboxWrapper.appendChild(checkbox);
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'toy-name';
        nameSpan.textContent = toyData.name;
        
        header.appendChild(checkboxWrapper);
        header.appendChild(nameSpan);
        toyItem.appendChild(header);
        
        // Special handling for prison toy
        if (toyId === 'prison') {
            const prisonControls = document.createElement('div');
            prisonControls.className = 'toy-controls';
            prisonControls.style.cssText = 'margin-left: 28px; margin-top: 10px; display: flex; flex-direction: row; gap: 16px; align-items: center;';
            
            // Worn checkbox (now first)
            const wornLabel = document.createElement('label');
            wornLabel.style.cssText = 'display: flex; align-items: center; gap: 8px; cursor: pointer;';
            
            const wornCheckbox = document.createElement('input');
            wornCheckbox.type = 'checkbox';
            wornCheckbox.checked = prisonWorn;
            wornCheckbox.disabled = !toyChecked[toyId];
            wornCheckbox.style.cssText = 'width: 18px; height: 18px; cursor: pointer; accent-color: #667eea;';
            
            const wornText = document.createElement('span');
            wornText.textContent = 'üëï Start Worn';
            wornText.style.cssText = 'font-weight: 600; color: #333;';
            
            wornLabel.appendChild(wornCheckbox);
            wornLabel.appendChild(wornText);
            prisonControls.appendChild(wornLabel);
            
            // Locked checkbox (now second)
            const lockedLabel = document.createElement('label');
            lockedLabel.style.cssText = 'display: flex; align-items: center; gap: 8px; cursor: pointer;';
            
            const lockedCheckbox = document.createElement('input');
            lockedCheckbox.type = 'checkbox';
            lockedCheckbox.checked = prisonLocked;
            lockedCheckbox.disabled = !toyChecked[toyId];
            lockedCheckbox.style.cssText = 'width: 18px; height: 18px; cursor: pointer; accent-color: #667eea;';
            lockedCheckbox.onchange = () => {
                prisonLocked = lockedCheckbox.checked;
                saveGameState();
                // Update all prison add/remove inputs to show locked state
                updatePrisonInputStates();
            };
            
            function updatePrisonInputStates() {
                // Update all prison add/remove inputs across all sets
                toyData.sets.forEach(setInfo => {
                    const toyKey = `${setInfo.setId}_prison`;
                    const addInput = document.getElementById(`add_${toyKey}`);
                    const removeInput = document.getElementById(`remove_${toyKey}`);
                    
                    if (addInput) {
                        if (prisonLocked) {
                            addInput.value = 0;
                            addInput.style.opacity = '0.5';
                            addInput.style.pointerEvents = 'none';
                        } else {
                            addInput.value = toyModifiers[toyKey]?.addChance || 10;
                            addInput.style.opacity = '1';
                            addInput.style.pointerEvents = 'auto';
                        }
                    }
                    
                    if (removeInput) {
                        if (prisonLocked) {
                            removeInput.value = 0;
                            removeInput.style.opacity = '0.5';
                            removeInput.style.pointerEvents = 'none';
                        } else {
                            removeInput.value = toyModifiers[toyKey]?.removeChance || 20;
                            removeInput.style.opacity = '1';
                            removeInput.style.pointerEvents = 'auto';
                        }
                    }
                });
            }
            
            const lockedText = document.createElement('span');
            lockedText.textContent = 'üîí Locked';
            lockedText.style.cssText = 'font-weight: 600; color: #333;';
            
            lockedLabel.appendChild(lockedCheckbox);
            lockedLabel.appendChild(lockedText);
            prisonControls.appendChild(lockedLabel);
            
            // Worn checkbox change handler
            wornCheckbox.onchange = () => {
                prisonWorn = wornCheckbox.checked;
                
                // If unchecking worn, also uncheck and disable locked
                if (!prisonWorn) {
                    prisonLocked = false;
                    lockedCheckbox.checked = false;
                    lockedCheckbox.disabled = true;
                    lockedCheckbox.style.opacity = '0.5';
                    lockedText.style.color = '#999';
                } else {
                    lockedCheckbox.disabled = false;
                    lockedCheckbox.style.opacity = '1';
                    lockedText.style.color = '#333';
                }
                
                saveGameState();
            };
            
            // Set initial locked state based on worn
            if (!prisonWorn) {
                lockedCheckbox.disabled = true;
                lockedCheckbox.style.opacity = '0.5';
                lockedText.style.color = '#999';
            }
            
            toyItem.appendChild(prisonControls);
            
            // If prison has sets (TnD or Analyse selected), show difficulty/modifiers
            if (toyData.sets.length > 0) {
                const setDifficultyContainer = document.createElement('div');
                setDifficultyContainer.className = 'set-difficulty';
                
                toyData.sets.forEach(setInfo => {
                    const toyKey = `${setInfo.setId}_${toyId}`;
                    const setItem = document.createElement('div');
                    setItem.className = 'set-difficulty-item';
                    
                    const diffRow = document.createElement('div');
                    diffRow.className = 'difficulty-row';
                    
                    const setCheckboxWrapper = document.createElement('div');
                    setCheckboxWrapper.style.cssText = 'display:flex;align-items:center;gap:8px;';
                    
                    const setCheckbox = document.createElement('input');
                    setCheckbox.type = 'checkbox';
                    setCheckbox.checked = toySetEnabled[toyKey];
                    setCheckbox.style.cssText = 'width:16px;height:16px;cursor:pointer;accent-color:#667eea;';
                    setCheckbox.disabled = !toyChecked[toyId];
                    setCheckbox.onchange = () => {
                        toySetEnabled[toyKey] = setCheckbox.checked;
                        renderToyLibrary();
                        saveGameState();
                    };
                    setCheckboxWrapper.appendChild(setCheckbox);
                    
                    const setNameSpan = document.createElement('span');
                    setNameSpan.textContent = `${setInfo.emoji} ${setInfo.setName}`;
                    setCheckboxWrapper.appendChild(setNameSpan);
                    diffRow.appendChild(setCheckboxWrapper);
                    
                    const diffControls = document.createElement('div');
                    diffControls.className = 'difficulty-controls';
                    
                    const diffSelect = document.createElement('select');
                    diffSelect.id = `difficulty_${toyKey}`;
                    diffSelect.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
                    
                    ['easy', 'medium', 'hard'].forEach(level => {
                        const opt = document.createElement('option');
                        opt.value = level;
                        opt.textContent = level == 'easy' ? 'Easy üòä' : level == 'medium' ? 'Medium üòê' : 'Hard üò§';
                        if (level == (toyDifficulties[toyKey] || 'medium')) opt.selected = true;
                        diffSelect.appendChild(opt);
                    });
                    
                    diffSelect.onchange = () => {
                        toyDifficulties[toyKey] = diffSelect.value;
                        applyPreset(toyKey, diffSelect.value);
                        saveGameState();
                    };
                    diffControls.appendChild(diffSelect);
                    
                    const isWearable = isToyWearable(toyId);
                    const hasAddRemove = toyHasAddRemoveTasks(toyKey);
                    const gearBtn = document.createElement('button');
                    gearBtn.className = 'gear-btn';
                    gearBtn.textContent = '‚öôÔ∏è';
                    gearBtn.title = !isWearable ? 'This toy cannot be worn/held' : !hasAddRemove ? 'This toy has no add/remove tasks' : 'Advanced Settings';
                    gearBtn.disabled = !isWearable || !hasAddRemove || !toyChecked[toyId] || !toySetEnabled[toyKey];
                    gearBtn.id = `gear_${toyKey}`;
                    
                    if (isWearable && hasAddRemove) {
                        gearBtn.onclick = (e) => {
                            e.preventDefault();
                            const advSettings = setItem.querySelector('.advanced-settings');
                            if (advSettings.classList.contains('visible')) {
                                advSettings.classList.remove('visible');
                                gearBtn.classList.remove('active');
                            } else {
                                advSettings.classList.add('visible');
                                gearBtn.classList.add('active');
                            }
                        };
                    }
                    diffControls.appendChild(gearBtn);
                    diffRow.appendChild(diffControls);
                    setItem.appendChild(diffRow);
                    
                    if (isWearable && hasAddRemove) {
                        const advSettings = document.createElement('div');
                        advSettings.className = 'advanced-settings';
                        
                        const addLabel = document.createElement('label');
                        addLabel.textContent = 'Add: ';
                        const addInput = document.createElement('input');
                        addInput.type = 'number';
                        addInput.min = '0';
                        addInput.max = '100';
                        // Show 0 if prison is locked, otherwise show stored value
                        addInput.value = (toyId === 'prison' && prisonLocked) ? 0 : (toyModifiers[toyKey]?.addChance || 10);
                        addInput.id = `add_${toyKey}`;
                        // Disable if locked or if toy/set disabled
                        addInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey] || (toyId === 'prison' && prisonLocked);
                        addInput.oninput = (e) => {
                            const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                            e.target.value = val;
                            if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                            toyModifiers[toyKey].addChance = val;
                            saveGameState();
                        };
                        addLabel.appendChild(addInput);
                        const addPercent = document.createTextNode('%');
                        addLabel.appendChild(addPercent);
                        advSettings.appendChild(addLabel);
                        
                        const removeLabel = document.createElement('label');
                        removeLabel.textContent = 'Remove: ';
                        const removeInput = document.createElement('input');
                        removeInput.type = 'number';
                        removeInput.min = '0';
                        removeInput.max = '100';
                        // Show 0 if prison is locked, otherwise show stored value
                        removeInput.value = (toyId === 'prison' && prisonLocked) ? 0 : (toyModifiers[toyKey]?.removeChance || 20);
                        removeInput.id = `remove_${toyKey}`;
                        // Disable if locked or if toy/set disabled
                        removeInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey] || (toyId === 'prison' && prisonLocked);
                        removeInput.oninput = (e) => {
                            const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                            e.target.value = val;
                            if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                            toyModifiers[toyKey].removeChance = val;
                            saveGameState();
                        };
                        removeLabel.appendChild(removeInput);
                        const removePercent = document.createTextNode('%');
                        removeLabel.appendChild(removePercent);
                        advSettings.appendChild(removeLabel);
                        
                        setItem.appendChild(advSettings);
                    }
                    
                    setDifficultyContainer.appendChild(setItem);
                });
                
                toyItem.appendChild(setDifficultyContainer);
            }
            
            container.appendChild(toyItem);
            
            // Apply locked state to inputs after rendering
            if (typeof updatePrisonInputStates === 'function') {
                updatePrisonInputStates();
            }
            
            continue; // Skip normal rendering for prison
        }
        
        const controls = document.createElement('div');
        controls.className = 'toy-controls';
        
        const qtyLabel = document.createElement('label');
        qtyLabel.textContent = 'Qty:';
        controls.appendChild(qtyLabel);
        
        const qtyInput = document.createElement('input');
        qtyInput.type = 'number';
        qtyInput.min = '1';
        qtyInput.value = toyQuantity;
        qtyInput.id = `qty_total_${toyId}`;
        qtyInput.disabled = !toyChecked[toyId];
        qtyInput.onchange = () => {
            const newQty = Math.max(1, parseInt(qtyInput.value) || 1);
            toyKeys.forEach(key => {
                toyQuantities[key] = newQty;
            });
            renderToyLibrary();
            saveGameState();
        };
        controls.appendChild(qtyInput);
        toyItem.appendChild(controls);
        
        const setDifficultyContainer = document.createElement('div');
        setDifficultyContainer.className = 'set-difficulty';
        
        toyData.sets.forEach(setInfo => {
            const toyKey = `${setInfo.setId}_${toyId}`;
            const setItem = document.createElement('div');
            setItem.className = 'set-difficulty-item';
            
            const diffRow = document.createElement('div');
            diffRow.className = 'difficulty-row';
            
            const setCheckboxWrapper = document.createElement('div');
            setCheckboxWrapper.style.cssText = 'display:flex;align-items:center;gap:8px;';
            
            const setCheckbox = document.createElement('input');
            setCheckbox.type = 'checkbox';
            setCheckbox.checked = toySetEnabled[toyKey];
            setCheckbox.style.cssText = 'width:16px;height:16px;cursor:pointer;accent-color:#667eea;';
            
            setCheckbox.disabled = !toyChecked[toyId];
            
            setCheckbox.onchange = () => {
                toySetEnabled[toyKey] = setCheckbox.checked;
                renderToyLibrary();
                saveGameState();
            };
            setCheckboxWrapper.appendChild(setCheckbox);
            
            const setNameSpan = document.createElement('span');
            setNameSpan.textContent = `${setInfo.emoji} ${setInfo.setName}`;
            setCheckboxWrapper.appendChild(setNameSpan);
            diffRow.appendChild(setCheckboxWrapper);
            
            const diffControls = document.createElement('div');
            diffControls.className = 'difficulty-controls';
            
            const diffSelect = document.createElement('select');
            diffSelect.id = `difficulty_${toyKey}`;
            diffSelect.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
            
            ['easy', 'medium', 'hard'].forEach(level => {
                const opt = document.createElement('option');
                opt.value = level;
                opt.textContent = level == 'easy' ? 'Easy üòä' : level == 'medium' ? 'Medium üòê' : 'Hard üò§';
                if (level == (toyDifficulties[toyKey] || 'medium')) opt.selected = true;
                diffSelect.appendChild(opt);
            });
            
            diffSelect.onchange = () => {
                toyDifficulties[toyKey] = diffSelect.value;
                applyPreset(toyKey, diffSelect.value);
                saveGameState();
            };
            diffControls.appendChild(diffSelect);
            
            const isWearable = isToyWearable(toyId);
            const hasAddRemove = toyHasAddRemoveTasks(toyKey);
            const gearBtn = document.createElement('button');
            gearBtn.className = 'gear-btn';
            gearBtn.textContent = '‚öôÔ∏è';
            gearBtn.title = !isWearable ? 'This toy cannot be worn/held' : !hasAddRemove ? 'This toy has no add/remove tasks' : 'Advanced Settings';
            gearBtn.disabled = !isWearable || !hasAddRemove || !toyChecked[toyId] || !toySetEnabled[toyKey];
            gearBtn.id = `gear_${toyKey}`;
            
            if (isWearable && hasAddRemove) {
                gearBtn.onclick = (e) => {
                    e.preventDefault();
                    const advSettings = setItem.querySelector('.advanced-settings');
                    if (advSettings.classList.contains('visible')) {
                        advSettings.classList.remove('visible');
                        gearBtn.classList.remove('active');
                    } else {
                        advSettings.classList.add('visible');
                        gearBtn.classList.add('active');
                    }
                };
            }
            diffControls.appendChild(gearBtn);
            diffRow.appendChild(diffControls);
            setItem.appendChild(diffRow);
            
            if (isWearable && hasAddRemove) {
                const advSettings = document.createElement('div');
                advSettings.className = 'advanced-settings';
                
                const addLabel = document.createElement('label');
                addLabel.textContent = 'Add: ';
                const addInput = document.createElement('input');
                addInput.type = 'number';
                addInput.min = '0';
                addInput.max = '100';
                addInput.value = toyModifiers[toyKey]?.addChance || 25;
                addInput.id = `add_${toyKey}`;
                addInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
                addInput.oninput = (e) => {
                    const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                    e.target.value = val;
                    if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                    toyModifiers[toyKey].addChance = val;
                    saveGameState();
                };
                addLabel.appendChild(addInput);
                const addPercent = document.createTextNode('%');
                addLabel.appendChild(addPercent);
                advSettings.appendChild(addLabel);
                
                const removeLabel = document.createElement('label');
                removeLabel.textContent = 'Remove: ';
                const removeInput = document.createElement('input');
                removeInput.type = 'number';
                removeInput.min = '0';
                removeInput.max = '100';
                removeInput.value = toyModifiers[toyKey]?.removeChance || 15;
                removeInput.id = `remove_${toyKey}`;
                removeInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
                removeInput.oninput = (e) => {
                    const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                    e.target.value = val;
                    if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                    toyModifiers[toyKey].removeChance = val;
                    saveGameState();
                };
                removeLabel.appendChild(removeInput);
                const removePercent = document.createTextNode('%');
                removeLabel.appendChild(removePercent);
                advSettings.appendChild(removeLabel);
                
                setItem.appendChild(advSettings);
            }
            
            setDifficultyContainer.appendChild(setItem);
        });
        
        toyItem.appendChild(setDifficultyContainer);
        container.appendChild(toyItem);
    }
    
    saveGameState();
}

function applyPreset(toyKey, difficulty) {
    const presets = {
        easy: {addChance: 5, removeChance: 25},
        medium: {addChance: 10, removeChance: 20},
        hard: {addChance: 15, removeChance: 15}
    };
    
    if (presets[difficulty]) {
        const [setId, ...toyIdParts] = toyKey.split('_');
        const toyId = toyIdParts.join('_');
        
        // If this is prison and it's locked, don't change add/remove values
        if (toyId === 'prison' && prisonLocked) {
            toyDifficulties[toyKey] = difficulty;
            // Don't update toyModifiers or inputs
            saveGameState();
            return;
        }
        
        toyModifiers[toyKey] = {...presets[difficulty]};
        toyDifficulties[toyKey] = difficulty;
        
        const addInput = document.getElementById(`add_${toyKey}`);
        const removeInput = document.getElementById(`remove_${toyKey}`);
        if (addInput) addInput.value = toyModifiers[toyKey].addChance;
        if (removeInput) removeInput.value = toyModifiers[toyKey].removeChance;
        
        saveGameState();
    }
}

// Event Listeners
document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => {
    cb.addEventListener('change', () => {
        renderToyLibrary();
        saveGameState();
    });
});

// Final Challenge probability sliders
const gesturesSlider = document.getElementById('gesturesSlider');
const vibraniumSlider = document.getElementById('vibraniumSlider');
const analyseSlider = document.getElementById('analyseSlider');

function updateFinalChallengeDisplays() {
    document.getElementById('gesturesPercent').textContent = finalChallengeSettings.gestures + '%';
    document.getElementById('vibraniumPercent').textContent = finalChallengeSettings.vibranium + '%';
    document.getElementById('analysePercent').textContent = finalChallengeSettings.analyse + '%';
    
    gesturesSlider.value = finalChallengeSettings.gestures;
    vibraniumSlider.value = finalChallengeSettings.vibranium;
    analyseSlider.value = finalChallengeSettings.analyse;
    
    saveGameState();
}

gesturesSlider.addEventListener('input', function() {
    const newGestures = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(finalChallengeSettings.analyse);
    finalChallengeSettings.gestures = newGestures > maxAllowed ? maxAllowed : newGestures;
    finalChallengeSettings.vibranium = 100 - finalChallengeSettings.analyse - finalChallengeSettings.gestures;
    updateFinalChallengeDisplays();
});

vibraniumSlider.addEventListener('input', function() {
    const newVibranium = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(finalChallengeSettings.analyse);
    finalChallengeSettings.vibranium = newVibranium > maxAllowed ? maxAllowed : newVibranium;
    finalChallengeSettings.gestures = 100 - finalChallengeSettings.analyse - finalChallengeSettings.vibranium;
    updateFinalChallengeDisplays();
});

analyseSlider.addEventListener('input', function() {
    const newAnalyse = Math.round(parseFloat(this.value));
    const available = 100 - newAnalyse;
    const currentTotal = Math.round(finalChallengeSettings.gestures) + Math.round(finalChallengeSettings.vibranium);
    
    // Changed: use equal split for BOTH directions (not just when increasing)
    if (available !== currentTotal) {
        const change = available - currentTotal;
        const half = change / 2;
        finalChallengeSettings.gestures = Math.max(0, Math.round(finalChallengeSettings.gestures + half));
        finalChallengeSettings.vibranium = Math.max(0, Math.round(finalChallengeSettings.vibranium + half));
        
        // Ensure total is exactly 100 by adjusting analyse if values were clamped
        const actualTotal = finalChallengeSettings.gestures + finalChallengeSettings.vibranium;
        finalChallengeSettings.analyse = Math.max(0, 100 - actualTotal);
    } else {
        finalChallengeSettings.analyse = Math.max(0, newAnalyse);
    }
    
    updateFinalChallengeDisplays();
});

// Final challenge type checkboxes
['gestures_ihot', 'gestures_icewater', 'gestures_spikeyband', 'gestures_squeezing', 'gestures_2finger',
 'vibranium_ihot', 'vibranium_icewater', 'analyse_vibranium'].forEach(id => {
    document.getElementById(id).addEventListener('change', function() {
        finalChallengeTypes[id] = this.checked;
        saveGameState();
    });
});

// Final challenge difficulty dropdowns
['gestures', 'vibranium', 'analyse'].forEach(type => {
    document.getElementById(`${type}Difficulty`).addEventListener('change', function() {
        finalChallengeDifficulties[type] = this.value;
        saveGameState();
    });
});

// Final challenge modifier checkboxes
['ce', 'pf'].forEach(mod => {
    document.getElementById(`modifier_${mod}`).addEventListener('change', function() {
        finalChallengeModifiers[mod] = this.checked;
        saveGameState();
    });
});

document.getElementById('playerNameInput').addEventListener('input', function() {
    playerName = this.value;
    saveGameState();
});

function startGame() {
    const toys = getSelectedToys();
    if (toys.length === 0) {
        alert('‚ö†Ô∏è Please select at least one toy from the instruction sets before starting!');
        return;
    }
    
    playerName = document.getElementById('playerNameInput').value.trim();
    if (!playerName) {
        alert('‚ö†Ô∏è Please enter your name before starting!');
        return;
    }
    
    // Add prison to Pe if "Start Worn" is checked
    if (prisonWorn && toyChecked['prison']) {
        addToyToBodyPart('Pe', 'prison');
    }
    
    gameStarted = true;
    saveGameState();
    
    startButton.style.display = 'none';
    const leftCol = document.querySelector('.settings-column-left');
    const rightCol = document.querySelector('.settings-column-right');
    if (leftCol) leftCol.style.display = 'none';
    if (rightCol) rightCol.style.display = 'none';
    
    instructions.classList.add('active');
    instructions.innerHTML = `
        <div style="font-size: 2em; font-weight: bold; color: #667eea; margin-bottom: 20px;">
            üçÄ Good Luck${playerName ? ' ' + playerName : ''}! üçÄ
        </div>
        <div style="font-size: 1.2em; color: #666; margin-bottom: 20px;">
            Roll the dice to begin!
        </div>
    `;
    
    rollDiceButton.style.display = 'block';
    diceResult.style.display = 'block';
    turnCounter.style.display = 'block';
    turnCounter.textContent = 'Turn: 0';
}

// Display final challenge task
function displayFinalChallenge() {
    // Roll prize type first (secretly)
    const prizeType = determinePrize();
    
    // Get condition helpers
    const conditionHelpers = getTaskConditions();
    
    // FIRST: Check for "always" tasks (priority tasks with specific conditions)
    const alwaysTasks = [];
    finalChallengeTasks.forEach((task, index) => {
        if (task.alwaysSelect && task.alwaysSelect(conditionHelpers)) {
            alwaysTasks.push({task, index});
        }
    });
    
    // If there are "always" tasks, randomly pick one
    if (alwaysTasks.length > 0) {
        const randomIndex = Math.floor(Math.random() * alwaysTasks.length);
        const selectedTask = alwaysTasks[randomIndex].task;
        const taskHTML = selectedTask.getDifficulty(null, conditionHelpers, toyDifficulties, prizeType);
        instructions.innerHTML = taskHTML;
        instructions.classList.add('active');
        return;
    }
    
    // SECOND: Get available regular tasks (check canSelect conditions)
    const availableTasks = [];
    finalChallengeTasks.forEach((task, index) => {
        // Skip if it's an "always" task (already checked above)
        if (task.alwaysSelect) return;
        
        if (!task.canSelect || task.canSelect(conditionHelpers)) {
            availableTasks.push({task, index});
        }
    });
    
    // Select random task from available
    let selectedTask;
    if (availableTasks.length > 0) {
        const randomIndex = Math.floor(Math.random() * availableTasks.length);
        selectedTask = availableTasks[randomIndex].task;
    } else {
        // Should never happen since fallback has no conditions, but safety fallback
        selectedTask = finalChallengeTasks[finalChallengeTasks.length - 1];
    }
    
    // Display the task with secret prize type
    const taskHTML = selectedTask.getDifficulty(null, conditionHelpers, toyDifficulties, prizeType);
    
    instructions.innerHTML = taskHTML;
    instructions.classList.add('active');
}

function rollDice() {
    rollDiceButton.disabled = true;
    turnCount++; // Increment turn counter
    const diceRoll = Math.floor(Math.random() * 6) + 1;
    diceResult.textContent = `Dice: ${diceRoll} üé≤`;
    turnCounter.textContent = `Turn: ${turnCount}`;

    
    let nextPosition = playerPosition + diceRoll;
    if (nextPosition > totalSquares) nextPosition = totalSquares;
    
    let finalPosition = nextPosition;
    let showContinueButton = false;
    
    const isSnake = snakes[nextPosition];
    const isLadder = ladders[nextPosition];
    
    if (isSnake || isLadder) {
        finalPosition = isSnake ? snakes[nextPosition] : ladders[nextPosition];
        showContinueButton = true;
    }
    
    const addRemoveTask = rollForAddRemoveTasks();
    
    animatePlayer(playerPosition, nextPosition, () => {
        playerPosition = nextPosition;
        
        if (addRemoveTask) {
            addRemoveTask.execute();
        }
        
        // If landed on snake or ladder, show that task immediately
        if (isSnake || isLadder) {
            displaySnakeLadderTask(isSnake ? 'snake' : 'ladder', nextPosition, finalPosition);
        } else {
            displayRandomInstructionWithAddRemove(addRemoveTask);
        }
        saveGameState();
        
        if (playerPosition === totalSquares) {
            rollDiceButton.disabled = true;
            displayFinalChallenge();
            return;
        }
        
        instructions.appendChild(continueButton);
        continueButton.style.display = "block";
        
        if (showContinueButton) {
            continueButton.onclick = () => {
                if (currentMetronomeTask && !currentMetronomeTask.isComplete()) return;
                continueButton.style.display = "none";
                animatePlayer(nextPosition, finalPosition, () => {
                    playerPosition = finalPosition;
                    if (playerPosition === totalSquares) {
                        rollDiceButton.disabled = true;
                        displayFinalChallenge();
                        saveGameState();
                    } else {
                        rollDiceButton.disabled = false;
                        // After sliding down/climbing up, show normal task
                        displayRandomInstruction();
                        saveGameState();
                    }
                }, true);
            };
        } else {
            continueButton.onclick = () => {
                if (currentMetronomeTask && !currentMetronomeTask.isComplete()) return;
                continueButton.style.display = "none";
                rollDiceButton.disabled = false;
            };
        }
    });
}

// Modal Functions
const modal = document.getElementById('patchNotesModal');
const btn = document.getElementById('patchNotesBtn');
const span = document.getElementsByClassName('close-btn')[0];

btn.onclick = () => modal.style.display = 'block';
span.onclick = () => modal.style.display = 'none';
window.onclick = e => {
    if (e.target == modal) modal.style.display = 'none';
};

// Reset Functions
const resetBtn = document.getElementById('resetBtn');
const resetModal = document.getElementById('resetModal');
const confirmResetBtn = document.getElementById('confirmReset');
const cancelResetBtn = document.getElementById('cancelReset');

resetBtn.addEventListener('click', () => resetModal.style.display = 'block');
cancelResetBtn.addEventListener('click', () => resetModal.style.display = 'none');

confirmResetBtn.addEventListener('click', function() {
    resetModal.style.display = 'none';
    localStorage.removeItem('snakesLaddersGameState');
    
    gameStarted = false;
    playerPosition = 0;
    turnCount = 0;
    turnCountBySet = {};
    turnCountByToy = {};
    lastSelectedSet = {};
    playerName = '';
    player.remove();
    bodyPartState = JSON.parse(JSON.stringify(bodyParts));
    prisonLocked = false;
    prisonWorn = false;
    
    startButton.style.display = 'block';
    rollDiceButton.style.display = 'none';
    rollDiceButton.disabled = false;
    continueButton.style.display = 'none';
    instructions.classList.remove('active');
    instructions.innerHTML = '';
    diceResult.textContent = 'Dice: -';
    diceResult.style.display = 'none';
    turnCounter.textContent = 'Turn: 0';
    turnCounter.style.display = 'none';
    
    document.getElementById('playerNameInput').value = '';
    
    const leftCol = document.querySelector('.settings-column-left');
    const rightCol = document.querySelector('.settings-column-right');
    if (leftCol) leftCol.style.display = 'block';
    if (rightCol) rightCol.style.display = 'block';
    
    document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => cb.checked = false);
    
    toySetEnabled = {};
    toyChecked = {};
    selectedSets = [];
    toyDifficulties = {};
    toyQuantities = {};
    toyModifiers = {};
    prizeSettings = {minor: 25, major: 10, noPrize: 65};
    
    updateSliderDisplays();
    renderToyLibrary();
});

// Test jump button for debugging
document.getElementById('testJumpButton').addEventListener('click', function() {
    if (!gameStarted) return;
    
    const targetSquare = parseInt(document.getElementById('testJumpInput').value);
    if (isNaN(targetSquare) || targetSquare < 1 || targetSquare > 100) {
        alert('Please enter a number between 1 and 100');
        return;
    }
    
    // Instant jump (no animation)
    playerPosition = targetSquare;
    const square = document.getElementById(`square-${targetSquare}`);
    if (square) square.appendChild(player);
    
    if (playerPosition === totalSquares) {
        rollDiceButton.disabled = true;
        displayFinalChallenge();
        saveGameState();
    } else {
        displayRandomInstruction();
        saveGameState();
    }
});

// Initialize
startButton.addEventListener('click', startGame);
rollDiceButton.addEventListener('click', rollDice);
createBoard();
renderToyLibrary();

loadGameState();
    </script>
</body>
</html>
