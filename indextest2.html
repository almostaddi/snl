<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snakes and Ladders</title>
    <style>
* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
}

body { 
    font-family: 'Segoe UI', sans-serif; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    min-height: 100vh; 
    padding: 20px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    color: #fff; 
}

h1 { 
    font-size: 3em; 
    margin-bottom: 30px; 
    text-shadow: 3px 3px 6px rgba(0,0,0,0.3); 
    animation: float 3s ease-in-out infinite; 
}

@keyframes float { 
    0%, 100% { transform: translateY(0); } 
    50% { transform: translateY(-10px); } 
}

#gameContainer { 
    background: rgba(255,255,255,0.95); 
    padding: 30px; 
    border-radius: 20px; 
    box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
    max-width: 1200px; 
    width: 100%; 
}

#board { 
    display: grid; 
    grid-template-columns: repeat(10, 1fr); 
    grid-template-rows: repeat(10, 1fr); 
    border: 4px solid #333; 
    border-radius: 15px; 
    margin: 0 auto 20px; 
    width: 100%; 
    max-width: 700px; 
    aspect-ratio: 1; 
    background: #fff; 
    box-shadow: inset 0 0 20px rgba(0,0,0,0.1); 
    overflow: hidden; 
}

.square { 
    display: flex; 
    justify-content: center; 
    align-items: center; 
    border: 1px solid rgba(0,0,0,0.1); 
    background: linear-gradient(135deg, #e0f7fa 0%, #b2ebf2 100%); 
    font-weight: bold; 
    font-size: 0.9em; 
    color: #333; 
    position: relative; 
    transition: all 0.3s ease; 
}

.square:hover { 
    transform: scale(1.05); 
    z-index: 5; 
}

.snake { 
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); 
    color: white; 
}

.snake::before { 
    content: 'üêç'; 
    position: absolute; 
    font-size: 3em; 
    opacity: 0.3; 
}

.snake::after { 
    content: attr(data-destination); 
    position: absolute; 
    bottom: 2px; 
    right: 2px; 
    background: rgba(0,0,0,0.7); 
    color: white; 
    font-size: 0.7em; 
    padding: 2px 5px; 
    border-radius: 5px; 
    font-weight: bold; 
}

.ladder { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    color: white; 
}

.ladder::before { 
    content: 'ü™ú'; 
    position: absolute; 
    font-size: 3em; 
    opacity: 0.3; 
}

.ladder::after { 
    content: attr(data-destination); 
    position: absolute; 
    top: 2px; 
    right: 2px; 
    background: rgba(0,0,0,0.7); 
    color: white; 
    font-size: 0.7em; 
    padding: 2px 5px; 
    border-radius: 5px; 
    font-weight: bold; 
}

.player { 
    width: 30px; 
    height: 30px; 
    background: radial-gradient(circle, #4dabf7 0%, #1864ab 100%); 
    border-radius: 50%; 
    position: absolute; 
    z-index: 10; 
    box-shadow: 0 4px 8px rgba(0,0,0,0.3); 
    animation: pulse 1s ease-in-out infinite; 
    border: 3px solid white; 
}

@keyframes pulse { 
    0%, 100% { transform: scale(1); } 
    50% { transform: scale(1.1); } 
}

#controls { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 15px; 
    margin-bottom: 20px; 
}

button { 
    padding: 15px 40px; 
    font-size: 20px; 
    font-weight: bold; 
    cursor: pointer; 
    color: white; 
    border: none; 
    border-radius: 50px; 
    transition: all 0.3s ease; 
    text-transform: uppercase; 
    letter-spacing: 1px; 
}

#startButton { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    box-shadow: 0 8px 20px rgba(81,207,102,0.4); 
}

#startButton:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 12px 25px rgba(81,207,102,0.5); 
}

#rollDice { 
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
    box-shadow: 0 8px 20px rgba(79,172,254,0.4); 
}

#rollDice:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 12px 25px rgba(79,172,254,0.5); 
}

button:disabled { 
    background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); 
    cursor: not-allowed; 
    box-shadow: none; 
}

#diceResult { 
    font-size: 28px; 
    font-weight: bold; 
    padding: 15px 30px; 
    background: linear-gradient(135deg, #ffd93d 0%, #ffbc00 100%); 
    border-radius: 15px; 
    color: #333; 
    box-shadow: 0 4px 15px rgba(255,188,0,0.3); 
    min-width: 150px; 
    text-align: center; 
}

#instructions { 
    margin-top: 20px; 
    font-size: 18px; 
    text-align: left; 
    min-height: 80px; 
    padding: 50px 80px; 
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); 
    border-radius: 15px; 
    color: #333; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.1); 
    display: none; 
    line-height: 1.8; 
    max-width: 900px; 
    margin-left: auto; 
    margin-right: auto; 
}

#instructions.active { 
    display: block; 
}

#instructions img { 
    margin: 40px 0; 
    max-width: 100%; 
    height: auto; 
    border-radius: 10px; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.2); 
}

#instructions p { 
    margin: 25px 0; 
    font-size: 17px; 
    line-height: 2; 
}

#instructions strong { 
    font-size: 26px; 
    display: block; 
    margin-bottom: 20px; 
    text-align: center; 
    color: #667eea; 
}

#continueButton { 
    margin-top: 15px; 
    padding: 12px 30px; 
    font-size: 18px; 
    background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); 
    box-shadow: 0 6px 20px rgba(250,82,82,0.4); 
    display: block; 
    margin-left: auto; 
    margin-right: auto; 
}

#continueButton:hover { 
    transform: translateY(-2px); 
    box-shadow: 0 8px 25px rgba(250,82,82,0.5); 
}

#buttoncontainer { 
    margin-top: 20px; 
    display: flex; 
    gap: 15px; 
    justify-content: center; 
    flex-wrap: wrap; 
    width: 100%; 
}

.settings-column-left, .settings-column-right { 
    width: 100%; 
    max-width: 900px; 
}

.settings-column-left {
    margin-bottom: 400px;
}

@media (min-width: 900px) {
    #buttoncontainer { 
        max-width: 1200px; 
        margin-left: auto; 
        margin-right: auto; 
        flex-wrap: nowrap; 
    }
    .settings-column-left { 
        width: 50%; 
        max-width: none; 
    }
    .settings-column-right { 
        width: 50%; 
        max-width: none; 
    }
}

.prize-settings { 
    margin-top: 0px; 
    padding: 20px; 
    background: white; 
    border-radius: 15px; 
    border: 2px solid #667eea; 
}

.prize-settings h3 { 
    color: #667eea; 
    margin-bottom: 15px; 
    text-align: center; 
    display: none;
}

.slider-container { 
    margin: 15px 0; 
}

.slider-label { 
    display: flex; 
    justify-content: space-between; 
    margin-bottom: 5px; 
    color: #333; 
    font-weight: bold; 
}

.slider-label .percentage { 
    color: #667eea; 
}

input[type="range"] { 
    width: 100%; 
    height: 8px; 
    border-radius: 5px; 
    outline: none; 
    -webkit-appearance: none; 
}

input[type="range"]::-webkit-slider-thumb { 
    -webkit-appearance: none; 
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #667eea; 
    cursor: pointer; 
}

input[type="range"]::-moz-range-thumb { 
    width: 20px; 
    height: 20px; 
    border-radius: 50%; 
    background: #667eea; 
    cursor: pointer; 
}

#minorSlider { 
    background: linear-gradient(to right, #51cf66, #37b24d); 
}

#majorSlider { 
    background: linear-gradient(to right, #ffd93d, #ffbc00); 
}

#noPrizeSlider { 
    background: linear-gradient(to right, #adb5bd, #868e96); 
}

.toy-library-item { 
    border: 2px solid #e9ecef; 
    border-radius: 10px; 
    padding: 8px; 
    margin-bottom: 8px; 
    transition: all 0.3s ease; 
}

.toy-library-item:hover { 
    border-color: #667eea; 
    box-shadow: 0 4px 12px rgba(102,126,234,0.2); 
}

.toy-header { 
    display: flex; 
    align-items: center; 
    gap: 10px; 
    font-size: 1em; 
    font-weight: bold; 
    color: #333; 
    margin-bottom: 6px; 
}

.toy-checkbox-wrapper { 
    display: flex; 
    align-items: center; 
}

.toy-checkbox-wrapper input[type="checkbox"] { 
    width: 18px; 
    height: 18px; 
    margin: 0; 
    cursor: pointer; 
    accent-color: #51cf66; 
}

.toy-name { 
    flex: 1; 
}

.toy-controls { 
    display: flex; 
    gap: 8px; 
    align-items: center; 
    flex-wrap: wrap; 
    margin-left: 28px; 
    margin-bottom: 6px; 
}

.toy-controls label { 
    font-size: 0.85em; 
    color: #333; 
    font-weight: 600; 
}

.toy-controls input[type="number"] { 
    width: 55px; 
    padding: 4px; 
    border: 2px solid #667eea; 
    border-radius: 6px; 
    text-align: center; 
}

.set-difficulty { 
    margin-left: 28px; 
    padding: 6px; 
    background: #f8f9fa; 
    border-radius: 6px; 
    margin-top: 6px; 
}

.toy-controls input[type="number"]:disabled { 
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.difficulty-row select:disabled {
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.advanced-settings input:disabled {
    opacity: 0.5;
    cursor: default;
    background: #f8f9fa;
}

.set-difficulty input[type="checkbox"]:disabled {
    opacity: 0.5;
    cursor: default;
}

.set-difficulty input[type="checkbox"]:disabled + span,
.set-difficulty-item:has(input[type="checkbox"]:disabled) {
    opacity: 0.5;
}

.set-difficulty-item { 
    padding: 4px 0; 
    border-bottom: 1px solid #e9ecef; 
}

.set-difficulty-item:last-child { 
    border-bottom: none; 
}

.difficulty-row { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
}

.difficulty-row > span { 
    font-weight: 600; 
    color: #495057; 
    font-size: 0.9em; 
}

.difficulty-controls { 
    display: flex; 
    gap: 8px; 
    align-items: center; 
}

.difficulty-row select { 
    padding: 3px 6px; 
    border: 2px solid #667eea; 
    border-radius: 4px; 
    background: white; 
    color: #333; 
    cursor: pointer; 
    font-size: 0.9em; 
}

.gear-btn { 
    background: #667eea; 
    color: white; 
    border: none; 
    width: 24px; 
    height: 24px; 
    border-radius: 6px; 
    cursor: pointer; 
    font-size: 12px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    transition: background 0.2s ease; 
}

.gear-btn:hover { 
    background: #5568d3; 
}

.gear-btn.active { 
    background: #51cf66; 
}

.gear-btn:disabled { 
    background: #adb5bd; 
    cursor: default; 
    opacity: 0.5; 
}

.gear-btn:disabled:hover { 
    background: #adb5bd; 
}

.advanced-settings { 
    margin-left: 20px; 
    padding: 6px 10px; 
    background: white; 
    border-radius: 4px; 
    border-left: 3px solid #667eea; 
    font-size: 0.8em; 
    color: #666; 
    display: none; 
    gap: 12px; 
    margin-top: 6px; 
}

.advanced-settings.visible { 
    display: flex; 
}

.advanced-settings label { 
    display: flex; 
    align-items: center; 
    gap: 4px; 
}

.advanced-settings input { 
    width: 45px; 
    padding: 2px 4px; 
    border: 1px solid #dee2e6; 
    border-radius: 3px; 
    text-align: center; 
}

#toyLibraryContainer { 
    background: white; 
    border-radius: 10px; 
    padding: 15px; 
    color: #333;
}

.metronome-container { 
    margin: 20px 0; 
    padding: 20px; 
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
    border-radius: 15px; 
    box-shadow: 0 4px 15px rgba(79,172,254,0.3); 
}

.metronome-display { 
    font-size: 48px; 
    font-weight: bold; 
    color: white; 
    text-align: center; 
    margin: 15px 0; 
    min-height: 60px; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
}

.metronome-beat { 
    width: 80px; 
    height: 80px; 
    border-radius: 50%; 
    background: rgba(255,255,255,0.3); 
    margin: 0 auto; 
    transition: all 0.1s ease; 
}

.metronome-beat.active { 
    background: white; 
    transform: scale(1.2); 
    box-shadow: 0 0 20px rgba(255,255,255,0.8); 
}

.metronome-btn { 
    padding: 12px 30px; 
    font-size: 18px; 
    background: white; 
    color: #4facfe; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.2); 
    margin: 10px auto; 
    display: block; 
}

.metronome-btn:hover:not(:disabled) { 
    transform: translateY(-2px); 
    box-shadow: 0 6px 20px rgba(0,0,0,0.3); 
}

.metronome-btn:disabled { 
    opacity: 0.5; 
}

.modal { 
    display: none; 
    position: fixed; 
    z-index: 2000; 
    left: 0; 
    top: 0; 
    width: 100%; 
    height: 100%; 
    background-color: rgba(0,0,0,0.7); 
    backdrop-filter: blur(5px); 
    padding-top: 60px; 
}

.modal-content { 
    background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); 
    margin: 5% auto; 
    padding: 30px; 
    width: 80%; 
    max-width: 600px; 
    border-radius: 20px; 
    box-shadow: 0 20px 60px rgba(0,0,0,0.4); 
    color: #333; 
}

.modal-content h2 { 
    color: #667eea; 
    margin-bottom: 20px; 
}

.modal-content p { 
    line-height: 1.8; 
    margin-bottom: 15px; 
}

.close-btn { 
    color: #aaa; 
    float: right; 
    font-size: 32px; 
    font-weight: bold; 
    cursor: pointer; 
    transition: all 0.3s ease; 
}

.close-btn:hover { 
    color: #667eea; 
    transform: rotate(90deg); 
}

#patchNotesBtn, #resetBtn { 
    position: fixed; 
    top: 20px; 
    padding: 10px 20px; 
    font-size: 14px; 
    font-weight: 600; 
    z-index: 10; 
}

#patchNotesBtn { 
    right: 20px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    box-shadow: 0 4px 15px rgba(102,126,234,0.4); 
}

#resetBtn { 
    left: 20px; 
    background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); 
    box-shadow: 0 4px 15px rgba(250,82,82,0.4); 
}

.prize-result { 
    font-size: 2em; 
    text-align: center; 
    margin: 20px 0; 
    padding: 30px; 
    border-radius: 15px; 
    animation: prizeReveal 0.5s ease-out; 
}

@keyframes prizeReveal { 
    0% { transform: scale(0); opacity: 0; } 
    50% { transform: scale(1.2); } 
    100% { transform: scale(1); opacity: 1; } 
}

.prize-minor { 
    background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%); 
    color: white; 
}

.prize-major { 
    background: linear-gradient(135deg, #ffd93d 0%, #ffbc00 100%); 
    color: #333; 
}

.prize-none { 
    background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); 
    color: white; 
}

.instruction-set-selector { 
    background: white; 
    border-radius: 10px; 
    padding: 15px; 
    border: 2px solid #667eea; 
    margin-bottom: 15px; 
}

.instruction-set-selector label { 
    display: block; 
    padding: 8px; 
    cursor: pointer; 
    color: #333; 
}

.instruction-set-selector input[type="checkbox"] { 
    margin-right: 10px; 
    width: 18px; 
    height: 18px; 
    accent-color: #667eea; 
}

@media (max-width: 600px) { 
    h1 { 
        font-size: 2em; 
    } 
    #gameContainer { 
        padding: 20px; 
    } 
    .square { 
        font-size: 0.7em; 
    } 
    .player { 
        width: 20px; 
        height: 20px; 
    } 
}
    </style>
</head>
<body>
    <h1>üé≤ Snakes and Ladders üé≤</h1>
    <div id="gameContainer">
        <div id="board"></div>
        <div id="controls">
            <button id="startButton">üéÆ Start Game</button>
            <button id="rollDice" style="display: none;">üé≤ Roll Dice</button>
            <div id="diceResult" style="display: none;">Dice: -</div>
        </div>
        <div id="instructions"></div>
        <div id="buttoncontainer">
            <div class="settings-column-left">
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üë§ Player Name:</label>
                <input type="text" id="playerNameInput" placeholder="Enter your name" style="width: 100%; padding: 12px; border: 2px solid #667eea; border-radius: 10px; font-size: 16px; margin-bottom: 15px; box-sizing: border-box;">
                
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üì¶ Select Instruction Sets:</label>
                <div id="instructionSetCheckboxes" class="instruction-set-selector">
                    <label><input type="checkbox" value="apple"> Analyse Set üçé</label>
                    <label><input type="checkbox" value="digging"> Deepthread Set ‚õèÔ∏è</label>
                    <label><input type="checkbox" value="dressup"> Pinplay Set üé®</label>
                    <label><input type="checkbox" value="tnd"> TnD üéØ</label>
                </div>

                <div id="toyLibraryContainer"></div>
            </div>
            
            <div class="settings-column-right">
                <label style="display: block; font-weight: bold; color: #333; margin-bottom: 10px; background: white; padding: 10px; border-radius: 8px;">üéÅ Prize Probabilities:</label>
                <div class="prize-settings">
                    <h3>üéÅ Prize Probabilities</h3>
                    <div class="slider-container">
                        <div class="slider-label"><span>üèÜ Major:</span><span class="percentage" id="majorPercent">10%</span></div>
                        <input type="range" id="majorSlider" min="0" max="100" value="10">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>üéâ Minor:</span><span class="percentage" id="minorPercent">25%</span></div>
                        <input type="range" id="minorSlider" min="0" max="100" value="25">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label"><span>‚ùå None:</span><span class="percentage" id="noPrizePercent">65%</span></div>
                        <input type="range" id="noPrizeSlider" min="0" max="100" value="65">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <button id="resetBtn">üîÑ Reset</button>
    <button id="patchNotesBtn">üìã Notes</button>
    
    <div id="patchNotesModal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>üìã Patch Notes</h2>
            <p><strong>Ver 0.5:</strong> Modifier system with add/remove chances & toy quantities</p>
        </div>
    </div>
    
    <div id="resetModal" class="modal">
        <div class="modal-content">
            <h2>‚ö†Ô∏è Reset Game?</h2>
            <p style="font-size: 18px; margin: 20px 0;">You will lose all progress!</p>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                <button id="confirmReset" style="padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #fa5252 0%, #e03131 100%); color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold;">Yes</button>
                <button id="cancelReset" style="padding: 12px 30px; font-size: 16px; background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%); color: white; border: none; border-radius: 50px; cursor: pointer; font-weight: bold;">Cancel</button>
            </div>
        </div>
    </div>
    
    <script>
// DOM Elements
const board = document.getElementById('board');
const diceResult = document.getElementById('diceResult');
const instructions = document.getElementById('instructions');
const startButton = document.getElementById('startButton');
const rollDiceButton = document.getElementById('rollDice');
const continueButton = document.createElement('button');
continueButton.id = "continueButton";
continueButton.textContent = "‚úì Complete";

// Game Constants
const boardSize = 10;
const totalSquares = 100;
const player = document.createElement('div');
player.classList.add('player');

const snakes = {16:6, 47:26, 49:11, 56:53, 62:19, 64:60, 87:24, 93:73, 95:75, 98:78};
const ladders = {1:38, 4:14, 9:31, 21:42, 28:84, 36:44, 51:67, 71:91, 80:99};

// Game State
let audioContext = null;
let currentMetronomeTask = null;
let toyDifficulties = {};
let gameStarted = false;
let playerPosition = 0;
let selectedSets = [];
let toySelections = {};
let prizeSettings = {major: 20, minor: 30, noPrize: 50};
let toyQuantities = {};
let toyModifiers = {};
let advancedSettingsOpen = false;
let playerName = '';
let toySetEnabled = {};
let toyChecked = {};

// Body part capacity system
const bodyParts = {
    Mo: { name: "Mo", capacity: 1, occupied: 0, items: [] },
    Ba: { name: "Ba", capacity: 1, occupied: 0, items: [] },
    Bu: { name: "Bu", capacity: 1, occupied: 0, items: [] },
    As: { name: "As", capacity: 1, occupied: 0, items: [] },
    Ni: { name: "Ni", capacity: 1, occupied: 0, items: [] },
    Ha: { name: "Ha", capacity: 1, occupied: 0, items: [] },
    Bo: { name: "Bo", capacity: 1, occupied: 0, items: [] }
};

const toyCapacity = {
    basketball: 1,
    soccerball: 1,
    jumprope: 1,
    climbingrope: 1,
    stickers: 0.05,
    silly_shirt: 1,
    wristband: 1,
    hand: 1,
    stick_a: 1,
    stick_m: 1,
    metal_stick: 1,
    tail: 1,
    vibranium: 1
};

function isToyWearable(toyId) {
    return toyCapacity.hasOwnProperty(toyId);
}

let bodyPartState = JSON.parse(JSON.stringify(bodyParts));

function getTaskConditions() {
    return {
        name: playerName || 'Player',
        isHolding: (toyId) => {
            for (const part of Object.values(bodyPartState)) {
                if (part.items.includes(toyId)) return true;
            }
            return false;
        },
        getBodyPartsHolding: (toyId) => {
            const parts = [];
            for (const [partKey, part] of Object.entries(bodyPartState)) {
                if (part.items.includes(toyId)) {
                    parts.push({ key: partKey, name: part.name });
                }
            }
            return parts;
        },
        isBodyPartOccupied: (bodyPartKey) => {
            return bodyPartState[bodyPartKey] && bodyPartState[bodyPartKey].occupied > 0;
        },
        canBodyPartHold: (bodyPartKey, toyId) => {
            return canAddToyToBodyPart(bodyPartKey, toyId);
        },
        getAllHeldItems: () => {
            const items = [];
            for (const part of Object.values(bodyPartState)) {
                items.push(...part.items);
            }
            return items;
        },
        getBodyPartState: () => bodyPartState
    };
}

// Instruction Sets
const instructionSets = {
    dressup: {
        name: "Pinplay Set",
        toys: [
            {id: "stickers", name: "Clothestickers üé®"},
            {id: "silly_shirt", name: "Clampshirt üëï"},
            {id: "wristband", name: "Spikeyband ‚åö"},
            {id: "hand", name: "Hand ‚úã"},
            {id: "vibranium", name: "Vibranium üíé"}
        ],
        tasks: {
            stickers: [
                {getDifficulty: d => `<strong>Clothesticker Challenge</strong><p>Apply ${d=='easy'?3:d=='medium'?5:8} clothestickers to yourself.</p><img src="https://picsum.photos/seed/sticker1/800/600"/>`},
                {type: 'add'},
                {type: 'remove'}
            ],
            silly_shirt: [
                {getDifficulty: d => `<strong>Wear the Clampshirt</strong><p>Put on the clampshirt and pose for ${d=='easy'?5:d=='medium'?10:15} seconds.</p><img src="https://picsum.photos/seed/shirt1/800/600"/>`},
                {type: 'add'},
                {type: 'remove'}
            ],
            wristband: [
                {getDifficulty: d => `<strong>Spikeyband Spin</strong><p>Spin the spikeyband around your wrist ${d=='easy'?5:d=='medium'?10:15} times.</p><img src="https://picsum.photos/seed/wrist1/800/600"/>`}
            ],
            hand: [
                {getDifficulty: d => `<strong>Hand Wave</strong><p>Wave your hand ${d=='easy'?10:d=='medium'?15:20} times.</p><img src="https://picsum.photos/seed/hand1/800/600"/>`},
                {type: 'redlight', getDifficulty: d => d=='easy'?15000:d=='medium'?20000:25000}
            ],
            vibranium: [
                {getDifficulty: d => `<strong>Vibranium Hold</strong><p>Hold the vibranium steady for ${d=='easy'?5:d=='medium'?10:15} seconds.</p><img src="https://picsum.photos/seed/vibranium1/800/600"/>`}
            ]
        }
    },
    apple: {
        name: "Analyse Set",
        toys: [
            {id: "stick_a", name: "Dillstick A ü™µ"},
            {id: "metal_stick", name: "Metal Dillstick üî©"},
            {id: "tail", name: "Plugtail ü¶ä"},
            {id: "vibranium", name: "Vibranium üíé"}
        ],
        tasks: {
            stick_a: [
                {getDifficulty: d => `<strong>Dillstick A Balance</strong><p>Balance the dillstick A on your hand for ${d=='easy'?3:d=='medium'?5:8} seconds.</p><img src="https://picsum.photos/seed/stick1/800/600"/>`},
                {type: 'add'},
                {type: 'remove'}
            ],
            metal_stick: [
                {getDifficulty: d => `<strong>Metal Dillstick Tap</strong><p>Tap the metal dillstick on the ground ${d=='easy'?10:d=='medium'?15:20} times.</p><img src="https://picsum.photos/seed/metal1/800/600"/>`},
                {type: 'add'},
                {type: 'remove'}
            ],
            tail: [
                {getDifficulty: d => `<strong>Plugtail Wag</strong><p>Wag your plugtail ${d=='easy'?5:d=='medium'?10:15} times.</p><img src="https://picsum.photos/seed/tail1/800/600"/>`},
                {type: 'add'},
                {type: 'remove'}
            ],
            vibranium: [
                {getDifficulty: d => `<strong>Vibranium Shake</strong><p>Shake the vibranium ${d=='easy'?5:d=='medium'?10:15} times.</p><img src="https://picsum.photos/seed/vibranium2/800/600"/>`}
            ]
        }
    },
    digging: {
        name: "Deepthread Set",
        toys: [
            {id: "stick_m", name: "Dillstick M ü™µ"},
            {id: "hand", name: "Hand ‚úã"}
        ],
        tasks: {
            stick_m: [
                {getDifficulty: d => `<strong>Dig with Dillstick M</strong><p>Use the dillstick M to make ${d=='easy'?3:d=='medium'?5:8} digging motions.</p><img src="https://picsum.photos/seed/dig1/800/600"/>`},
                {type: 'add'},
                {type: 'remove'}
            ],
            hand: [
                {getDifficulty: d => `<strong>Hand Digging</strong><p>Make digging motions with your hands ${d=='easy'?10:d=='medium'?15:20} times.</p><img src="https://picsum.photos/seed/dighand1/800/600"/>`}
            ]
        }
    },
    tnd: {
        name: "TnD",
        toys: [
            {id: "vibranium", name: "Vibranium üíé"},
            {id: "hand", name: "Hand ‚úã"}
        ],
        tasks: {
            vibranium: [
                {getDifficulty: d => `<strong>Vibranium Control</strong><p>Control the vibranium settings for ${d=='easy'?10:d=='medium'?20:30} seconds.</p><img src="https://picsum.photos/seed/vibranium3/800/600"/>`}
            ],
            hand: [
                {getDifficulty: d => `<strong>Hand Gesture</strong><p>Make hand gestures ${d=='easy'?8:d=='medium'?12:16} times.</p><img src="https://picsum.photos/seed/handtnd1/800/600"/>`}
            ]
        }
    }
};

// Storage Functions
function saveGameState() {
    localStorage.setItem('snakesLaddersGameState', JSON.stringify({
        gameStarted,
        playerPosition,
        selectedSets,
        toySelections,
        toyDifficulties,
        prizeSettings,
        toyQuantities,
        toyModifiers,
        advancedSettingsOpen,
        bodyPartState,
        playerName,
        toySetEnabled,
        toyChecked,
        diceResultText: diceResult.textContent,
        currentInstruction: instructions.innerHTML,
        instructionsActive: instructions.classList.contains('active'),
        lastTaskInfo: window.lastTaskInfo || null
    }));
}

function loadGameState() {
    const saved = localStorage.getItem('snakesLaddersGameState');
    if (!saved) return false;
    
    try {
        const gs = JSON.parse(saved);
        gameStarted = gs.gameStarted;
        playerPosition = gs.playerPosition;
        selectedSets = gs.selectedSets || [];
        toySelections = gs.toySelections || {};
        toyDifficulties = gs.toyDifficulties || {};
        toyQuantities = gs.toyQuantities || {};
        toyModifiers = gs.toyModifiers || {};
        advancedSettingsOpen = gs.advancedSettingsOpen || false;
        playerName = gs.playerName || '';
        toySetEnabled = gs.toySetEnabled || {};
        toyChecked = gs.toyChecked || {};
        
        if (gs.bodyPartState) {
            bodyPartState = gs.bodyPartState;
        }
        
        if (gs.prizeSettings) {
            prizeSettings = gs.prizeSettings;
            updateSliderDisplays(true);
        }
        
        document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => {
            cb.checked = selectedSets.includes(cb.value);
        });
        
        if (gameStarted) {
            startButton.style.display = 'none';
            rollDiceButton.style.display = 'block';
            diceResult.style.display = 'block';
            diceResult.textContent = gs.diceResultText || 'Dice: -';
            
            const leftCol = document.querySelector('.settings-column-left');
            const rightCol = document.querySelector('.settings-column-right');
            if (leftCol) leftCol.style.display = 'none';
            if (rightCol) rightCol.style.display = 'none';
            
            createBoard();
            
            if (playerPosition > 0) {
                const sq = document.getElementById(`square-${playerPosition}`);
                if (sq) sq.appendChild(player);
            }
            
            if (gs.lastTaskInfo && gs.lastTaskInfo.taskType) {
                window.lastTaskInfo = gs.lastTaskInfo;
                instructions.classList.add('active');
                
                if (gs.lastTaskInfo.taskType === 'metronome') {
                    currentMetronomeTask = createMetronomeTask(gs.lastTaskInfo.beatCount);
                    instructions.innerHTML = '';
                    instructions.appendChild(currentMetronomeTask.element);
                } else if (gs.lastTaskInfo.taskType === 'redlight') {
                    currentMetronomeTask = createRedLightGreenLightTask(gs.lastTaskInfo.duration);
                    instructions.innerHTML = '';
                    instructions.appendChild(currentMetronomeTask.element);
                } else if (gs.currentInstruction) {
                    instructions.innerHTML = gs.currentInstruction;
                }
            } else if (gs.currentInstruction && gs.currentInstruction.trim() !== '') {
                instructions.innerHTML = gs.currentInstruction;
                if (gs.instructionsActive) instructions.classList.add('active');
            }
        } else {
            document.getElementById('playerNameInput').value = playerName;
            renderToyLibrary();
        }
        
        return true;
    } catch (e) {
        console.error('Load error:', e);
        return false;
    }
}

// Prize Functions
function updateSliderDisplays(skipSave = false) {
    prizeSettings.minor = Math.round(prizeSettings.minor * 10) / 10;
    prizeSettings.major = Math.round(prizeSettings.major * 10) / 10;
    prizeSettings.noPrize = Math.round(prizeSettings.noPrize * 10) / 10;
    
    document.getElementById('minorPercent').textContent = prizeSettings.minor.toFixed(1) + '%';
    document.getElementById('majorPercent').textContent = prizeSettings.major.toFixed(1) + '%';
    document.getElementById('noPrizePercent').textContent = prizeSettings.noPrize.toFixed(1) + '%';
    
    document.getElementById('minorSlider').value = prizeSettings.minor;
    document.getElementById('majorSlider').value = prizeSettings.major;
    document.getElementById('noPrizeSlider').value = prizeSettings.noPrize;
    
    if (!skipSave) saveGameState();
}

document.getElementById('minorSlider').addEventListener('input', function() {
    const newMinor = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(prizeSettings.major);
    prizeSettings.minor = newMinor > maxAllowed ? maxAllowed : newMinor;
    prizeSettings.noPrize = 100 - prizeSettings.minor - prizeSettings.major;
    updateSliderDisplays();
});

document.getElementById('majorSlider').addEventListener('input', function() {
    const newMajor = Math.round(parseFloat(this.value));
    const maxAllowed = 100 - Math.round(prizeSettings.minor);
    prizeSettings.major = newMajor > maxAllowed ? maxAllowed : newMajor;
    prizeSettings.noPrize = 100 - prizeSettings.minor - prizeSettings.major;
    updateSliderDisplays();
});

document.getElementById('noPrizeSlider').addEventListener('input', function() {
    const newNoPrize = Math.round(parseFloat(this.value));
    const available = 100 - newNoPrize;
    const currentTotal = Math.round(prizeSettings.minor) + Math.round(prizeSettings.major);
    
    if (available < currentTotal && currentTotal > 0) {
        const reduction = currentTotal - available;
        const minorProp = prizeSettings.minor / currentTotal;
        const majorProp = prizeSettings.major / currentTotal;
        prizeSettings.minor = Math.max(0, Math.round(prizeSettings.minor - reduction * minorProp));
        prizeSettings.major = Math.max(0, Math.round(prizeSettings.major - reduction * majorProp));
    } else if (available > currentTotal) {
        const increase = available - currentTotal;
        const half = increase / 2;
        prizeSettings.minor = Math.round(prizeSettings.minor + half);
        prizeSettings.major = Math.round(prizeSettings.major + half);
    }
    
    prizeSettings.noPrize = newNoPrize;
    updateSliderDisplays();
});

function determinePrize() {
    const roll = Math.random() * 100;
    return roll < prizeSettings.major ? 'major' : 
           roll < prizeSettings.major + prizeSettings.minor ? 'minor' : 'none';
}

function displayPrizeResult(prize) {
    return prize === 'major' ? 
        '<div class="prize-result prize-major">üèÜ MAJOR PRIZE! üèÜ<br>Congratulations!</div>' :
        prize === 'minor' ? 
        '<div class="prize-result prize-minor">üéâ Minor Prize! üéâ<br>Nice job!</div>' :
        '<div class="prize-result prize-none">‚ùå No Prize<br>Better luck next time!</div>';
}

// Body Part Functions
function canAddToyToBodyPart(bodyPart, toyId) {
    const toySize = toyCapacity[toyId] || 0;
    const available = bodyPartState[bodyPart].capacity - bodyPartState[bodyPart].occupied;
    return available >= toySize;
}

function addToyToBodyPart(bodyPart, toyId) {
    const toySize = toyCapacity[toyId] || 0;
    if (canAddToyToBodyPart(bodyPart, toyId)) {
        bodyPartState[bodyPart].occupied += toySize;
        bodyPartState[bodyPart].items.push(toyId);
        saveGameState();
        return true;
    }
    return false;
}

function removeToyFromBodyPart(bodyPart, toyId) {
    const index = bodyPartState[bodyPart].items.indexOf(toyId);
    if (index > -1) {
        const toySize = toyCapacity[toyId] || 0;
        bodyPartState[bodyPart].occupied -= toySize;
        bodyPartState[bodyPart].items.splice(index, 1);
        saveGameState();
        return true;
    }
    return false;
}

function getAvailableBodyPartsForToy(toyId) {
    const toySize = toyCapacity[toyId] || 0;
    const available = [];
    
    for (const [partKey, part] of Object.entries(bodyPartState)) {
        const availableSpace = part.capacity - part.occupied;
        if (availableSpace >= toySize) {
            available.push({
                key: partKey,
                name: part.name,
                available: availableSpace
            });
        }
    }
    
    return available;
}

function getBodyPartsHoldingToy(toyId) {
    const holding = [];
    
    for (const [partKey, part] of Object.entries(bodyPartState)) {
        if (part.items.includes(toyId)) {
            holding.push({
                key: partKey,
                name: part.name
            });
        }
    }
    
    return holding;
}

// Add/Remove Task Functions
function createAddToyTask(toyKey, toyName) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_'); // Handle IDs like "stick_a" or "stick_m"
    
    let heldCount = 0;
    for (const part of Object.values(bodyPartState)) {
        heldCount += part.items.filter(item => item === toyId).length;
    }
    
    const totalAvailable = toyQuantities[toyKey] || 0;
    if (heldCount >= totalAvailable) {
        return null;
    }
    
    const availableParts = getAvailableBodyPartsForToy(toyId);
    
    if (availableParts.length === 0) {
        return null;
    }
    
    const targetPart = availableParts[Math.floor(Math.random() * availableParts.length)];
    
    return {
        type: 'add',
        toyId: toyId,
        toyKey: toyKey,
        toyName: toyName,
        bodyPart: targetPart.key,
        bodyPartName: targetPart.name,
        execute: function() {
            return addToyToBodyPart(this.bodyPart, this.toyId);
        },
        getHTML: function() {
            return `<strong>üì• Pick Up Task</strong><p>Pick up the ${this.toyName} and hold it in your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">This toy will stay with you until a task tells you to put it down.</p>`;
        }
    };
}

function createRemoveToyTask(toyKey, toyName) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_'); // Handle IDs like "stick_a" or "stick_m"
    const holdingParts = getBodyPartsHoldingToy(toyId);
    
    if (holdingParts.length === 0) {
        return null;
    }
    
    const targetPart = holdingParts[Math.floor(Math.random() * holdingParts.length)];
    
    return {
        type: 'remove',
        toyId: toyId,
        toyKey: toyKey,
        toyName: toyName,
        bodyPart: targetPart.key,
        bodyPartName: targetPart.name,
        execute: function() {
            return removeToyFromBodyPart(this.bodyPart, this.toyId);
        },
        getHTML: function() {
            return `<strong>üì§ Put Down Task</strong><p>Put down the ${this.toyName} from your ${this.bodyPartName}.</p><p style="color: #666; font-size: 0.9em;">You can now use this body part freely again.</p>`;
        }
    };
}

function shouldRollAddTask(toyKey) {
    const modifier = toyModifiers[toyKey];
    if (!modifier) return false;
    const roll = Math.random() * 100;
    return roll < modifier.addChance;
}

function shouldRollRemoveTask(toyKey) {
    const modifier = toyModifiers[toyKey];
    if (!modifier) return false;
    const roll = Math.random() * 100;
    return roll < modifier.removeChance;
}

function toyHasAddRemoveTasks(toyKey) {
    const [setId, ...toyIdParts] = toyKey.split('_');
    const toyId = toyIdParts.join('_'); // Handle IDs like "stick_a" or "stick_m"
    
    if (!instructionSets[setId] || !instructionSets[setId].tasks[toyId]) return false;
    
    const tasks = instructionSets[setId].tasks[toyId];
    const hasAdd = tasks.some(task => task.type === 'add');
    const hasRemove = tasks.some(task => task.type === 'remove');
    
    return hasAdd && hasRemove;
}

function rollForAddRemoveTasks() {
    const addTasks = [];
    const removeTasks = [];
    
    for (const [toyKey, quantity] of Object.entries(toyQuantities)) {
        if (quantity > 0) {
            const [setId, ...toyIdParts] = toyKey.split('_');
            const toyId = toyIdParts.join('_'); // Handle IDs like "stick_a" or "stick_m"
            
            if (!isToyWearable(toyId)) continue;
            
            // Only process toys that have add/remove tasks defined
            if (!toyHasAddRemoveTasks(toyKey)) continue;
            
            if (shouldRollAddTask(toyKey)) {
                let toyName = toyId;
                
                if (instructionSets[setId]) {
                    const toy = instructionSets[setId].toys.find(t => t.id === toyId);
                    if (toy) toyName = toy.name;
                }
                
                const task = createAddToyTask(toyKey, toyName);
                if (task) addTasks.push(task);
            }
            
            if (shouldRollRemoveTask(toyKey)) {
                let toyName = toyId;
                
                if (instructionSets[setId]) {
                    const toy = instructionSets[setId].toys.find(t => t.id === toyId);
                    if (toy) toyName = toy.name;
                }
                
                const task = createRemoveToyTask(toyKey, toyName);
                if (task) removeTasks.push(task);
            }
        }
    }
    
    const allTasks = [...addTasks, ...removeTasks];
    if (allTasks.length > 0) {
        return allTasks[Math.floor(Math.random() * allTasks.length)];
    }
    
    return null;
}

// Metronome Task
function createMetronomeTask(beatCount) {
    let metronomeInterval = null;
    let countdownInterval = null;
    let isComplete = false;
    
    const wrapper = document.createElement('div');
    const textDiv = document.createElement('div');
    textDiv.innerHTML = '<strong>üèÄ Bounce to the Beat!</strong><p>Bounce the basketball in rhythm.</p>';
    wrapper.appendChild(textDiv);
    
    const container = document.createElement('div');
    container.className = 'metronome-container';
    container.innerHTML = `
        <div class="metronome-beat" id="metronomeBeat"></div>
        <div class="metronome-display" id="metronomeDisplay">Ready?</div>
        <button class="metronome-btn" id="startMetronome">‚ñ∂Ô∏è Start</button>
    `;
    wrapper.appendChild(container);
    
    const startBtn = container.querySelector('#startMetronome');
    const display = container.querySelector('#metronomeDisplay');
    const beat = container.querySelector('#metronomeBeat');
    
    startBtn.addEventListener('click', function() {
        startBtn.disabled = true;
        let count = 3;
        display.textContent = count;
        
        countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                display.textContent = count;
            } else {
                clearInterval(countdownInterval);
                display.textContent = "Bounce!";
                startMetronome();
            }
        }, 1000);
    });
    
    function playBeep() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.type = 'sine';
        osc.frequency.value = 440;
        gain.gain.setValueAtTime(0.3, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
        osc.start(audioContext.currentTime);
        osc.stop(audioContext.currentTime + 0.05);
    }
    
    function startMetronome() {
        let beatsLeft = beatCount;
        const bpm = 100;
        const interval = 60000 / bpm;
        
        function doBeat() {
            beatsLeft--;
            beat.classList.add('active');
            playBeep();
            display.textContent = `${beatsLeft} bounces left`;
            
            setTimeout(() => {
                beat.classList.remove('active');
            }, 100);
            
            if (beatsLeft <= 0) {
                clearInterval(metronomeInterval);
                display.textContent = "Complete! ‚úì";
                isComplete = true;
                continueButton.disabled = false;
                continueButton.style.opacity = '1';
            }
        }
        
        doBeat();
        metronomeInterval = setInterval(doBeat, interval);
        continueButton.disabled = true;
        continueButton.style.opacity = '0.5';
    }
    
    return {
        element: wrapper,
        isComplete: () => isComplete,
        cleanup: () => {
            if (metronomeInterval) clearInterval(metronomeInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        },
        hasStarted: () => startBtn.disabled
    };
}

// Red Light Green Light Task
function createRedLightGreenLightTask(totalDuration) {
    let gameInterval = null;
    let countdownInterval = null;
    let isComplete = false;
    let timeRemaining = totalDuration;
    
    const imagePatterns = [
        {image: 'chair.jpg', name: 'Chair', type: 'red'},
        {image: 'broom.jpg', name: 'Broom', type: 'green'},
        {image: 'hat.jpg', name: 'Hat', type: 'red'},
        {image: 'ball.jpg', name: 'Ball', type: 'green'},
        {image: 'books.jpg', name: 'Books', type: 'red'},
        {image: 'car.jpg', name: 'Car', type: 'green'},
        {image: 'tree.jpg', name: 'Tree', type: 'red'},
        {image: 'guitar.jpg', name: 'Guitar', type: 'green'},
        {image: 'apple.jpg', name: 'Apple', type: 'red'},
        {image: 'bike.jpg', name: 'Bike', type: 'green'}
    ];
    
    const lightPatterns = [
        {duration: 2000}, {duration: 1500}, {duration: 1500}, {duration: 2500},
        {duration: 1000}, {duration: 3000}, {duration: 2000}, {duration: 1500}
    ];
    
    const container = document.createElement('div');
    container.className = 'metronome-container';
    container.style.background = 'linear-gradient(135deg, #845ef7 0%, #5f3dc4 100%)';
    container.innerHTML = `
        <div><strong>üö¶ Red Light, Green Light!</strong></div>
        <p style="color: white; margin: 10px 0;">üü¢ GREEN = Jump! | üî¥ RED = Stop!</p>
        <div style="background: rgba(255, 255, 255, 0.2); border-radius: 15px; padding: 20px; margin: 15px 0;">
            <div style="width: 150px; height: 150px; margin: 0 auto 10px; background: white; border-radius: 10px; display: flex; align-items: center; justify-content: center; overflow: hidden;" id="imageContainer">
                <div style="font-size: 3em; color: #845ef7;">üö¶</div>
            </div>
            <div style="color: white; font-size: 1.2em; font-weight: bold;" id="imageName">Get Ready!</div>
        </div>
        <div style="width: 120px; height: 120px; border-radius: 50%; background: rgba(255, 255, 255, 0.3); margin: 20px auto; display: flex; align-items: center; justify-content: center; font-size: 4em; transition: all 0.3s ease;" id="lightIndicator">‚è∏Ô∏è</div>
        <div class="metronome-display" id="lightDisplay">Press Start!</div>
        <div style="color: white; font-size: 18px; margin: 10px 0;" id="timeDisplay"></div>
        <button class="metronome-btn" id="startRedLight">‚ñ∂Ô∏è Start</button>
    `;
    
    const startBtn = container.querySelector('#startRedLight');
    const display = container.querySelector('#lightDisplay');
    const lightIndicator = container.querySelector('#lightIndicator');
    const timeDisplay = container.querySelector('#timeDisplay');
    const imageContainer = container.querySelector('#imageContainer');
    const imageName = container.querySelector('#imageName');
    
    startBtn.addEventListener('click', function() {
        startBtn.disabled = true;
        let count = 3;
        imageContainer.innerHTML = `<div style="font-size: 4em; color: #845ef7;">${count}</div>`;
        imageName.textContent = 'Starting...';
        lightIndicator.textContent = '‚è≥';
        display.textContent = 'Get ready...';
        
        countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                imageContainer.innerHTML = `<div style="font-size: 4em; color: #845ef7;">${count}</div>`;
            } else {
                clearInterval(countdownInterval);
                startGame();
            }
        }, 1000);
    });
    
    function startGame() {
        let currentImageIndex = 0;
        let currentPatternIndex = 0;
        
        function showNextLight() {
            if (timeRemaining <= 0) {
                clearInterval(gameInterval);
                display.textContent = "Game Complete! ‚úì";
                lightIndicator.textContent = "‚úì";
                lightIndicator.style.background = "linear-gradient(135deg, #51cf66 0%, #37b24d 100%)";
                imageContainer.innerHTML = '<div style="font-size: 4em; color: #51cf66;">üéâ</div>';
                imageName.textContent = "Great Job!";
                timeDisplay.textContent = "";
                isComplete = true;
                continueButton.disabled = false;
                continueButton.style.opacity = '1';
                return;
            }
            
            const currentImage = imagePatterns[currentImageIndex];
            const pattern = lightPatterns[currentPatternIndex];
            
            imageContainer.innerHTML = `<img src="${currentImage.image}" alt="${currentImage.name}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'font-size: 3em; color: #845ef7;\\'>${currentImage.name[0]}</div>';">`;
            imageName.textContent = currentImage.name;
            lightIndicator.textContent = currentImage.type === 'green' ? 'üü¢' : 'üî¥';
            display.textContent = currentImage.type === 'green' ? 'GREEN LIGHT - JUMP!' : 'RED LIGHT - STOP!';
            
            if (currentImage.type === 'green') {
                lightIndicator.style.background = 'linear-gradient(135deg, #51cf66 0%, #37b24d 100%)';
                lightIndicator.style.transform = 'scale(1.2)';
            } else {
                lightIndicator.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)';
                lightIndicator.style.transform = 'scale(1)';
            }
            
            const displayDuration = Math.min(pattern.duration, timeRemaining);
            timeRemaining -= displayDuration;
            timeDisplay.textContent = `${Math.ceil(timeRemaining / 1000)}s remaining`;
            
            setTimeout(() => {
                currentImageIndex++;
                if (currentImageIndex >= imagePatterns.length) {
                    currentImageIndex = 0;
                }
                currentPatternIndex++;
                if (currentPatternIndex >= lightPatterns.length) {
                    currentPatternIndex = 0;
                }
                showNextLight();
            }, displayDuration);
        }
        
        continueButton.disabled = true;
        continueButton.style.opacity = '0.5';
        showNextLight();
    }
    
    return {
        element: container,
        isComplete: () => isComplete,
        cleanup: () => {
            if (gameInterval) clearInterval(gameInterval);
            if (countdownInterval) clearInterval(countdownInterval);
        },
        hasStarted: () => startBtn.disabled
    };
}

// Board Functions
function createBoard() {
    let reverse = false;
    let currentNumber = 1;
    
    for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col < boardSize; col++) {
            const actualCol = reverse ? boardSize - col - 1 : col;
            const square = document.createElement('div');
            square.classList.add('square');
            square.textContent = currentNumber;
            square.id = `square-${currentNumber}`;
            square.style.gridRow = boardSize - row;
            square.style.gridColumn = actualCol + 1;
            
            if (snakes[currentNumber]) {
                square.classList.add('snake');
                square.setAttribute('data-destination', '‚Üì' + snakes[currentNumber]);
            } else if (ladders[currentNumber]) {
                square.classList.add('ladder');
                square.setAttribute('data-destination', '‚Üë' + ladders[currentNumber]);
            }
            
            board.appendChild(square);
            currentNumber++;
        }
        reverse = !reverse;
    }
}

function animatePlayer(start, end, callback, instant = false) {
    if (instant) {
        const targetSquare = document.getElementById(`square-${end}`);
        if (targetSquare) targetSquare.appendChild(player);
        if (callback) callback();
        return;
    }
    
    let current = start;
    const step = current < end ? 1 : -1;
    
    const interval = setInterval(() => {
        current += step;
        const currentSquare = document.getElementById(`square-${current}`);
        if (currentSquare) currentSquare.appendChild(player);
        
        if (current === end) {
            clearInterval(interval);
            if (callback) callback();
        }
    }, 200);
}

// Toy Selection Functions
function getSelectedToys() {
    const allToys = [];
    for (const [toyKey, quantity] of Object.entries(toyQuantities)) {
        if (quantity > 0) {
            const [setId, toyId] = toyKey.split('_');
            
            if (toyChecked[toyId] && toySetEnabled[toyKey]) {
                allToys.push({
                    toyId,
                    setId,
                    difficulty: toyDifficulties[toyKey] || 'medium'
                });
            }
        }
    }
    return allToys;
}

function displayRandomInstruction() {
    const toys = getSelectedToys();
    
    if (currentMetronomeTask) {
        currentMetronomeTask.cleanup();
        currentMetronomeTask = null;
    }
    
    if (toys.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>üéØ Select instruction sets and toys to get started!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const randomToyObj = toys[Math.floor(Math.random() * toys.length)];
    const tasks = instructionSets[randomToyObj.setId].tasks[randomToyObj.toyId];
    
    if (!tasks || tasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>No tasks available for this toy!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const conditions = getTaskConditions();
    const availableTasks = tasks.filter(task => !task.canSelect || task.canSelect(conditions));
    
    if (availableTasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>No available tasks for current conditions!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const randomTask = availableTasks[Math.floor(Math.random() * availableTasks.length)];
    window.lastTaskInfo = {
        toyId: randomToyObj.toyId,
        setId: randomToyObj.setId,
        difficulty: randomToyObj.difficulty,
        taskType: randomTask.type || 'normal'
    };
    
    instructions.classList.add('active');
    
    if (randomTask.type === 'metronome') {
        const beatCount = randomTask.getDifficulty(randomToyObj.difficulty, conditions);
        window.lastTaskInfo.beatCount = beatCount;
        currentMetronomeTask = createMetronomeTask(beatCount);
        instructions.innerHTML = '';
        instructions.appendChild(currentMetronomeTask.element);
    } else if (randomTask.type === 'redlight') {
        const duration = randomTask.getDifficulty(randomToyObj.difficulty, conditions);
        window.lastTaskInfo.duration = duration;
        currentMetronomeTask = createRedLightGreenLightTask(duration);
        instructions.innerHTML = '';
        instructions.appendChild(currentMetronomeTask.element);
    } else {
        const content = randomTask.getDifficulty(randomToyObj.difficulty, conditions);
        instructions.innerHTML = content;
    }
}

function displayRandomInstructionWithAddRemove(addRemoveTask) {
    const toys = getSelectedToys();
    
    if (currentMetronomeTask) {
        currentMetronomeTask.cleanup();
        currentMetronomeTask = null;
    }
    
    if (toys.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>üéØ Select instruction sets and toys to get started!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const randomToyObj = toys[Math.floor(Math.random() * toys.length)];
    const tasks = instructionSets[randomToyObj.setId].tasks[randomToyObj.toyId];
    
    if (!tasks || tasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>No tasks available for this toy!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const conditions = getTaskConditions();
    const availableTasks = tasks.filter(task => !task.canSelect || task.canSelect(conditions));
    
    if (availableTasks.length === 0) {
        instructions.classList.add('active');
        instructions.innerHTML = "<div>No available tasks for current conditions!</div>";
        window.lastTaskInfo = null;
        return;
    }
    
    const randomTask = availableTasks[Math.floor(Math.random() * availableTasks.length)];
    window.lastTaskInfo = {
        toyId: randomToyObj.toyId,
        setId: randomToyObj.setId,
        difficulty: randomToyObj.difficulty,
        taskType: randomTask.type || 'normal'
    };
    
    instructions.classList.add('active');
    
    let addRemoveHTML = '';
    if (addRemoveTask) {
        const html = addRemoveTask.getHTML();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const strong = doc.querySelector('strong');
        const paragraphs = doc.querySelectorAll('p');
        let text = '';
        if (strong) text += `<strong>${strong.textContent}</strong>`;
        paragraphs.forEach(p => text += `<p>${p.textContent}</p>`);
        addRemoveHTML = text;
    }
    
    if (randomTask.type === 'metronome') {
        const beatCount = randomTask.getDifficulty(randomToyObj.difficulty, conditions);
        window.lastTaskInfo.beatCount = beatCount;
        currentMetronomeTask = createMetronomeTask(beatCount);
        instructions.innerHTML = addRemoveHTML;
        instructions.appendChild(currentMetronomeTask.element);
    } else if (randomTask.type === 'redlight') {
        const duration = randomTask.getDifficulty(randomToyObj.difficulty, conditions);
        window.lastTaskInfo.duration = duration;
        currentMetronomeTask = createRedLightGreenLightTask(duration);
        instructions.innerHTML = addRemoveHTML;
        instructions.appendChild(currentMetronomeTask.element);
    } else {
        const content = randomTask.getDifficulty(randomToyObj.difficulty, conditions);
        instructions.innerHTML = addRemoveHTML + content;
    }
}

// Render Toy Library  
function renderToyLibrary() {
    selectedSets = Array.from(document.querySelectorAll('#instructionSetCheckboxes input:checked'))
        .map(cb => cb.value);
    
    const container = document.getElementById('toyLibraryContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (selectedSets.length === 0) {
        container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px; background: white; border-radius: 10px; border: 2px solid #667eea;">Select instruction sets above to see available toys</p>';
        return;
    }
    
    const setEmojis = {dressup: 'üé®', apple: 'üçé', digging: '‚õèÔ∏è', tnd: 'üéØ'};
    const allToys = {};
    
    selectedSets.forEach(setId => {
        if (instructionSets[setId]) {
            instructionSets[setId].toys.forEach(toy => {
                if (!allToys[toy.id]) {
                    allToys[toy.id] = {id: toy.id, name: toy.name, sets: []};
                }
                allToys[toy.id].sets.push({
                    setId,
                    setName: instructionSets[setId].name,
                    emoji: setEmojis[setId] || ''
                });
            });
        }
    });
    
    for (const [toyId, toyData] of Object.entries(allToys)) {
        const toyItem = document.createElement('div');
        toyItem.className = 'toy-library-item';
        
        const toyKeys = toyData.sets.map(s => `${s.setId}_${toyId}`);
        
        toyKeys.forEach(key => {
            if (toyQuantities[key] === undefined) toyQuantities[key] = 1;
            if (!toyModifiers[key]) toyModifiers[key] = {addChance: 10, removeChance: 20};
            if (!toyDifficulties[key]) toyDifficulties[key] = 'medium';
            if (toySetEnabled[key] === undefined) toySetEnabled[key] = true;
        });
        
        if (toyChecked[toyId] === undefined) toyChecked[toyId] = true;
        
        const enabledKeys = toyKeys.filter(key => toySetEnabled[key]);
        
        const toyQuantity = toyQuantities[toyKeys[0]] || 1;
        
        const header = document.createElement('div');
        header.className = 'toy-header';
        
        const checkboxWrapper = document.createElement('div');
        checkboxWrapper.className = 'toy-checkbox-wrapper';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = toyChecked[toyId];
        checkbox.style.cursor = 'pointer';
        checkbox.onchange = () => {
            toyChecked[toyId] = checkbox.checked;
            renderToyLibrary();
            saveGameState();
        };
        checkboxWrapper.appendChild(checkbox);
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'toy-name';
        nameSpan.textContent = toyData.name;
        
        header.appendChild(checkboxWrapper);
        header.appendChild(nameSpan);
        toyItem.appendChild(header);
        
        const controls = document.createElement('div');
        controls.className = 'toy-controls';
        
        const qtyLabel = document.createElement('label');
        qtyLabel.textContent = 'Qty:';
        controls.appendChild(qtyLabel);
        
        const qtyInput = document.createElement('input');
        qtyInput.type = 'number';
        qtyInput.min = '1';
        qtyInput.value = toyQuantity;
        qtyInput.id = `qty_total_${toyId}`;
        qtyInput.disabled = !toyChecked[toyId];
        qtyInput.onchange = () => {
            const newQty = Math.max(1, parseInt(qtyInput.value) || 1);
            toyKeys.forEach(key => {
                toyQuantities[key] = newQty;
            });
            renderToyLibrary();
            saveGameState();
        };
        controls.appendChild(qtyInput);
        toyItem.appendChild(controls);
        
        const setDifficultyContainer = document.createElement('div');
        setDifficultyContainer.className = 'set-difficulty';
        
        toyData.sets.forEach(setInfo => {
            const toyKey = `${setInfo.setId}_${toyId}`;
            const setItem = document.createElement('div');
            setItem.className = 'set-difficulty-item';
            
            const diffRow = document.createElement('div');
            diffRow.className = 'difficulty-row';
            
            const setCheckboxWrapper = document.createElement('div');
            setCheckboxWrapper.style.cssText = 'display:flex;align-items:center;gap:8px;';
            
            const setCheckbox = document.createElement('input');
            setCheckbox.type = 'checkbox';
            setCheckbox.checked = toySetEnabled[toyKey];
            setCheckbox.style.cssText = 'width:16px;height:16px;cursor:pointer;accent-color:#667eea;';
            
            setCheckbox.disabled = !toyChecked[toyId];
            
            setCheckbox.onchange = () => {
                toySetEnabled[toyKey] = setCheckbox.checked;
                renderToyLibrary();
                saveGameState();
            };
            setCheckboxWrapper.appendChild(setCheckbox);
            
            const setNameSpan = document.createElement('span');
            setNameSpan.textContent = `${setInfo.emoji} ${setInfo.setName}`;
            setCheckboxWrapper.appendChild(setNameSpan);
            diffRow.appendChild(setCheckboxWrapper);
            
            const diffControls = document.createElement('div');
            diffControls.className = 'difficulty-controls';
            
            const diffSelect = document.createElement('select');
            diffSelect.id = `difficulty_${toyKey}`;
            diffSelect.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
            
            ['easy', 'medium', 'hard'].forEach(level => {
                const opt = document.createElement('option');
                opt.value = level;
                opt.textContent = level == 'easy' ? 'Easy üòä' : level == 'medium' ? 'Medium üòê' : 'Hard üò§';
                if (level == (toyDifficulties[toyKey] || 'medium')) opt.selected = true;
                diffSelect.appendChild(opt);
            });
            
            diffSelect.onchange = () => {
                toyDifficulties[toyKey] = diffSelect.value;
                applyPreset(toyKey, diffSelect.value);
                saveGameState();
            };
            diffControls.appendChild(diffSelect);
            
            const isWearable = isToyWearable(toyId);
            const hasAddRemove = toyHasAddRemoveTasks(toyKey);
            const gearBtn = document.createElement('button');
            gearBtn.className = 'gear-btn';
            gearBtn.textContent = '‚öôÔ∏è';
            gearBtn.title = !isWearable ? 'This toy cannot be worn/held' : !hasAddRemove ? 'This toy has no add/remove tasks' : 'Advanced Settings';
            gearBtn.disabled = !isWearable || !hasAddRemove || !toyChecked[toyId] || !toySetEnabled[toyKey];
            gearBtn.id = `gear_${toyKey}`;
            
            if (isWearable && hasAddRemove) {
                gearBtn.onclick = (e) => {
                    e.preventDefault();
                    const advSettings = setItem.querySelector('.advanced-settings');
                    if (advSettings.classList.contains('visible')) {
                        advSettings.classList.remove('visible');
                        gearBtn.classList.remove('active');
                    } else {
                        advSettings.classList.add('visible');
                        gearBtn.classList.add('active');
                    }
                };
            }
            diffControls.appendChild(gearBtn);
            diffRow.appendChild(diffControls);
            setItem.appendChild(diffRow);
            
            if (isWearable && hasAddRemove) {
                const advSettings = document.createElement('div');
                advSettings.className = 'advanced-settings';
                
                const addLabel = document.createElement('label');
                addLabel.textContent = 'Add: ';
                const addInput = document.createElement('input');
                addInput.type = 'number';
                addInput.min = '0';
                addInput.max = '100';
                addInput.value = toyModifiers[toyKey]?.addChance || 25;
                addInput.id = `add_${toyKey}`;
                addInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
                addInput.oninput = (e) => {
                    const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                    e.target.value = val;
                    if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                    toyModifiers[toyKey].addChance = val;
                    saveGameState();
                };
                addLabel.appendChild(addInput);
                const addPercent = document.createTextNode('%');
                addLabel.appendChild(addPercent);
                advSettings.appendChild(addLabel);
                
                const removeLabel = document.createElement('label');
                removeLabel.textContent = 'Remove: ';
                const removeInput = document.createElement('input');
                removeInput.type = 'number';
                removeInput.min = '0';
                removeInput.max = '100';
                removeInput.value = toyModifiers[toyKey]?.removeChance || 15;
                removeInput.id = `remove_${toyKey}`;
                removeInput.disabled = !toyChecked[toyId] || !toySetEnabled[toyKey];
                removeInput.oninput = (e) => {
                    const val = Math.max(0, Math.min(100, parseInt(e.target.value) || 0));
                    e.target.value = val;
                    if (!toyModifiers[toyKey]) toyModifiers[toyKey] = {addChance: 10, removeChance: 20};
                    toyModifiers[toyKey].removeChance = val;
                    saveGameState();
                };
                removeLabel.appendChild(removeInput);
                const removePercent = document.createTextNode('%');
                removeLabel.appendChild(removePercent);
                advSettings.appendChild(removeLabel);
                
                setItem.appendChild(advSettings);
            }
            
            setDifficultyContainer.appendChild(setItem);
        });
        
        toyItem.appendChild(setDifficultyContainer);
        container.appendChild(toyItem);
    }
    
    saveGameState();
}

function applyPreset(toyKey, difficulty) {
    const presets = {
        easy: {addChance: 5, removeChance: 25},
        medium: {addChance: 10, removeChance: 20},
        hard: {addChance: 15, removeChance: 15}
    };
    
    if (presets[difficulty]) {
        toyModifiers[toyKey] = {...presets[difficulty]};
        toyDifficulties[toyKey] = difficulty;
        
        const addInput = document.getElementById(`add_${toyKey}`);
        const removeInput = document.getElementById(`remove_${toyKey}`);
        if (addInput) addInput.value = toyModifiers[toyKey].addChance;
        if (removeInput) removeInput.value = toyModifiers[toyKey].removeChance;
        
        saveGameState();
    }
}

// Event Listeners
document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => {
    cb.addEventListener('change', () => {
        renderToyLibrary();
        saveGameState();
    });
});

document.getElementById('playerNameInput').addEventListener('input', function() {
    playerName = this.value;
    saveGameState();
});

function startGame() {
    const toys = getSelectedToys();
    if (toys.length === 0) {
        alert('‚ö†Ô∏è Please select at least one toy from the instruction sets before starting!');
        return;
    }
    
    playerName = document.getElementById('playerNameInput').value.trim();
    if (!playerName) {
        alert('‚ö†Ô∏è Please enter your name before starting!');
        return;
    }
    
    gameStarted = true;
    saveGameState();
    
    startButton.style.display = 'none';
    const leftCol = document.querySelector('.settings-column-left');
    const rightCol = document.querySelector('.settings-column-right');
    if (leftCol) leftCol.style.display = 'none';
    if (rightCol) rightCol.style.display = 'none';
    
    instructions.classList.add('active');
    instructions.innerHTML = `
        <div style="font-size: 2em; font-weight: bold; color: #667eea; margin-bottom: 20px;">
            üçÄ Good Luck${playerName ? ' ' + playerName : ''}! üçÄ
        </div>
        <div style="font-size: 1.2em; color: #666; margin-bottom: 20px;">
            Roll the dice to begin!
        </div>
    `;
    
    rollDiceButton.style.display = 'block';
    diceResult.style.display = 'block';
}

function rollDice() {
    rollDiceButton.disabled = true;
    const diceRoll = Math.floor(Math.random() * 6) + 1;
    diceResult.textContent = `Dice: ${diceRoll} üé≤`;
    
    let nextPosition = playerPosition + diceRoll;
    if (nextPosition > totalSquares) nextPosition = totalSquares;
    
    let finalPosition = nextPosition;
    let showContinueButton = false;
    
    const isSnake = snakes[nextPosition];
    const isLadder = ladders[nextPosition];
    
    if (isSnake || isLadder) {
        finalPosition = isSnake ? snakes[nextPosition] : ladders[nextPosition];
        showContinueButton = true;
    }
    
    const addRemoveTask = rollForAddRemoveTasks();
    
    animatePlayer(playerPosition, nextPosition, () => {
        playerPosition = nextPosition;
        
        if (addRemoveTask) {
            addRemoveTask.execute();
        }
        
        displayRandomInstructionWithAddRemove(addRemoveTask);
        saveGameState();
        
        if (playerPosition === totalSquares) {
            rollDiceButton.disabled = true;
            const prize = determinePrize();
            instructions.innerHTML = `<div><strong>üéâ Congratulations, you've won! üéâ</strong></div>` + displayPrizeResult(prize);
            return;
        }
        
        instructions.appendChild(continueButton);
        continueButton.style.display = "block";
        
        if (showContinueButton) {
            continueButton.onclick = () => {
                if (currentMetronomeTask && !currentMetronomeTask.isComplete()) return;
                continueButton.style.display = "none";
                animatePlayer(nextPosition, finalPosition, () => {
                    playerPosition = finalPosition;
                    if (playerPosition === totalSquares) {
                        rollDiceButton.disabled = true;
                        const prize = determinePrize();
                        instructions.innerHTML = `<div><strong>üéâ Congratulations, you've won! üéâ</strong></div>` + displayPrizeResult(prize);
                        saveGameState();
                    } else {
                        rollDiceButton.disabled = false;
                        instructions.innerHTML = `<div><strong>üìç You landed on ${finalPosition}.</strong></div>`;
                        displayRandomInstruction();
                        saveGameState();
                    }
                }, true);
            };
        } else {
            continueButton.onclick = () => {
                if (currentMetronomeTask && !currentMetronomeTask.isComplete()) return;
                continueButton.style.display = "none";
                rollDiceButton.disabled = false;
            };
        }
    });
}

// Modal Functions
const modal = document.getElementById('patchNotesModal');
const btn = document.getElementById('patchNotesBtn');
const span = document.getElementsByClassName('close-btn')[0];

btn.onclick = () => modal.style.display = 'block';
span.onclick = () => modal.style.display = 'none';
window.onclick = e => {
    if (e.target == modal) modal.style.display = 'none';
};

// Reset Functions
const resetBtn = document.getElementById('resetBtn');
const resetModal = document.getElementById('resetModal');
const confirmResetBtn = document.getElementById('confirmReset');
const cancelResetBtn = document.getElementById('cancelReset');

resetBtn.addEventListener('click', () => resetModal.style.display = 'block');
cancelResetBtn.addEventListener('click', () => resetModal.style.display = 'none');

confirmResetBtn.addEventListener('click', function() {
    resetModal.style.display = 'none';
    localStorage.removeItem('snakesLaddersGameState');
    
    gameStarted = false;
    playerPosition = 0;
    playerName = '';
    player.remove();
    bodyPartState = JSON.parse(JSON.stringify(bodyParts));
    
    startButton.style.display = 'block';
    rollDiceButton.style.display = 'none';
    rollDiceButton.disabled = false;
    continueButton.style.display = 'none';
    instructions.classList.remove('active');
    instructions.innerHTML = '';
    diceResult.textContent = 'Dice: -';
    diceResult.style.display = 'none';
    
    document.getElementById('playerNameInput').value = '';
    
    const leftCol = document.querySelector('.settings-column-left');
    const rightCol = document.querySelector('.settings-column-right');
    if (leftCol) leftCol.style.display = 'block';
    if (rightCol) rightCol.style.display = 'block';
    
    document.querySelectorAll('#instructionSetCheckboxes input').forEach(cb => cb.checked = false);
    
    toySetEnabled = {};
    toyChecked = {};
    selectedSets = [];
    toySelections = {};
    toyDifficulties = {};
    toyQuantities = {};
    toyModifiers = {};
    advancedSettingsOpen = false;
    prizeSettings = {minor: 25, major: 10, noPrize: 65};
    
    updateSliderDisplays();
    renderToyLibrary();
});

// Initialize
startButton.addEventListener('click', startGame);
rollDiceButton.addEventListener('click', rollDice);
createBoard();
renderToyLibrary();

loadGameState();
    </script>
</body>
</html>
